<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Полиморфизм, третья часть</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6/chapter0#contents">&laquo; К оглавлению</a>
    <div style="display: flex;width: 50%;justify-content: space-between;">
        <a href="/fcim_poo_21.6/chapter7">&lsaquo; Шаблоны типов</a>
        <a href="/fcim_poo_21.6/chapter8">&Uarr; Вверх</a>
    </div>
</header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">

    <table width="75%" align="center" border="0" cellpadding="2">
        <tr>
            <td width="80%">

<div align="left">
    <h4>Полиморфизм, третья часть</h4>
</div>
<div align="justify">

<p>
    Напоследок можно было бы подумать о том, как сделать такой тип данных, который представляет рациональные числа во всей их полноте; например, этот тип самостоятельно определяет, показывать только целую часть или всю дробь, в зависимости от значений числителя и знаменателя.
</p>
<p>
    Проверенный временем способ, использующийся для достижения такого уровня функциональности – “объединение”, тип данных <code>union</code>. Следует напомнить, что этот тип является специальным видом структуры, которая может содержать несколько переменных, как любая другая структура, но памяти потребляет ровно столько, сколько нужно для хранения самой “большой” из объявленных переменных. Например, для упрощенной формы типа <code>rational</code>:
</p>
<pre><code>
class rational {
public:
    int p{1};
    int q{1};
};

<b>union</b> r_int_variant {
    int a{0};
    rational r;
};        
</code></pre>
<p>
    Здесь объект структуры <code>union r_int_variant</code> будет занимать в памяти не 12 байтов, как может сначала показаться (по 4 байта для каждого поля с типом <code>int</code>), а 8 – ровно столько, сколько нужно для хранения поля <code>r</code>. Благодаря этому для инициализации поля <code>a</code> будет использоваться тот же адрес, что и для инициализации поля <code>r</code>. Очевидно, что в таких условиях эти поля не могут существовать в памяти одновременно, изменение одного будет стирать значение другого.
</p>
<p>
    Это свойство объединений можно использовать для цели, обозначенной выше. Так как одновременно в объединении может существовать только целое или дробное представление, проблема заключается в правильной инициализации и контролировании операции присваивания. Для этого нужно следить за тем, какое из полей последний раз было инициализировано, благодаря чему можно определить к какому из полей нужно обращаться в тот или иной момент.
</p>
<pre><code>
class r_int {
public:
    int _type;
    r_int_variant data;
};

<b>#define</b> r_int_cons(c, val) if(                   \
    ((sizeof(val) == sizeof(int))                \
            ? (c._type = ((c.data.a = val), 2))  \
            : (c._type = ((c.data.r = val), 1))))
</code></pre>
<p>
    В примере выше код написан ближе к тому, как он бы выглядел в языке <b>С</b>. Роль непосредственного типа играет специальный класс, который контролирует доступ к объединению с данными. Специальный “флаг” – переменная <code>_type</code> – следит за тем, какое из полей объединения сейчас инициализировано. Для инициализации используется <b>“макро”</b> – именованная инструкция, которая автоматически выставляет “флаг” согласно размеру переданного аргумента.
</p>
<pre><code>
r_int u;
r_int_cons(u, 1);
</code></pre>
<p>
    Очень быстро становится очевидным главный минус такого подхода: следить за изменением значения “флага” нужно очень внимательно, иначе работа программы может нарушиться. Проверять значение “флага” придется при каждой операции над объектами такого класса. Не говоря уже о том, что такой метод контроля за значениями “флага” не будет работать, если размеры полей совпадают.
</p>
<p>
    Естественно, все эти операции можно включить в новый класс в виде методов, скрыть “флаг” и данные от прямого внешнего воздействия. Создатели <b>С++</b> именно так и поступили, добавив в язык библиотеку <b>variant</b> [CPP(f)].
</p>
<pre><code>
<b>std::variant</b>&lt;int, rational> v(1);
std::cout &lt;&lt; <b>std::get</b>&lt;int>(v) &lt;&lt; "\n";

<b>std::variant</b>&lt;int, rational> w(rational(4, 5));
std::cout &lt;&lt; <b>std::get</b>&lt;rational>(w) &lt;&lt; "\n";
</code></pre>
<p>
    Класс <code>std::variant</code> использует шаблоны типов для того, чтобы правильно инициализировать память. Он следит за тем, какой из типов в каждый конкретный момент доступен для переменной. Чтобы получить значение, которое хранится в переменной варианта, необходимо использовать стандартную функцию <code>std::get</code>, которую необходимо вызвать с соответствующим типом в качестве шаблонного аргумента. Функция попытается привести данные в “варианте” к указанному типу. Таким образом, если тип указан правильно, приведение сработает без ошибок, и результат функции будет содержать нужное значение. Если же тип будет указан для того поля объекта, которое в данный момент не активно, это вызовет исключение в программе.
</p>
<p>
    В отличие от способа с объединением, данный метод позволяет работать только с абстракциями. Более того, исключения можно обработать и предотвратить ошибки программы даже в случае неправильно указанного типа. Тем не менее, в целом данный способ не намного лучше предыдущего, так как вам все равно придется следить за тем, что вы правильно указываете тип и обрабатываете исключения, точно так же, как вам пришлось бы следить за тем, к какому полю класса вы обращаетесь, и какое значение “флага” действительно в данный момент в случае с объединением.
</p>
<p>
    Данную проблему можно решить как минимум еще одним способом – через <b>множественное наследование</b>. Работает оно именно так, как звучит: у конкретного класса может быть два и более родительских класса. Это значит, что при инициализации такого объекта в нем будет содержаться соответствующее количество анонимных объектов наследуемых классов со своими полями, а значит посредством одного дочернего объекта будут доступны все их операции.
</p>
<p>
    Исходя из этого можно сделать один важный вывод. Если родительские объекты являются родственными, со множеством пересекающихся методов, их структура в дочернем объекте может стать очень запутанной. Поэтому множественное наследование как инструмент в основном используется в случаях, когда имеется несколько никак друг с другом не связанных классов<sup>1</sup>, но при этом их интерфейсы необходимо объединить в одном типе данных. Похожего эффекта можно добиться либо через <b>абстрактные классы-интерфейсы</b> (так делается в языках программирования, где множественное наследование не поддерживается), либо через <b>композицию объектов</b> (явное включение требуемых классов в качестве полей нового класса).
</p>
<p>
    Пример, описываемый в этой главе, к таким случаям не относится. Наоборот, цель заключается в том, чтобы объединить в рамках одного повернутого к пользователю класса (“рациональные числа”) возможности двух других родственных типов (“целые числа” и “дробные числа”). Это вызовет определенные трудности, но можно представить простой пример реализации такого отношения между типами данных.
</p>
<pre><code>
class r_int <b>: rational, integer</b> {
public:
    r_int() = delete;
    r_int(int x) : rational(x, 1), integer(x) {}
    r_int(int x, int y) : rational(x, y), integer(x) {}
    friend std::ostream &operator&lt;&lt;(std::ostream &os, const r_int &obj) {
        if(obj.q == 1) os &lt;&lt; obj.x;
        else os &lt;&lt; obj.p &lt;&lt; "/" &lt;&lt; obj.q;
        return os;
    }
};
</code></pre>
<p>
    Тип <code>integer</code>, включенный в иерархию наследования, является простой “оберткой” встроенного типа <code>int</code> – поле нужного типа оборачивается в класс для того, чтобы добавить в один с полем контекст необходимые операции и наследовать примитивный тип. В качестве примера операции с переменным результатом реализован <b>оператор вывода</b>. Так как оператор вывода вызывается только на объекты типов, определенных в библиотеке <b>iostream</b>, его перегрузка внутри других классов обязана быть дружественной функцией (помните, что для обычных методов есть обязательно условие – неявный указатель на сам объект, <code>this</code>). Первый аргумент – это ссылка на объект потока, в который будет осуществлен вывод; второй – объект, который надо поместить в поток вывода.
</p>
<pre><code>
r_int x(1);
std::cout &lt;&lt; x;
</code></pre>
<p>
    В этом случае будет вызван оператор вывода, перегруженный в классе <code>r_int</code>, первым аргументом для него будет объект <code>std::cout</code>, а вторым – объект <code>x</code>. Этот фрагмент кода выведет в поток строку <code>“1”</code>, а код ниже строку <code>“4/5"</code>:
</p>
<pre><code>
r_int y(4, 5);
std::cout &lt;&lt; y;
</code></pre>
<p>
    Как вы помните, дружественные функции не имеют доступа к скрытым полям анонимного объекта родительского типа, поэтому в классах <code>rational</code> и <code>integer</code> необходимо использовать метку <code>protected</code> вместо метки <code>private</code>.
</p>
<pre><code>
class integer {
public:
    integer(int a) : x(a) {}
    <b>// остальные методы</b>
protected:
    int x{0};
};

class rational {
public:
    rational(int x, int y) { <b>...</b> }
    <b>// остальные методы</b>
protected:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    Аналогично оператору вывода можно перегрузить все остальные операторы, либо использовать те, которые перегружены для родительских типов.
</p>

<br>&nbsp;<br>

<h4>Упражнения</h4>
<p>
    Предположим, что перед вами стоит задача интегрировать в иерархию наследования, показанную в этой главе, классы, которые рассматривались в предыдущих главах (<code>number</code>, <code>positive_integer</code> и т.д.). Иерархия, реализованная в этой главе, может быть схематично представлена как сходящиеся к типу <code>r_int</code> ветви.
</p>
<figure>
    <img
        src="assets/rational_hier_simp.png"
        alt="Диаграмма классов для иерархии множественного наследования"
        height="200" />
    <figcaption>Диаграмма классов для иерархии множественного наследования.</figcaption>
</figure>
<p>
    Если в иерархию добавить общий для целых и дробных чисел базовый класс “Числа”, при инициализации объекта копия этого класса будет содержаться и в объекте типа “Целое”, и в объекте “Дробное”.
</p>
<figure>
    <img
        src="assets/rational_hier_diamond.png"
        alt="Диаграмма классов для иерархии ромбовидного наследования"
        height="350" />
    <figcaption>Диаграмма классов для иерархии ромбовидного наследования.</figcaption>
</figure>
<p>
    Но вы уже знаете, что в объекте “Рациональное” при инициализации будут созданы копии объектов и “Целого”, и “Дробного” типов. Отсюда можно сделать вывод, что из объекта типа “Рациональное” будет <b>доступ к двум разным объектам типа “Число”</b>, так как тип “Рациональное” по факту наследует тип “Число” дважды. Если попытаться обратиться к одному из них изнутри класса “Рациональное”, какая из копий будет использоваться?
</p>
<p>
    Такая ромбовидная<sup>2</sup> структура иерархии наследования намекает на возможные проблемы в программах в будущем. Необходимо заставить компилятор не создавать лишние копии объектов при построении объекта, который расположен внизу иерархии. Конечно, в описании класса “Рациональное” можно явно указывать: к какой именно из двух копий обращаться, используя пространства имен. Но это нужно будет делать везде, что не очень удобно.
</p>
<button>Пример решения</button>
<br>&nbsp;<br>

<h4>Сноски</h4>
<p><sup>1</sup>Такие классы принято называть ортогональными, то есть, не пересекающимися в плоскости функциональности.</p>
<p><sup>2</sup>В специальной литературе этот феномен называется “dreaded diamond” [Standard].</p>

<br>&nbsp;<br>

                    <p>
                        Copyright &copy; 2023 Брынзан, Л. В.<br>
                        GNU General Public License<br>
                        “Commons Clause” License Condition v1.0<br>
                        GPL Attribution-ShareAlike 4.0 International<br>
                    </p>

                </div>
            </td>
        </tr>
    </table>
</body>
</html>
