<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Сокрытие данных и инкапсуляция</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header
    style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6">&laquo; К оглавлению</a>
    <div style="display: flex;width: 40%;justify-content: space-between;">
        <a href="/fcim_poo_21.6/chapter1">&laquo; Абстрактные типы данных</a>
        <a href="/fcim_poo_21.6/chapter2">&Uarr; Вверх</a>
        <a href="/fcim_poo_21.6/chapter3">Конструкторы &rsaquo;</a>
    </div>
</header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
<table width="75%" align="center" border="0" cellpadding="2">
<tr>
<td width="80%">
<div align="left"><h4>Сокрытие данных и инкапсуляция</h4></div>
<div align="justify">

<p>
    В предыдущей части вы создали структуру, которая представляет в программах дробные числа. Почти сразу же стало очевидно, что одной из проблем этой структуры является полный доступ к ее полям из любого места в программе. Это позволяет перезаписывать значения числителя и знаменателя в любой момент, в обход всех правил, которые были ранее установлены для создания рациональных чисел. Это также противоречит сути нашего типа данных, который является абстрактным согласно установленному выше дизайну. Из того, что это абстрактный тип данных, следует, что пользователь не должен изменять эти поля напрямую. А это значит, что их нужно от пользователя как-то скрыть.
</p>
<p>
    В <b>С++</b> для этого есть специальный механизм [Stroustrup]. Этот механизм позволяет запретить прямое изменение полей структуры одним из двух способов. Первый способ заключается в добавлении специального слова <code>private</code> в структуру, непосредственно над полями, которые необходимо скрыть.
</p>
<pre><code>
struct rational {
private:
    int p;
    int q;
};
</code></pre>
<p>
    Обратите внимание на двоеточие после данного слова, это напоминает <b>метки</b> в <b>С</b>, которые можно использовать для возврата к нужной строке в программе. Метка <code>private</code> делит структуру на две области: все, что находится над ней, доступно вне структуры, а все, что – под ней, скрыто и доступно только внутри структуры. В примере выше ничего кроме двух полей нет, поэтому поля <code>p</code> и <code>q</code> не доступны нигде.
</p>
<p>
    Второй способ достичь такого же эффекта – использовать ключевое слово <code>class</code> вместо <code>struct</code> в определении структуры:
</p>
<pre><code>
class rational {
    int p;
    int q;
};    
</code></pre>
<p>
    Оба подхода дают одинаковый результат, поэтому на практике можно использовать любой из них, но, как правило, <code>struct</code> используется когда какие-то поля с данными все-таки планируется сделать открытыми для изменений, а <code>class</code> – когда поля должны быть скрыты от внешнего мира<sup>1</sup>.
</p>
<p>
    Независимо от того, какой метод будет выбран<sup>2</sup>, эффект будет один: программа из предыдущей главы перестанет работать, так как создать “хорошую” переменную типа <code>rational</code> – ни напрямую, ни с помощью функции <code>cons</code> – будет нельзя. Доступ к полям <code>p</code> и <code>q</code> теперь возможен только внутри класса, а никакого другого кода там нет, поэтому и сами поля будут оставаться неизменными в течение жизни созданного объекта такого типа. Если бы вы писали программу в строгом соответствии с правилами языка <b>С</b>, на этом история типа <code>rational</code> бы и закончилась, так как никакой пользы в программах такие объекты бы не приносили. Собственно, в <b>С</b> нет прямых механизмов сокрытия данных, потому что <b>С</b> создавался совсем для других целей (для написания ядра операционной системы Unix, например [Ritchie]). Конечно, добавив такую возможность в <b>С++</b>, его авторы добавили и способы работы с внутренними полями. Хорошая новость заключается в том, что вам почти ничего не надо менять для этого. Достаточно взять функцию <code>cons</code> и перенести ее внутрь самого класса.
</p>
<pre><code>
class rational {
public:
    static rational cons(int x, int y) {
        assert(y != 0);
        rational r;
        if(x == 0) {
            r.p = 0;
            r.q = 0;
        }
        else if(y &lt; 0) {
            r.p = -x;
            r.q = -y;
        }
        else {
            r.p = x;
            r.q = y;
        }
        return r;
    }
private:
    int p;
    int q;
};        
</code></pre>
<p>
    Особое внимание стоит обратить на ключевое слово <code>static</code>, которое появилось перед определением функции в классе. Если вы сталкивались с этим словом в языке <b>С</b>, то знаете, что оно отвечает за доступ к отмеченному им идентификатору, статические локальные переменные можно использовать в любом месте файла, в котором они объявлены, а статические функции не видны за пределами файла, в котором объявлены (это верно и для глобальных переменных). 
</p>
<p>
    В <b>С++</b> это слово приобретает новые свойства, которые легче будет понять на конкретном примере. Допустим, что этого слова там нет. Попробуем теперь создать новую переменную, используя эту функцию. Первый же вопрос, который встанет перед вами: как вызвать функцию, которая находится внутри какого-то класса? Мы знаем, что к именам структуры необходимо обращаться либо через <b>оператор выбора</b> (<code>.</code>), либо через <b>оператор косвенного выбора</b> (<code>-&gt;</code>), в зависимости от типа данных объекта. Так как новый объект представлен типом <code>rational</code>, вызов функции мог бы выглядеть так.
</p>
<pre><code>
rational b;
b.cons(20, 50);  
</code></pre>
<p>
    Интуиция в этом случае оказалась верной. Авторы <b>С++</b> не стали изобретать велосипед и сохранили привычный синтаксис языка <b>C</b> для этого случая. Но при этом код немного потерял в лаконичности: необходимо сначала создать ничем не инициализированный объект, а потом использовать функцию, чтобы изменить его значения. Более того, это даже вводит в заблуждение, потому что такой вызов функции не изменит саму переменную <code>b</code>. Функция вернет копию нового объекта, который надо будет сохранить в <code>b</code> с помощью присваивания:  
</p>
<pre><code>
rational b = b.cons(20, 50);
</code></pre>
<p>
    Согласитесь, что такая запись выглядит странно. Ключевое слово <code>static</code> в примере выше как раз и нужно для того, чтобы исключить двоякое чтение кода. Почему <code>b</code> находится и справа, и слева от оператора присваивания? Что происходит раньше: создание переменной или вызов функции? Эту запись стоило бы сделать более понятной.
</p>
<p>
    Правда, всплывает другой нюанс. Согласно правилам языка статические функции ничего не знают об объектах того типа, которому принадлежат. Они знают только внутреннюю структуру самого типа данных. Как следствие, форма записи <code>b.cons</code> или <code>b->cons</code> для статических функций не нужна. Но и запись вида <code>rational b = cons(10, 50)</code> невозможна, потому что невозможно определить где в файле находится идентификатор <code>cons</code>. И здесь на помощь приходит <b>оператор расширения области видимости</b> (<code>::</code>), указывающий на область видимости, в которой нужно искать заданное имя. В примере выше область видимости для имени функции <code>cons</code> определена границами класса <code>rational</code>, а значит и обращаться к функции надо посредством имени класса:
</p>
<pre><code>
rational b = rational::cons(10, 50);
</code></pre>
<p>
    Здесь указывается на то, что функцию под таким именем нужно искать где-то внутри класса <code>rational</code>; так получилась желанная форма записи, при этом другие поля класса защищены от внешнего воздействия. Осталось обсудить возможные альтернативы такого подхода.
</p>
<p>
    Один из самых распространенных способов – создать специальные функции внутри класса, которые дают возможность изменять поля класса при соблюдении определенных правил. Такие функции называются <b>“мутаторами”</b> (от слова mutate – “изменять”) или <b>“сеттерами”</b> (от слова set – “устанавливать”).
</p>
<pre><code>
class rational {
public:
    void set_p(int x) {
        p = x;
    }
    void set_q(int x) {
        assert(x != 0);
        q = x;
    }
private:
    int p;
    int q;
};        
</code></pre>
<p>
    Фрагмент выше может показаться знакомым. Как и в самом первом примере, здесь объект под именем <code>с</code> не конструируется с этими значениями. Они задаются уже после создания переменной.
</p>
<pre><code>
rational c;
c.set_p(5);
c.set_q(10);
</code></pre>
<p>
    В одном случае объект создается с уже заданными полями и может быть использован в других контекстах, в другом случае объект необходимо как-то инициализировать во время создания – это два разных подхода к созданию объектов. Возникает закономерный вопрос, “какой из этих способов лучше?”.
</p>
<p>
    На практике они оба могут оказаться нужны, поэтому принято их комбинировать. Необходимость включения сеттеров в класс диктуется тем, какую функциональность должен предоставлять тип данных. Ведь принципиальное отличие функции <code>cons</code> от сеттеров заключается в том, что она <b>производит новый объект</b>, в то время как <b>сеттеры изменяют уже существующий</b>. Если нужно создать объект с заранее заданными полями, выбор очевиден. Если же нужно изменить свойства существующего объекта, проще вызвать сеттер, чем создавать новый объект. Хотя, на практике часто выбирают создание нового объекта, чтобы избежать <b>побочных эффектов</b>.
</p>
<p>
    С этого момента введем два новых термина. Факт группирования данных и операций над ними внутри какой-то структуры данных мы будем называть <b>инкапсуляцией</b>. Совокупность всех открытых операций (т.е. функций, которые не скрыты меткой <code>private</code>), определенных внутри класса, мы будем называть ее <b>интерфейсом</b>.
</p>

<br>&nbsp;<br>

<h4>Упражнения</h4>
<p>1</p>
<p>
    Выше были упомянуты возможные побочные эффекты при использовании сеттеров. Попробуем рассмотреть один такой эффект и подумать, как его можно избежать. В предыдущем задании была разработана функция, которая сокращает дробь. Очевидно, что если изменить значение числителя или знаменателя после сокращения, сокращать дробь придется еще раз. Было бы лучше, если бы это происходило само собой: как при конструировании объекта, так и при любых изменениях числителя или знаменателя. Это означает, что функцию <code>reduce</code> можно использовать по-разному. Можно сделать ее внешней относительно класса, используя сеттеры и геттеры<sup>3</sup> для реализации. Можно сделать ее внутренней скрытой функцией и вызывать в нужных местах. Наконец, можно сделать ее внутренней статической функцией, включив ее в интерфейс класса, чтобы ее можно было вызывать в любом месте программы. Рекомендуется попробовать самостоятельно реализовать все три варианта. В разделе с примерами представлен один из них.
</p>
<p>
    Отдельно стоит отметить, что сеттеры по своей природе нарушают <b>принцип закрытости</b> класса. Подробней об этом и других принципах будет говориться в последующих главах, однако важно иметь ввиду, что делать поля закрытыми с помощью метки <code>private</code>, а затем разрешать их изменение с помощью специальной функции может противоречить общему решению.
</p>
<button>Пример решения</button>
<p>2</p>
<p>
    Это упражнение призвано развенчать некоторые мифы, связанные с классами в <b>С++</b>. Для его выполнения понадобится некоторое знание указателей и того, как структурируется виртуальная память процесса в языке <b>С</b>. Необходимо создать переменную типа <code>rational</code>, а затем изменить ее скрытые поля данных <code>p</code> и <code>q</code>, не меняя класс <code>rational</code> и не используя сеттеры. Подумайте, как это может быть связано с указателями и с тем, как они работают в <b>С</b>.
</p>
<button>Пример решения</button>

<br>&nbsp;<br>

<h4>Сноски</h4>
<p><sup>1</sup>Если говорить конкретней, слово <b>“класс”</b> используется в ситуациях, когда необходимо подчеркнуть особенность способа управления процессов в программе, когда классы используются для создания новых типов данных, которые управляют выполнением команд через обмен сообщениями между объектами с помощью их методов [Goldberg].</p>
<p><sup>2</sup>С этого момента в тексте будет использоваться слово <code>class</code>, все области доступа будут помечены соответствующей меткой.</p>
<p><sup>3</sup>Геттер (или <b>"аксессор"</b>) – (от слова get, англ.) внутренняя функция какой-либо структуры данных, которая возвращает значение внутренних полей структуры, часто – без возможности их последующего изменения .</p>

<br>&nbsp;<br>

<p>
    Copyright &copy; 2023 Брынзан, Л. В.<br>
    GNU General Public License<br>
    “Commons Clause” License Condition v1.0<br>
    GPL Attribution-ShareAlike 4.0 International<br>
</p>

</div>
</td>
</tr>
</table>
</body>
</html>
