<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Конструкторы</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header 
    style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6#contents">&laquo; К оглавлению</a>
    <div style="display: flex;width: 50%;justify-content: space-between;">
    <a href="/fcim_poo_21.6/chapter2">&lsaquo; Сокрытие данных и инкапсуляция</a>
    <a href="/fcim_poo_21.6/chapter3">&Uarr; Вверх</a>
    <a href="/fcim_poo_21.6/chapter4">Перегрузка функций &rsaquo;</a>
    </div>
    </header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
<table width="75%" align="center" border="0" cellpadding="2">
<tr>
<td width="80%">
<div align="left"><h4>Конструкторы</h4></div>
<div align="justify">

<p>
    Понятие <b>конструктора</b> существует во многих языках программирования и также является абстракцией, основное предназначение которой – абстрагироваться от процедуры конструирования объекта в программе. Если пробежаться глазами по примерам из предыдущих частей, можно заметить постепенный переход от конструирования объектов типа <code>rational</code> вручную к делегированию этого конструирования специальной функции (<code>cons</code>). Сделав это вы установили конкретные правила конструирования объектов. Таким образом любой программист, который в будущем захотел бы воспользоваться типом данных <code>rational</code> вынужден бы был создавать переменные посредством функции <code>cons</code>.
</p>
<p>
    Здесь есть несколько тонкостей. Во-первых, было бы неплохо добиться того, чтобы объекты можно было создавать без явного вызова специальной функции. Например, если пользователь не знает, какие первоначальные значения для числителя и знаменателя задать, конструктор мог бы определять их самостоятельно. Во-вторых, было бы удобно создавать новые объекты, используя уже существующие объекты напрямую, без явного вызова геттеров и последующей передачи их в конструктор, как было сделано в одном из примеров выше:
</p>
<pre><code>
return cons(r.p, r.q);
</code></pre>
<p>
    Было бы логичней если бы оно выглядело, например, так:
</p>
<pre><code>
return rational(r);
</code></pre>
<p>
    В этом случае намерение данной инструкции выглядит более явным: вызвать специальную функцию, которая носит имя того типа данных, который будет использоваться для создания нового объекта, при этом новый объект будет создан на базе существующего.
</p>
<p>
    Это подразумевает установление для всех полей нового объекта значений на основании величин, хранящихся в соответствующих полях аргумента. Используя последний пример, новый объект, который будет создан в результате этой операции, в своем поле <code>p</code> будет содержать значение поля <code>p</code>, которое принадлежит объекту <code>r</code>, в своем поле <code>q</code> будет содержать значение поля <code>q</code>, которое принадлежит объекту <code>r</code>.
</p>
<p>
    Существуют и другие типы конструкторов. Например, вы могли бы написать такую функцию, которая создает объект типа <code>rational</code> на основании переданной строки определенного вида (для строки 
    <math display="inline">
        <mfrac><mrow><mi>3</mi></mrow><mrow><mi>2</mi></mrow></mfrac>
    </math> создать объект с полем <code>p</code> равным <math display="inline"><mi>3</mi></math>, и полем <code>q</code> равным <math display="inline"><mi>2</mi></math>). Или, как упоминалось ранее, можно было бы написать функцию, которая создает рациональные числа, в которых значения полей <code>p</code> и <code>q</code> задаются по умолчанию в том случае, если программист при создании объекта не задал их явно (например, чтобы исключить возможность появления <math display="inline"><mi>0</mi></math> в знаменателе для неинициализированного <code>q</code>).
</p>
<p>
    Для всего этого можно сделать соответствующие функции внутри заданного класса, дав этим функциям названия, которые указывают на их предназначение. И в некоторых языках программирования это пришлось бы сделать, так как они не позволяют создавать больше одного конструктора. В <b>С++</b> конструкторов может быть сколько угодно, отличаться они должны только в том, какие аргументы они принимают. Например, ниже можно посмотреть на код, который конвертирует функцию <code>cons</code> в конструктор с двумя аргументами – желаемыми значениями числителя и знаменателя.
</p>
<pre><code>
rational(int x, int y) {
    assert(y != 0);
    if(y &lt; 0) {
        p = -x;
        q = -y;
    }
    else {
        p = x;
        q = y;
    }
    if(x != 0) reduce(*this);
}
</code></pre>
<p>
    Пример выше содержит несколько синтаксических приемов, которые до сих пор в этом тексте не встречались. В соответствии с правилами <b>С++</b> у конструкторов есть ряд неявных свойств, о которых следует знать перед тем, как начать ими пользоваться.
</p>
<p>
    Первое, что бросается в глаза – отсутствие типа данных перед именем этой функции. Второе – это некий указатель <code>this</code>, используемый в последней строке функции. Третье – само имя функции повторяет имя класса, внутри которого функция задана. Это продиктовано условностями реализации стандартов языка <b>С++</b> на различных платформах. Как и в случае с меткой <code>private</code>, это условности, которые устанавливаются на уровне компилятора для удобства и соблюдения единого стандарта. Чтобы разобраться с этими нюансами, нужно в первую очередь запомнить, что конструктор – это такая же функция, как и другие функции, которая имеет ряд синтаксических особенностей.
</p>
<p>
    Первая особенность заключается в том, что на уровне кода пользователя конструкторы имеют сокращенную форму. В первую очередь, это выражается в том, что у них, как и у всех функций, находящихся внутри класса, есть <b>скрытый первый аргумент</b>. У этого аргумента есть тип и название (речь идет о ключевом слове <code>this</code> из предыдущего фрагмента). Если бы этот аргумент задавался явно, выглядеть это могло бы следующим образом.
</p>
<pre><code>
void cons(<b>rational *_this</b>, int x, int y) {
    assert(y != 0);
    if(y &lt; 0) {
        _this->p = -x;
        _this->q = -y;
    }
    else {
        _this->p = x;
        _this->q = y;
    }
    if(x != 0) rational::reduce(*_this);
}
</code></pre>
<p>
    В этом фрагменте кода нет ничего загадочного. В функцию передается адрес, по которому хранятся данные рационального числа, и посредством этого адреса функция может изменять эти данные. Единственный вопрос, который закономерно возникает: как передать этот адрес в функцию, которая скрывает аргумент <code>this</code>?
</p>
<p>
    Здесь стоит вспомнить что было сказано в предыдущей части о вызове функций, которые объявлены внутри класса. Как вы уже знаете, эти функции вызываются следующим образом (где <code>b</code> – это переменная типа <code>rational</code>):
</p>
<pre><code>
b.cons(20, 50);
</code></pre>
<p>
    Вызов такой функции возможен только посредством существующего объекта, следовательно функция изменяет состояние объекта, который ее вызывает (при этом он явно не обозначается как один из аргументов), из чего можно сделать вывод, что объект туда передан неявно.
</p>
<p>
    Этот объект передается как указатель, для удобства названный <code>this</code>, что намекает на природу изменяемого объекта. Слово “этот” указывает на переменную, которая использовалась для вызова функции (то есть, в контексте функции ее вызвал “этот объект”). В примере выше – это адрес переменной <code>b</code>, соответственно <code>b.p</code> примет значение <math display="inline"><mi>20</mi></math>, а <code>b.q</code> – <math display="inline"><mi>50</mi></math>. Другими словами, если вне класса к полям объекта надо обращаться через оператор прямого доступа, применяемый к его имени в программе, то внутри класса – через оператор косвенного доступа, применяемый к его адресу в программе. С этого момента функции, объявленные внутри класса, которые содержат неявный аргумент <code>this</code>, мы будем называть <b>методами</b>.
</p>
<p>
    Для конструкторов это тоже верно, то есть, они являются <b>специальными методами</b>. Главная же особенность конструкторов заключается в том, что они <b>вызываются автоматически во время создания объекта</b> в программе. Иначе говоря, каждая переменная соответствующего типа, объявленная в программе, в момент своей инициализации вызовет подходящий конструктор. Это также верно для классов, в которых не объявлено ни одного явного конструктора. В <b>С++ компилятор автоматически генерирует конструкторы</b> в меру своих способностей в случае их отсутствия. На практике на это полагаться не рекомендуется, поэтому если ваш конструктор должен соблюдать определенный набор правил, его надо задавать явно.
</p>
<p>
    Конкретней, для типа <code>rational</code> следующая запись вызовет <b>конструктор по умолчанию</b>.
</p>
<pre><code>
rational a;
</code></pre>
<p>
    Конструкторы по умолчанию выполняют действия по инициализации полей класса в тех случаях, когда для этого нет конкретных данных. В данном примере конструктор по умолчанию будет сгенерирован автоматически. Так как внутренние поля представлены примитивным типом <code>int</code>, сгенерированному конструктору ничего не придется делать. Но в предыдущих главах было установлено как минимум одно правило, которое должно выполняться даже для таких случаев: знаменатель не должен быть равен нулю. Для обработки такого сценария существует несколько возможных вариантов.
</p>
<p>
    Первый способ заключается в предварительной инициализации полей внутри класса.
</p>
<pre><code>
class rational {
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    Используя <b>инициализаторы</b> (фигурные скобки после имени поля с данными) можно задать первоначальные значения для всех переменных такого типа. Это делается еще до вызова конструктора. Так можно гарантировать правильные значения для всех полей во избежание странных ошибок в дальнейшем.
</p>
<p>
    Другой способ заключается в задании значений по умолчанию для одного из <b>конструкторов с параметрами</b>.
</p>
<pre><code>
class rational {
public:
    rational(<b>int x = 1, int y = 1</b>) {
        assert(y != 0);
        if(y &lt; 0) {
            this-&gt;p = -x;
            this-&gt;q = -y;
        }
        else {
            this-&gt;p = x;
            this-&gt;q = y;
        }
        if(x != 0) reduce(*this);
    }
private:
    int p;
    int q;
};        
</code></pre>
<p>
    Строка <code>rational(int x = 1, int y = 1)</code> использует свойство функций <b>С++</b> устанавливать значения по умолчанию для параметров (соблюдая определенные правила [IBM]). У этого свойства есть интересные последствия для конструкторов.
</p>
<pre><code>
rational c = rational(9, 2);
assert(9 == c.get_p() && 2 == c.get_q());
rational d;
assert(1 == d.get_p() && 1 == d.get_q());
</code></pre>
<p>
    То есть, в данном случае компилятор считает, что конструктор с параметрами одновременно является и конструктором по умолчанию. Если вызвать этот конструктор с конкретными значениями, они заменят аргументы по умолчанию при вызове функции, если же не передавать ничего, этот конструктор все равно будет вызван, но аргументы будут иметь значения по умолчанию, определенные в заголовке функции.
</p>
<p>
    Третий способ, который мы рассмотрим – это <b>запрет на конструирование объектов заданного типа</b> без параметров. Если в вашей программе нет ситуаций, в которых рациональное число нужно было бы создавать без конкретных значений, лучше себя обезопасить от случайностей, указав на это в классе, чтобы компилятор мог распознавать все попытки так сделать.
</p>
<pre><code>
class rational {
public:
    <b>rational() = delete</b>;
    rational(int x, int y) {
        assert(y != 0);
        if(y &lt; 0) {
            this-&gt;p = -x;
            this-&gt;q = -y;
        }
        else {
            this-&gt;p = x;
            this-&gt;q = y;
        }
        if(x != 0) reduce(*this);
    }
private:
    int p;
    int q;
};
</code></pre>
<p>
    Здесь появляется новое ключевое слово <code>delete</code> (не путать с оператором <code>delete</code> [Whitney(a)]). В данном случае оно указывает на то, что конструктор без параметров для этого типа использовать нельзя. Если теперь попробовать создать переменную без явной инициализации: <code>rational a;</code> – компилятор покажет ошибку, <b>“error: use of deleted function 'rational::rational()”</b>. Обратите внимание на то, что в конструкторе с параметрами больше нет значений по умолчанию. Ведь параметры по умолчанию превращают конструктор в конструктор по умолчанию, и последний фрагмент тогда имел бы два конструктора по умолчанию. То есть, нужно сделать выбор в пользу одного из этих двух вариантов.
</p>
<p>
    Следующий важный конструктор, который стоит реализовать – это <b>конструктор копирования</b>. Он нужен для того, чтобы в программе можно было создавать новые переменные как копии уже существующих переменных этого же типа.
</p>
<pre><code>
rational a(2, 3);
rational b(a);
assert(2 == b.get_p() && 3 == b.get_q());
</code></pre>
<p>
    Здесь надо быть очень внимательным. Как и в случае с конструктором по умолчанию, компилятор генерирует конструктор копирования в определенных ситуациях, поэтому пример кода выше может быть вполне рабочим. Это происходит потому, что все поля в классе <code>rational</code> представлены примитивным типом данных <code>int</code>. Компилятор знает как копировать данные типа <code>int</code> и без вашей помощи. Для составных типов данных вроде массивов оставлять копирование на совести компилятора не следует. Для данного случая конструктор копирования мог бы выглядеть следующим образом.
</p>
<pre><code>
class rational {
public:
    rational(<b>const rational &other</b>) {
        this-&gt;p = other.p;
        this-&gt;q = other.q;
    }
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    Как вы уже знаете, в конструктор передается аргумент для скрытого параметра <code>rational *this</code>, и явно в пару к нему заявляется параметр – ссылка<sup>1</sup> на объект (указатель, который <b>не может принимать значения <code>NULL</code> или <code>nullptr</code></b>) такого же типа. Таким образом, необходимо поочередно скопировать значения всех полей второго аргумента (<code>other</code> в примере) в первый (<code>this</code>). Существует и другая форма записи, использующая список инициализации.
</p>
<pre><code>
class rational {
public:
    rational(const rational &other) <b>: p(other.p), q(other.q)</b> {}
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    То есть, в случаях, когда достаточно просто скопировать данные из одной переменной в другую, язык позволяет сделать это до вызова тела конструктора.
</p>

<br>&nbsp;<br>

<h4>Упражнения</h4>
<p>1</p>
<p>
    Используя примеры из этой части необходимо написать конструктор, который создает объект типа <code>rational</code> на основании переданной строки определенного вида (например, для строки <code>“3/2”</code> создать объект с полем <code>p</code> равным <math display="inline"><mi>3</mi></math>, и полем <code>q</code> равным <math display="inline"><mi>2</mi></math>).
</p>
<button>Пример решения</button>
<p>2</p>
<p>
    <b>Конструктор переноса</b> является еще одним “каноническим конструктором”, который в <b>С++</b> принято реализовывать из соображений быстродействия программ. Останавливаться на нем очень подробно сейчас не стоит, но познакомиться с принципами его работы полезно. Работает он следующим образом. Для значений особого типа такой конструктор не копирует передаваемый ему объект, а “крадет” существующие в памяти значения, переписывая адреса этих значений на свой объект. Таким образом переданный в этот конструктор объект остается без действительных значений, так как все они были перенесены в другой объект. В зависимости от конкретной реализации языка <b>С++</b> это может происходить автоматически<sup>2</sup>. В большинстве же случаев программисты самостоятельно отмечают переменные, которые они хотят перенести. Такие переменные принято называть ссылками на <b>R-значения</b><sup>3</sup> и в коде отмечать как <code>&&</code> – ссылка на ссылку.
</p>
<p>
    В одной из следующих глав будет рассмотрен более конкретный пример того, зачем такой конструктор нужен на практике. Самое главное, не зацикливайтесь на этих нюансах если что-то пока не понятно. Задача данного текста заключается не в том, чтобы объяснить особенности реализации языка <b>С++</b>, который используется только в ознакомительных целях. Загвоздка же в том, что ссылки на R-значения являются способом реализации важных абстрактных идей, который выбрали разработчики <b>С++</b>, и вам следует иметь это ввиду. Попробуйте написать такой конструктор самостоятельно, а затем сверьтесь с примером из соответствующего раздела.
</p>
<button>Пример решения</button>

<br>&nbsp;<br>

<h4>Сноски</h4>
<p><sup>1</sup>Ссылки в <b>С++</b> отличаются от указателей в <b>С</b> тем, что они уже разыменованы в момент инициализации; если для какого-то <code>int a</code> ссылка создается с помощью оператора <code>&a</code>, то для <code>int& a</code> объект уже ведет себя как <code>int</code>. Другими словами, если к данным указателя вы обращаетесь через <b>оператор разыменования *</b>, для ссылок это делать не нужно, они ведут себя как обычные значения.</p>
<p><sup>2</sup>Компилятору позволяется самому выбирать между копированием и переносом в ситуациях, когда переменная не отмечена ключевым словом <code>volatile</code> или не является аргументом функции [Polacek].</p>
<p><sup>3</sup>Это название исторически закрепилось за <b>анонимными значениями</b> в коде, так как они всегда находятся справа от <b>оператора присваивания</b> (отсюда и название, right-hand value – R-value). Примером такого значения может быть любое константное число (<code>int x = 5</code>), которое указывает на присваиваемое в переменную первоначальное значение. В <b>С++</b> переменные тоже могут обладать свойствами R-значений, в этом случае их называют <b>Х-значениями</b> [CPP(a)].</p>

<br>&nbsp;<br>

<p>
    Copyright &copy; 2023 Брынзан, Л. В.<br>
    GNU General Public License<br>
    “Commons Clause” License Condition v1.0<br>
    GPL Attribution-ShareAlike 4.0 International<br>
</p>

</div>
</td>
</tr>
</table>
</body>
</html>
