<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Перегрузка функций</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header 
    style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6#contents">&laquo; К оглавлению</a>
    <div style="display: flex;width: 50%;justify-content: space-between;">
    <a href="/fcim_poo_21.6/chapter3">&lsaquo; Конструкторы</a>
    <a href="/fcim_poo_21.6/chapter4">&Uarr; Вверх</a>
    <a href="#operators">&Darr; Перегрузка операторов</a>
    <a href="/fcim_poo_21.6/chapter5">Полиморфизм I &rsaquo;</a>
    </div>
    </header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
<table width="75%" align="center" border="0" cellpadding="2">
<tr>
<td width="80%">
<div align="left"><h4>Перегрузка функций</h4></div>
<div align="justify">
<p>
    В большинстве примеров выше для проверки функциональности кода используется ключевое слово <code>assert</code>. В последнем примере мелькает следующая строка.
</p>
<pre><code>
assert(1 == g.get_p() && 5 == g.get_q());
</code></pre>
<p>
    Логический оператор “и” (<code>&&</code> или <code>and</code>) указывает на то, что все выражение в скобках проверяется на истинность. Если результат выполнения метода <code>get_p</code> для объекта <code>g</code> равен <math display="inline"><mi>1</mi></math> и результат выполнения метода <code>get_q</code> для этого же объекта равен <math display="inline"><mi>5</mi></math>, то строка кода программой игнорируется, в противном случае работа программы будет прервана.
</p>
<p>
    Напомним, что метод <code>get_p</code> всего лишь возвращает значение поля <code>p</code> заданного объекта, и аналогично <code>get_q</code> – значение поля <code>q</code>. Выше уже говорилось о том, что данные методы нарушают инкапсуляцию (а точнее, принцип закрытости, о котором речь пойдет ниже), то есть их пришлось сделать конкретно для этого сравнения, потому что другого способа проверить текущие значения скрытых полей у нас нет. Было бы лучше иметь под рукой какой-то механизм проверки всего этого условия без того, чтобы копаться в недрах объекта и высматривать значения отдельных полей.
</p>
<p>
    Например, можно заменить проверку каждого поля в отдельности на один вызов специального метода, который отвечает на вопрос, “равны ли поля объекта переданным значениям?”.
</p>
<pre><code>
class rational {
public:
    bool eq(int __p, int __q) {
        return this-&gt;p == __p && this-&gt;q == __q;
    }
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>Тогда следующий фрагмент кода мог бы проверять поля заданного объекта.</p>
<pre><code>
rational e(1, 5);
assert(e.eq(1, 5));
</code></pre>
<p>
    Если позволить фантазии разгуляться, то можно представить, что будут ситуации, где таким же образом надо сравнить два объекта типа <code>rational</code>. В предыдущих частях вы бы делали это поочередно сравнивая соответствующие поля двух объектов с помощью методов <code>get_p</code> и <code>get_q</code>. Но лучшим вариантом было бы сделать отдельный метод, который всю “кухню” скрывает внутри класса, аналогично примеру выше.
</p>
<pre><code>
class rational {
public:
    bool eq(int __p, int __q) {
        return this-&gt;p == __p && this-&gt;q == __q;
    }
    bool eq(const rational& other) {
        return this-&gt;p == other.p && this-&gt;q == other.q;
    }
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    Тогда вызов выглядит так.
</p>
<pre><code>
rational a(2, 3);
rational b(a);
assert(b.eq(a));
</code></pre>
<p>
    Было бы удобно не только сохранить оба этих определения, но и если бы можно было делать сколько угодно таких методов с одинаковыми названиями. Разработчики <b>С++</b> именно так и думали, потому что оно так и работает. До тех пор, пока функции имеют <b>отличающиеся списки аргументов</b>, они могут иметь одинаковое название и возвращаемый тип.
</p>
<p>
    Для вас это не является новостью потому что в предыдущих примерах это свойство функций в языке <b>С++</b> уже использовалось для конструкторов. Все конструкторы называются одинаково и отличаются только в количестве и типах параметров. Исходя из типов и порядка переданных аргументов компилятор выбирает какой конструктор вызвать. С другими методами это работает так же, потому что и конструкторы, и методы являются особым видом функций. Когда говорят о <b>перегрузке</b> (<b>“overload”</b>, не путать с <code>override</code>) именно это свойство и подразумевают.
</p>

<a id="operators">&nbsp;</a>
<h4>Перегрузка операторов</h4>

<p>
    Имея под рукой все методы, описанные выше, можно сравнивать любые рациональные числа друг с другом, что очень полезно само по себе, но не очень удобно. Например, имея массив рациональных чисел пользователь мог бы его отфильтровать, игнорируя все отрицательные числа в массиве:
</p>
<pre><code>
if(a[i].lt(0)) { … }
</code></pre>
<p>
    Здесь <code>lt</code> – это метод из класса <code>rational</code>, который проверяет, если рациональное число слева строго меньше своего целочисленного аргумента. Даже на этом простом примере видно, как синтаксис языка делает достаточно простую операцию сложной для восприятия. Было бы намного проще понять что происходит, если бы выражение выглядело так:
</p>
<pre><code>
if(a[i] &lt; 0) { … }
</code></pre>
<p>
    Язык <b>С++</b> позволяет это сделать. Многие операторы являются функциями, а вы уже знаете, что функции можно перегружать. Следовательно, операторы тоже могут быть перегружены [CPP(b)]. Для этого достаточно заменить название функции на ключевое слово <code>operator</code>, за которым указывается непосредственно символ нужного оператора. Например, можно переписать функцию <code>eq</code>.
</p>
<pre><code>
class rational {
public:
    bool <b>operator==</b>(const rational& other) {
        return this-&gt;p == other.p && this-&gt;q == other.q;
    }
private:
    int p{1};
    int q{1};
};
</code></pre>
<p>
    Тогда сравнение двух рациональных чисел могло бы выглядеть так:
</p>
<pre><code>
assert(b == rational(2, 3));
</code></pre>
<p>
    Но не спешите переписывать все методы, сделанные в предыдущей части, как операторы. Перегрузка операторов требует следовать определенным правилам, и не все методы в классе <code>rational</code> этим правилам соответствуют. Например, нельзя превратить в оператор метод <code>eq</code>, работающий с двумя целыми числами:
</p>
<pre><code>
bool operator==(int __p, int __q); 
</code></pre>
<p>
    Методы вызываются на объект с помощью оператора доступа, то есть метод всегда имеет аргумент <code>this</code>, а это значит, что для такой формы записи оператора он бы принимал три аргумента. Но вы уже знаете, что <b>оператор сравнения принимает только два аргумента</b> – слева и справа от оператора. Ошибка компилятора для такого варианта оператора вам примерно это же и говорит, <b>“error: bool rational::operator==(int, int)' must have exactly one argument”</b>. То есть, в такой форме записи оператора уже есть аргумент <code>this</code>, вдобавок к которому можно передавать только один дополнительный аргумент. Если попробовать исправить это, убрав скрытый аргумент <code>this</code> с помощью ключевого слова <code>static</code>:
</p>
<pre><code>
static bool operator==(int __p, int __q);
</code></pre>
<p>
    компилятор сгенерирует другую ошибку, <b>“error: static bool rational::operator==(int, int)' must be either a non-static member function or a non-member function”</b>. Другими словами, убрав аргумент <code>this</code> мы избавились от переменных типа <code>rational</code> в этом методе совсем, и пропала необходимость держать его внутри класса, так как он не оперирует данными класса. Если же мы явно зададим аргумент типа <code>rational</code> для этого оператора, мы опять вернемся к патовой ситуации с тремя аргументами.
</p>
<p>
    Единственное, что нам позволяется сделать, это задать оператор сравнения с одним единственным целым числом.
</p>
<pre><code>
bool operator==(int x);
</code></pre>
<p>
    Это позволит делать сравнения такого вида: <code>a == 1</code>; при этом сравнения вида <code>1 == a</code> будут невозможны, так как первоначальная форма оператора предполагает, что объект типа <code>rational</code> всегда слева (он является скрытым аргументом <code>this</code>, который всегда проверяется слева от оператора).
</p>
<p>Данное ограничение тоже можно обойти с помощью ключевого слова <code>friend</code>.</p>
<pre><code>
class rational {
public:
    <b>friend</b> bool operator==(int lhs, const rational &rhs) {
        return rhs.p == lhs && rhs.q == lhs;
    }
private:
    int p{1};
    int q{1};
};        
</code></pre>
<p>
    Ключевое слово <code>friend</code> позволяет обойти ограничение на обязательное использование аргумента <code>this</code>, достаточно чтобы аргументов было адекватное количество (для бинарного оператора – два), и чтобы один из аргументов был типа <code>rational</code>.
</p>
<pre><code>
rational a;
assert(1 == a); 
</code></pre>
<p>
    Проблема только в том, чтобы запомнить все эти тонкости. Это очень показательная ситуация. Язык <b>С++</b> позволяет сделать значительную часть кода легко читаемой при условии, что программист готов затратить большие усилия на предварительную работу по подготовке всех нужных для этого инструментов.
</p>
<p>
    Часто используемый прием при перегрузке функций – использовать уже готовые функции как основу реализации новых, если эти функции как-то связаны между собой. Например, с помощью оператора “равно” можно реализовать оператор “не равно”, используя булевое отрицание.
</p>
<pre><code>
class rational {
public:
    friend bool operator==(int lhs, const rational &rhs) {
        return rhs.p == lhs && rhs.q == lhs;
    }
    friend bool operator!=(int lhs, const rational &rhs) {
        <b>return !(lhs == rhs);</b>
    }
private:
    int p{1};
    int q{1};
};        
</code></pre>
<p>
    Аналогичным способом можно перегрузить оператор “меньше”. Особое внимание следует обратить на версию этого оператора, которая сравнивает два рациональных числа. Этот <b>оператор используется компилятором для сортировки</b>, поэтому при необходимости отсортировать список рациональных чисел определение этого оператора придется предоставить.
</p>
<p>
    “Наивная” версия алгоритма могла бы выглядеть так: если знаменатель левой части равен знаменателю правой части, меньше то число, числитель которого меньше; если знаменатели не равны, оба числа предварительно необходимо привести к общему знаменателю и сравнить полученные таким образом два числа. На деле реализация может оказаться не такой тривиальной, так как алгоритм может зациклиться в бесконечной рекурсии; конструирование новых объектов и их последующее сравнение может организоваться в цикл последовательных вызовов самого оператора “меньше”.
</p>
<p>
    Другой алгоритм предполагает использование следующего свойства для некоторых натуральных чисел, при условии, что 
    <math display="inline"><mtext>b</mtext><mtext>,</mtext><mtext>d</mtext><mtext>&#x2209;</mtext><mo>&#x007B;</mo><mi>0</mi><mo>&#x007D;</mo></math>:
</p>
<div align="center"><math display="inline">
    <mfrac>
        <mrow><mtext>a</mtext></mrow>
        <mrow><mtext>b</mtext></mrow>
    </mfrac>
    <mo>&lt;</mo>
    <mfrac>
        <mrow><mtext>c</mtext></mrow>
        <mrow><mtext>d</mtext></mrow>
    </mfrac>
    <mo>&#x2261;</mo>
    <mtext>a</mtext><mo>&#x22C5;</mo><mtext>d</mtext>
    <mo>&lt;</mo>
    <mtext>c</mtext><mo>&#x22C5;</mo><mtext>b</mtext>
</math>.
</div> 
<p>
    На первый взгляд такой метод предельно прост в реализации, не считая возможных проблем с отрицательными аргументами<sup>1</sup>. Тем не менее, он редко встречается в реализациях данной операции, в частности из-за того, что <b>результат умножения числителя на знаменатель имеет тенденцию к переполнению</b><sup>2</sup>. В примере ниже используется метод сравнения рациональных чисел, конвертированных в числа с плавающей запятой.
</p>
<pre><code>
friend bool operator&lt;(const rational &lhs, const rational &rhs) {
    auto x = (long double)lhs.p / (long double)lhs.q;
    auto y = (long double)rhs.p / (long double)rhs.q;
    return x &lt; y;
}
</code></pre>
<p>
    Синтаксис уже должен быть понятен. Здесь сохраняется проблема переполнения в том случае, когда числитель или знаменатель хотя бы одного из операндов представлены значениями, превышающими максимальное значение типа <code>long double</code>. Соответственно, для данной реализации инвариантом<sup>3</sup> является диапазон допустимых значений для числителя и знаменателя аргументов. В данном случае это определяется на уровне класса <code>rational</code>, а следовательно может контролироваться выбранным изначально типом, единственное требование к которому – быть подмножеством (или приводиться к нему) множества чисел, представляемых типом <code>long double</code> (это зависит от конкретного компилятора для конкретной архитектуры процессора, что можно проверять в самой операции). Для такой реализации код ниже будет рабочим.
</p>
<pre><code>
rational b(2, 3);
rational c(3, 4);
assert(b &lt; c);
</code></pre>
<p>
    Реализовать все остальные операторы сравнения достаточно просто, они могут быть выражены через уже сделанный оператор “меньше”.
</p>
<pre><code>
friend bool operator&gt;(const rational &lhs, const rational &rhs) {
    <b>return rhs &lt; lhs</b>;
}
friend bool operator&gt;=(const rational &lhs, const rational &rhs) {
    <b>return !(lhs &lt; rhs)</b>;
}
friend bool operator&lt;=(const rational &lhs, const rational &rhs) {
    <b>return !(rhs &lt; lhs)</b>;
}
</code></pre>

<br>&nbsp;<br>

<h4>Упражнения</h4>
<p>1</p>
<p>
    Внимательные читатели успели заметить одну деталь в фрагментах кода, представленных выше, которая в тексте пристально не рассматривалась. До того момента, как  конструкторы были введены в класс <code>rational</code>, создавать объекты все равно было можно. Более того, можно было создавать объекты на базе других объектов, например, таким образом:
</p>
<pre><code>
rational b = a;
</code></pre>
<p>
    Здесь объект <code>a</code> тоже имеет тип <code>rational</code>. Это возможно благодаря сгенерированному автоматически конструктору копирования. Нюанс же заключается в следующем. Что произойдет, если дополнить строку выше такой инструкцией: <code>a = b</code>? Здесь конструирования не происходит, потому что оба объекта уже были инициализированы выше, но данные должны копироваться из области, связанной с именем справа от оператора присваивания, в область имени слева от оператора присваивания.
</p>
<p>
    Секрет как раз и состоит в том, что оператор присваивания для класса <code>rational</code> тоже будет сгенерирован автоматически. Как вы уже можете догадываться, этот оператор тоже можно перегрузить. Он во многом повторяет логику соответствующего конструктора копирования за одним исключением. Если при конструировании объекта не нужно беспокоиться о его состоянии, то при вызове оператора присваивания объект, владеющий этим оператором (то есть, аргумент <code>this</code>), может уже существовать в программе какое-то время, и его состояние этим оператором не устанавливается начисто, а изменяется с одного на другое. В таких ситуациях предварительно приходится объект готовить к присваиванию, для чего оператор должен делать определенные проверки. Конкретно для типа <code>rational</code> такая проверка проста: желательно убедиться что присваивание не производится объектом над самим собой (<code>b = b</code>). В более сложных случаях нужны дополнительные проверки текущего состояния объекта. Имея это ввиду попробуйте написать <b>перегрузку для оператора присваивания</b> как для L-значений, так и для R-значений.
</p>
<button>Пример решения</button>
<p>2</p>
<p>
    Операция сложения двух рациональных чисел может быть хорошим кандидатом на перегрузку. Оператор сложения также является бинарным оператором, поэтому его можно перегрузить по той же схеме, что и любой из операторов сравнения. Само сложение двух дробных чисел требует нахождения <b>наименьшего общего множителя</b> в случае отличающихся знаменателей. Затем обе дроби нужно привести к общему знаменателю и уже после этого сложить их числители.
</p>
<button>Пример решения</button>

<br>&nbsp;<br>

<h4>Сноски</h4>
<p><sup>1</sup>Например, сравнение двух чисел <code>rational(2, 3)</code> и <code>rational(-3, -4)</code> даст неправильный результат, так как он зависит от сравнения выражений 
    <math display="inline"><mi>2</mi><mo>*</mo><mi>-4</mi></math> и 
    <math display="inline"><mi>-3</mi><mo>*</mo><mi>3</mi></math>, то есть, 
    <math display="inline"><mi>-8</mi></math> и 
    <math display="inline"><mi>-9</mi></math>, где правая часть меньше левой.</p>
<p><sup>2</sup>На практике применяется способ, который не вызывает переполнения при арифметических операциях с числителем и знаменателем; например, реализация оператора “меньше” в библиотеке <b>Boost</b> упрощает аргументы, приводя их к непрерывным дробям, используя алгоритм Евклида для нахождения наибольшего общего делителя [Moore].</p>
<p><sup>3</sup>Свойство какой-либо сущности в выражении, которое остается неизменным, независимо от условий.</p>

<br>&nbsp;<br>

<p>
    Copyright &copy; 2023 Брынзан, Л. В.<br>
    GNU General Public License<br>
    “Commons Clause” License Condition v1.0<br>
    GPL Attribution-ShareAlike 4.0 International<br>
</p>

</div>
</td>
</tr>
</table>
</body>
</html>
