<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Абстрактные типы данных</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header
    style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6">&laquo; К оглавлению</a>
    <div style="display: flex;width: 35%;justify-content: space-between;">
        <a href="/fcim_poo_21.6/chapter1">&Uarr; Вверх</a>
        <a href="/fcim_poo_21.6/chapter2">Сокрытие данных и инкапсуляция &rsaquo;</a>
    </div>
</header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
    <table width="75%" align="center" border="0" cellpadding="2">
        <tr>
            <td width="80%">
                <div align="left">
                    <h4>Абстрактные типы данных</h4>
                </div>
                <div align="justify">

                    <p>
                        В предыдущей части было сделано утверждение относительно роли абстракций типов данных в программировании. Для того, чтобы в этом убедиться, следует вернуться к понятию <b>“переменная”</b>, но теперь уже – в
                        контексте программирования. Кто-то может сказать, что переменная – это имя в программе. Что
                        будет не совсем точно, потому что “имя”, обладает единственным свойством – его уникальностью.
                        Очевидно, что переменные обладают и другими свойствами. Кто-то скажет, что это “хранилище”,
                        которое принимает различные значения. Это опять не совсем точно в отношении переменных в
                        программах, так как часто переменная не хранит значение, которое ей присваивается, при этом
                        значение не может существовать в программе само по себе, ведь оно тоже абстрактно. Оно будет
                        иметь некоторое конкретное представление.
                    </p>
                    <p>
                        Например, число <math display="inline"><mtext>42</mtext></math> является значением, оно будет
                        представлено в памяти компьютера в виде двоичного:
                    </p>
                    <div align="center"><math display="inline">
                        <msup><mi>2</mi><mi>5</mi></msup><mo>+</mo><msup><mi>2</mi><mi>3</mi></msup><mo>+</mo><msup><mi>2</mi><mi>1</mi></msup>
                        </math>;
                    </div>                            
                    <p>а в программе – еще и в виде десятичного:</p>
                    <div align="center"><math display="inline">
                        <mi>4</mi>
                        <mo>*</mo>
                        <msup><mi>10</mi><mi>1</mi></msup>
                        <mo>+</mo>
                        <mi>2</mi>
                        <mo>*</mo>
                        <msup><mi>10</mi><mi>0</mi></msup>
                        </math>;
                    </div> 
                    <p>или шестнадцатеричного:</p>
                    <div align="center"><math display="inline">
                        <mi>2</mi>
                        <mo>*</mo>
                        <msup><mi>16</mi><mi>1</mi></msup>
                        <mo>+</mo>
                        <mi>10</mi>
                        <mo>*</mo>
                        <msup><mi>16</mi><mi>0</mi></msup>
                        <mtext>&#x3164;или&#x3164;</mtext>
                        <mi>2</mi>
                        <msub><mi>A</mi><mi>16</mi></msub>
                        </math>
                    </div>
                    <p>набора данных.</p>
                    <p>
                        На основании этих уточнений можно выделить три основных момента, присущих любой переменной. Переменные обладают способом представления в конкретном языке (целое число, дробное число, текст и т.д.). Переменные обладают порядком хранения в памяти компьютера (занимаемые байты, а также назначение каждого бита в соответствующих байтах). Наконец, переменные обладают непосредственно значением, которое определяет их полезность в программе. Таким образом мы столкнулись с тремя уровнями абстракции, совершая переход от математических концепций к их воплощению в памяти компьютера посредством какого-то языка программирования<sup>1</sup>.
                    </p>
                    <p>
                        Так как математические абстракции принято классифицировать по каким-либо признакам для удобства (например, переменные разделяются на такие, которые представляют целые или дробные числа), такой подход применяется и в языках программирования. Классификация производится по свойствам, перечисленным выше, а именно: какое множество значений принимают данные, какую форму принимают значения из этого множества, какие операции возможны для значений из этого множества [Wirth]. То есть, <b>тип данных</b> – это совокупность представления какого-то значения в программе и в памяти компьютера, которая позволяет работать с конкретным значением в программе с помощью соответствующих операций. Внутри самой программы также есть “конкретные” сущности и абстрактные сущности. Первые ассоциируются с объектами, вторые – со значениями [McJones]. В общем смысле, <b>объект</b> – это некоторое отношение между типом данных и самими данными в памяти компьютера. Свойства объекта определяются его типом.
                    </p>
                    <p>
                        Второе значение слова “абстрактный” – удаленный, то есть, рассматриваемый в отрыве от своего источника. Так разделение подходов в программировании на парадигмы (программирование может быть структурное, объектно-ориентированное, функциональное и т.д.) является абстракцией, потому что с точки зрения целевого устройства все эти парадигмы производят один и тот же машинный код, который исполняется независимо от того, какую идею вкладывал в него программист. Предназначение абстракций в программировании заключается в том, чтобы проектировать программы, понимать их и проверять их логику на правильность <b>на основании законов, которые управляют абстракциями</b> (например, на основании законов математики), не отвлекаясь на подробности реализации этих абстракций в конкретном компьютере.
                    </p>
                    <p>
                        Рассмотрим несложный пример. Предположим, что перед вами поставлена задача разработать тип данных в языке <b>С</b>, который будет использоваться для представления рациональных<sup>2</sup> чисел в различных программах. Например, такое число можно было бы хранить в виде структуры:
                    </p>
                    <pre><code>
struct rational {
    int p;
    int q;
};                        
                    </code></pre>
                    
                    <p>
                        Тогда атрибут <math display="inline"><mi>p</mi></math> – это числитель, а <math display="inline"><mi>q</mi></math> – знаменатель. В этом случае создание рационального числа в программе могло бы выглядеть так:
                    </p>
                    <pre><code>
rational a = {1, 2};

rational b;
b.p = 5;
b.q = 6;

rational c;
                    </code></pre>
                    <p>
                        Все три способа являются правильными с точки зрения компилятора (в данном примере используется gcc<sup>3</sup>). Но внимательный читатель может заметить, что тут есть проблемы. Во-первых, в качестве числителя и знаменателя можно передавать любые значения, в том числе <math display="inline"><mi>0</mi></math>. Это, конечно, противоречит правилам работы с рациональными числами, так как <math display="inline"><mi>0</mi></math> в числителе должен обнулять все число, а в знаменателе <math display="inline"><mi>0</mi></math> недопустим. Во-вторых, и числитель, и знаменатель можно свободно менять уже после создания переменной, что чревато всеми проблемами, перечисленными выше. В-третьих, оба атрибута можно оставить без значений, что делает такую переменную бесполезной, а поведение программы, которая ее использует, непредсказуемым.
                    </p>
                    <p>
                        Общепринятый способ решения похожих проблем заключается в создании специальных функций, которые устанавливают значения согласно определенному набору требований  (в нашем случае – определенные значения числителя и знаменателя). Для рациональных чисел эта функция могла бы выглядеть так:
                    </p>
                    <pre><code>
rational cons(int x, int y) {
    assert(y != 0);
    if(x == 0) return {0, 0};
    rational r;
    if(y &lt; 0) {
        r.p = -x;
        r.q = -y;
    }
    else {
        r.p = x;
        r.q = y;
    }
    return r;
}                        
                    </code></pre>
                    <p>
                        Функция проверяет: числитель на нулевое значение (тогда вся дробь обнуляется), знаменатель на нулевое значение (тогда даже нет смысла продолжать, и работа программы прерывается c помощью макроса <code>assert</code> из соответствующей библиотеки; в одной из следующих глав есть более элегантный способ справляться с этой ситуацией), знаменатель на отрицательное значение (тогда отрицание переносится на числитель).
                    </p>
                    <pre><code>
rational a = cons(1, 2);
                    </code></pre>
                    <p>
                        Конечно, те, кто более-менее разбирается в нюансах создания переменных в <b>С</b>, понимают, что эта функция никак не решает проблемы изменения значений числителя и знаменателя в дальнейшем. В целом, ограничения, которые эта функция накладывает, условны. Никак не запрещается создавать переменные такого типа без использования этой функции. Другими словами, она рассчитана на то, что разработчики будут руководствоваться здравым смыслом при работе с такими рациональными числами. Тем не менее, компилятор позволяет установить более жесткие ограничения, которые полностью контролируют создание переменных и изменение атрибутов каждого создаваемого объекта типа <code>rational</code>. О них речь пойдет в следующих главах.
                    </p>
                    <p>
                        Тут интересно другое. Когда было принято решение создать функцию, задача которой – заботиться о правильности инициирования рациональных чисел, вы абстрагировались от деталей реализации рациональных чисел в программе. Использование рациональных чисел в своих программах является основным критерием для пользователя. Аналогичные функции можно написать для всех операций, в которых будут участвовать такие объекты. Результатом становится <b>абстрактный тип данных</b>. Такой тип данных предоставляет не только механизм для создания объектов с данными, но и механизмы для полноценной работы с этими объектами – стандартные операции над ними.
                    </p>

                    <br>&nbsp;<br>

                    <h4>Упражнения</h4>
                    <p>
                        Абстрактные типы данных будут составлять основу большинства концепций, обсуждаемых в этом тексте, поэтому с ними нужно освоиться как можно лучше. Для этого читателю предлагается дополнить тип данных, описанный выше, несколькими операциями. Во-первых, было бы неплохо поддерживать сокращенную форму всех создаваемых в программе рациональных чисел (при заданных числителе и знаменателе, которые кратны одному и тому же числу, делить их на это число по умолчанию: 
                        <math display="inline">
                            <mfrac><mrow><mi>5</mi></mrow><mrow><mi>10</mi></mrow></mfrac>
                        </math> превращать в 
                        <math display="inline">
                            <mfrac><mrow><mi>1</mi></mrow><mrow><mi>2</mi></mrow></mfrac>
                        </math>, 
                        <math display="inline">
                            <mfrac><mrow><mi>9</mi></mrow><mrow><mi>6</mi></mrow></mfrac>
                        </math> – в 
                        <math display="inline">
                            <mfrac><mrow><mi>3</mi></mrow><mrow><mi>2</mi></mrow></mfrac>
                        </math>). Во-вторых, было бы удобно отображать такие числа в текстовом виде как дроби, а не пару целых чисел. Пример этих дополнений будет ниже, но настоятельно рекомендуется сделать их самостоятельно, и только в случае полной неудачи посмотреть реализацию.
                    </p>

                    <button>Пример решения</button>

                    <br>&nbsp;<br>

                    <h4>Сноски</h4>
                    <p><sup>1</sup>Программирование можно считать одной из областей математики, языки программирования можно называть абстрактными компьютерами [Strachey].</p>
                    <p><sup>2</sup>Действительное число, которое можно представить как пару целых чисел, записанных одно
                        над другим через прочерк, в виде дроби.</p>
                    <p><sup>3</sup>GCC, the GNU Compiler Collection, <a href="https://gcc.gnu.org/">gcc.gnu.org</a>.</p>

                    <br>&nbsp;<br>

                    <p>
                        Copyright &copy; 2023 Брынзан, Л. В.<br>
                        GNU General Public License<br>
                        “Commons Clause” License Condition v1.0<br>
                        GPL Attribution-ShareAlike 4.0 International<br>
                    </p>
                </div>
            </td>
        </tr>
    </table>
</body>
</html>
