<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Абстрактные типы данных</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
    <style>
        div#example {
            border: 1px solid black;
            background-color: white;
        }
    </style>
</head>

<header
    style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6">&laquo; К оглавлению</a>
    <div style="display: flex;width: 35%;justify-content: space-between;">
        <a href="/fcim_poo_21.6/chapter1">&Uarr; Вверх</a>
        <a href="/fcim_poo_21.6/chapter2">Сокрытие данных и инкапсуляция &rsaquo;</a>
    </div>
</header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
    <table width="75%" align="center" border="0" cellpadding="2">
        <tr>
            <td width="80%">
                <div align="left">
                    <h4>Абстрактные типы данных</h4>
                </div>
                <div align="justify">

                    <p>
                        В предыдущей части было сделано утверждение относительно роли абстракций типов данных в программировании. Для того, чтобы в этом убедиться, следует вернуться к понятию <b>“переменная”</b>, но теперь уже – в
                        контексте программирования. Кто-то может сказать, что переменная – это имя в программе. Что
                        будет не совсем точно, потому что “имя”, обладает единственным свойством – его уникальностью.
                        Очевидно, что переменные обладают и другими свойствами. Кто-то скажет, что это “хранилище”,
                        которое принимает различные значения. Это опять не совсем точно в отношении переменных в
                        программах, так как часто переменная не хранит значение, которое ей присваивается, при этом
                        значение не может существовать в программе само по себе, ведь оно тоже абстрактно. Оно будет
                        иметь некоторое конкретное представление.
                    </p>
                    <p>
                        Например, число <math display="inline"><mtext>42</mtext></math> является значением, оно будет
                        представлено в памяти компьютера в виде двоичного:
                    </p>
                    <div align="center"><math display="inline">
                        <msup><mi>2</mi><mi>5</mi></msup><mo>+</mo><msup><mi>2</mi><mi>3</mi></msup><mo>+</mo><msup><mi>2</mi><mi>1</mi></msup>
                        </math>;
                    </div>                            
                    <p>а в программе – еще и в виде десятичного:</p>
                    <div align="center"><math display="inline">
                        <mi>4</mi>
                        <mo>*</mo>
                        <msup><mi>10</mi><mi>1</mi></msup>
                        <mo>+</mo>
                        <mi>2</mi>
                        <mo>*</mo>
                        <msup><mi>10</mi><mi>0</mi></msup>
                        </math>;
                    </div> 
                    <p>или шестнадцатеричного:</p>
                    <div align="center"><math display="inline">
                        <mi>2</mi>
                        <mo>*</mo>
                        <msup><mi>16</mi><mi>1</mi></msup>
                        <mo>+</mo>
                        <mi>10</mi>
                        <mo>*</mo>
                        <msup><mi>16</mi><mi>0</mi></msup>
                        <mtext>&#x3164;или&#x3164;</mtext>
                        <mi>2</mi>
                        <msub><mi>A</mi><mi>16</mi></msub>
                        </math>
                    </div>
                    <p>набора данных.</p>
                    <p>
                        На основании этих уточнений можно выделить три основных момента, присущих любой переменной. Переменные обладают способом представления в конкретном языке (целое число, дробное число, текст и т.д.). Переменные обладают порядком хранения в памяти компьютера (занимаемые байты, а также назначение каждого бита в соответствующих байтах). Наконец, переменные обладают непосредственно значением, которое определяет их полезность в программе. Таким образом мы столкнулись с тремя уровнями абстракции, совершая переход от математических концепций к их воплощению в памяти компьютера посредством какого-то языка программирования<sup>1</sup>.
                    </p>
                    <p>
                        Так как математические абстракции принято классифицировать по каким-либо признакам для удобства (например, переменные разделяются на такие, которые представляют целые или дробные числа), такой подход применяется и в языках программирования. Классификация производится по свойствам, перечисленным выше, а именно: какое множество значений принимают данные, какую форму принимают значения из этого множества, какие операции возможны для значений из этого множества [Wirth]. То есть, <b>тип данных</b> – это совокупность представления какого-то значения в программе и в памяти компьютера, которая позволяет работать с конкретным значением в программе с помощью соответствующих операций. Внутри самой программы также есть “конкретные” сущности и абстрактные сущности. Первые ассоциируются с объектами, вторые – со значениями [McJones]. В общем смысле, <b>объект</b> – это некоторое отношение между типом данных и самими данными в памяти компьютера. Свойства объекта определяются его типом.
                    </p>
                    <p>
                        Второе значение слова “абстрактный” – удаленный, то есть, рассматриваемый в отрыве от своего источника. Так разделение подходов в программировании на парадигмы (программирование может быть структурное, объектно-ориентированное, функциональное и т.д.) является абстракцией, потому что с точки зрения целевого устройства все эти парадигмы производят один и тот же машинный код, который исполняется независимо от того, какую идею вкладывал в него программист. Предназначение абстракций в программировании заключается в том, чтобы проектировать программы, понимать их и проверять их логику на правильность <b>на основании законов, которые управляют абстракциями</b> (например, на основании законов математики), не отвлекаясь на подробности реализации этих абстракций в конкретном компьютере.
                    </p>
                    <p>
                        Рассмотрим несложный пример. Предположим, что перед вами поставлена задача разработать тип данных в языке <b>С</b>, который будет использоваться для представления рациональных<sup>2</sup> чисел в различных программах. Например, такое число можно было бы хранить в виде структуры:
                    </p>
                    <pre><code>
struct rational {
    int p;
    int q;
};                        
                    </code></pre>
                    
                    <p>
                        Тогда атрибут <math display="inline"><mi>p</mi></math> – это числитель, а <math display="inline"><mi>q</mi></math> – знаменатель. В этом случае создание рационального числа в программе могло бы выглядеть так:
                    </p>
                    <pre><code>
rational a = {1, 2};

rational b;
b.p = 5;
b.q = 6;

rational c;
                    </code></pre>
                    <p>
                        Все три способа являются правильными с точки зрения компилятора (в данном примере используется gcc<sup>3</sup>). Но внимательный читатель может заметить, что тут есть проблемы. Во-первых, в качестве числителя и знаменателя можно передавать любые значения, в том числе <math display="inline"><mi>0</mi></math>. Это, конечно, противоречит правилам работы с рациональными числами, так как <math display="inline"><mi>0</mi></math> в числителе должен обнулять все число, а в знаменателе <math display="inline"><mi>0</mi></math> недопустим. Во-вторых, и числитель, и знаменатель можно свободно менять уже после создания переменной, что чревато всеми проблемами, перечисленными выше. В-третьих, оба атрибута можно оставить без значений, что делает такую переменную бесполезной, а поведение программы, которая ее использует, непредсказуемым.
                    </p>
                    <p>
                        Общепринятый способ решения похожих проблем заключается в создании специальных функций, которые устанавливают значения согласно определенному набору требований  (в нашем случае – определенные значения числителя и знаменателя). Для рациональных чисел эта функция могла бы выглядеть так:
                    </p>
                    <pre><code>
rational cons(int x, int y) {
    assert(y != 0);
    if(x == 0) return {0, 0};
    rational r;
    if(y &lt; 0) {
        r.p = -x;
        r.q = -y;
    }
    else {
        r.p = x;
        r.q = y;
    }
    return r;
}                        
                    </code></pre>
                    <p>
                        Функция проверяет: числитель на нулевое значение (тогда вся дробь обнуляется), знаменатель на нулевое значение (тогда даже нет смысла продолжать, и работа программы прерывается c помощью макроса <code>assert</code> из соответствующей библиотеки; в одной из следующих глав есть более элегантный способ справляться с этой ситуацией), знаменатель на отрицательное значение (тогда отрицание переносится на числитель).
                    </p>
                    <pre><code>
rational a = cons(1, 2);
                    </code></pre>
                    <p>
                        Конечно, те, кто более-менее разбирается в нюансах создания переменных в <b>С</b>, понимают, что эта функция никак не решает проблемы изменения значений числителя и знаменателя в дальнейшем. В целом, ограничения, которые эта функция накладывает, условны. Никак не запрещается создавать переменные такого типа без использования этой функции. Другими словами, она рассчитана на то, что разработчики будут руководствоваться здравым смыслом при работе с такими рациональными числами. Тем не менее, компилятор позволяет установить более жесткие ограничения, которые полностью контролируют создание переменных и изменение атрибутов каждого создаваемого объекта типа <code>rational</code>. О них речь пойдет в следующих главах.
                    </p>
                    <p>
                        Тут интересно другое. Когда было принято решение создать функцию, задача которой – заботиться о правильности инициирования рациональных чисел, вы абстрагировались от деталей реализации рациональных чисел в программе. Использование рациональных чисел в своих программах является основным критерием для пользователя. Аналогичные функции можно написать для всех операций, в которых будут участвовать такие объекты. Результатом становится <b>абстрактный тип данных</b>. Такой тип данных предоставляет не только механизм для создания объектов с данными, но и механизмы для полноценной работы с этими объектами – стандартные операции над ними.
                    </p>

                    <br>&nbsp;<br>

                    <h4>Упражнения</h4>
                    <p>
                        Абстрактные типы данных будут составлять основу большинства концепций, обсуждаемых в этом тексте, поэтому с ними нужно освоиться как можно лучше. Для этого читателю предлагается дополнить тип данных, описанный выше, несколькими операциями. Во-первых, было бы неплохо поддерживать сокращенную форму всех создаваемых в программе рациональных чисел (при заданных числителе и знаменателе, которые кратны одному и тому же числу, делить их на это число по умолчанию: 
                        <math display="inline">
                            <mfrac><mrow><mi>5</mi></mrow><mrow><mi>10</mi></mrow></mfrac>
                        </math> превращать в 
                        <math display="inline">
                            <mfrac><mrow><mi>1</mi></mrow><mrow><mi>2</mi></mrow></mfrac>
                        </math>, 
                        <math display="inline">
                            <mfrac><mrow><mi>9</mi></mrow><mrow><mi>6</mi></mrow></mfrac>
                        </math> – в 
                        <math display="inline">
                            <mfrac><mrow><mi>3</mi></mrow><mrow><mi>2</mi></mrow></mfrac>
                        </math>). Во-вторых, было бы удобно отображать такие числа в текстовом виде как дроби, а не пару целых чисел. Пример этих дополнений будет ниже, но настоятельно рекомендуется сделать их самостоятельно, и только в случае полной неудачи посмотреть реализацию.
                    </p>

                    <a href="#example">Пример решения</a>
                    <div id="example" hidden="until-found">
                        <p>
                            Идея, стоящая за функцией сокращения дробей довольно проста. Во-первых, если числитель равен нулю или знаменатель – единице, делать сокращение нет необходимости. Во-вторых, если сокращение делать все таки надо, для этого достаточно определить значение наибольшего общего делителя для дроби и поделить на эту величину числитель и знаменатель.
                        </p>
                        <pre><code>
void reduce(rational &r) {
    if(r.q == 1 || r.p == 0) return;
    else {
        int d = <b>gcd</b>(abs(r.p), r.q);
        r.p /= d;
        r.q /= d;
    }
}                            
                        </code></pre>
                        <p>
                            Обратите внимание на то, что тип данных для переменной <code>d</code> указан явно, что можно сделать только с несколькими допущениями: результат функции <code>gcd</code> имеет значение типа <code>int</code> или без потерь приводится к нему; числитель и знаменатель аргумента <code>r</code> оба могут участвовать в выражениях вместе со значениями типа <code>int</code>. Этот дефект алгоритма в последствии придется исправить. Обобщенное программирование является одним из инструментов для этого и подробно обсуждается в соответствующей главе. Реализация нахождения наибольшего общего делителя могла бы выглядеть так.
                        </p>
                        <pre><code>
int gcd(int m, int n) {
    while(n != 0) {
        int t = m % n;
        m = n;
        n = t;
    }
    if(m &lt; 0) m = -m;
    return m;
}                            
                        </code></pre>
                        <p>
                            Здесь используется модифицированный алгоритм Евклида [Степанов]. Данный алгоритм легко переписывается с помощью рекурсии для тех языков, которые не имеют встроенных циклов. У многих реализаций этого алгоритма есть некоторые недостатки. Алгоритм зависит от операции деления, которая является недостаточно эффективной. Алгоритм также зависит от типов данных его аргументов, что привязано к архитектуре процессора и используемому компилятору, поэтому <b>неудачная реализация может нарушать важные математические свойства алгоритма</b> [Cormen]. На практике часто можно встретить использование расширенной версии алгоритма Евклида или двоичного алгоритма, разработанного Д. Штайном [Knuth]. Поэтому лучшим выбором для среднестатистического разработчика будет <b>использование встроенного в стандартную библиотеку алгоритма</b>, реализация которого остается на совести авторов компилятора. Например, в <b>С++</b>:
                        </p>
                        <pre><code>
template&lt;class M, class N> constexpr std::common_type_t&lt;M, N> <b>gcd</b>(M m, N n);
                        </code></pre>
                        <p>
                            Стандартная функция использует <b>шаблоны типов</b> для того, чтобы в качестве аргументов можно было передавать любые целые числа. С этого момента будем предполагать, что все упоминания функции <code>gcd</code> используют эту версию, поставляемую с языком <b>С++</b>.
                        </p>
                        <p>
                            В случае с выводом строковой формы дроби реализация будет чуть сложнее. Для этого необходимо решить две задачи. Первая задача заключается в определении всех цифр, которые составляют числа в числителе и знаменателе. Вторая задача состоит в составлении строки, которая содержит в себе символы, отвечающие полученным числовым значениям. Достичь этого можно несколькими способами, и ниже представлен лишь один из них.
                        </p>
                        <pre><code>
char *rstr(const rational &r, char *ret) {
    int i = 0;
    auto f = <b>[&] (int n)</b> {
        char *start = ret + i;
        while(n) {
            ret[i++] = (n % 10) + '0';
            n /= 10;
        }
        char *end = ret + i - 1;
        while(start &lt; end) {
            char tmp = *start;
            *start = *end;
            *end = tmp;
            start++;
            end--;
        }
    };
    f(r.p);
    if(r.q > 1) {    
        ret[i++] = '/';
        f(r.q);
    }
    return ret;
}                            
                        </code></pre>
                        <p>
                            Тонкий момент в коде выше связан с включением в функцию другой функции. Это сделано исходя из того факта, что внутренняя функция никогда не будет использоваться отдельно от родительской функции, соответственно нет причины захламлять пространство имен, связанное с этим файлом, именем еще одной функции. Сама внутренняя функция <code>f</code> сделана с помощью <b>лямбда-выражения</b> [Вики-конспекты(г)]. Эта функция определяет цифры, составляющие числитель и знаменатель, с помощью остатка от деления на <math display="inline"><mi>10</mi></math> и записывает эти цифры в виде печатных символов в предоставленный для этого массив. Сами печатные символы получаются прибавлением <b>ASCII</b>-кода [ANSI] символа <math display="inline"><mtext>"0"</mtext></math> к числовому значению, что даст ASCII-код искомой цифры (так как все коды в таблице идут по порядку, начиная с <math display="inline"><mi>0</mi></math>).
                        </p>
                        <p>
                            Символы поглощаются справа налево, следовательно запись в массив происходит по мере их получения, то есть, в порядке обратном тому, который нужен для правильного отображения всей дроби. Поэтому часть массива, которая только что была заполнена, должна быть перевернута (это делается во втором цикле внутренней функции <code>f</code>). В конечном итоге, если знаменатель не равен единице, строковое представление должно в себя включать символ дроби и сам знаменатель после.
                        </p>
                        <p>
                            Наконец, важно отметить несколько неочевидных моментов. Во-первых, функция не знает заранее, какой величины должна быть результирующая строка, и для таких случаев строка либо поставляется в функцию вместе с дробью (то есть, размер уже определен до вызова функции), либо строка создается динамически в самой функции, что подразумевает несколько дополнительных операций (подсчет общего количества символов и выделение нужного участка памяти в соответствии с результатом подсчета). В примере выше используется первый способ. Но если вы чувствуете уверенность в себе, автор рекомендует попробовать реализовать второй способ самостоятельно.
                        </p>
                        <p>
                            Во-вторых, функция возвращает строку, которая передается в нее изначально, что может показаться бесполезным. Причина состоит в том, что строки в <b>С</b> и <b>С++</b> являются указателями, что подразумевает отсутствие процесса “конструирования” объекта внутри функции. Это значит, что данная функция не создает новых объектов, а только лишь дублирует адрес строки, в которой были произведены необходимые манипуляции с данными. Другими словами, можно считать, что у функции нет возвращаемого значения:
                        </p>
                        <pre><code>
rational a = cons(10, 20);
reduce(a);
char tmp[100]{};
<b>rstr(a, tmp)</b>;
assert(!strcmp("1/2", tmp));
                        </code></pre>
                        <p>
                            Тем не менее, согласно первоначальной идее того, как эта функция должна работать, она возвращает строковое представление:
                        </p>
                        <pre><code>
char tmp[100]{};
assert(!strcmp(“1/2”, rstr(a, tmp)));
                        </code></pre>
                        <p>
                            То есть, результат работы этой функции можно передавать как аргумент в другие функции, ожидающие указатель на строку в качестве аргумента. Из этого следует, что в идеале наша функция должна возвращать не адрес той строки, которую мы в нее передали, а непосредственно символы, составляющие такую строку, которые можно скопировать в новую переменную типа <code>char*</code>:
                        </p>
                        <pre><code>
tmp = rstr(a);
                        </code></pre>
                        <p>
                            В одной из следующих глав будет показано как это можно сделать. Но многие читатели, наверное, догадались, что это будет сделано с помощью абстрактного типа данных.
                        </p>
                    </div>

                    <br>&nbsp;<br>

                    <h4>Сноски</h4>
                    <p><sup>1</sup>Программирование можно считать одной из областей математики, языки программирования можно называть абстрактными компьютерами [Strachey].</p>
                    <p><sup>2</sup>Действительное число, которое можно представить как пару целых чисел, записанных одно
                        над другим через прочерк, в виде дроби.</p>
                    <p><sup>3</sup>GCC, the GNU Compiler Collection, <a href="https://gcc.gnu.org/">gcc.gnu.org</a>.</p>

                    <br>&nbsp;<br>

                    <p>
                        Copyright &copy; 2023 Брынзан, Л. В.<br>
                        GNU General Public License<br>
                        “Commons Clause” License Condition v1.0<br>
                        GPL Attribution-ShareAlike 4.0 International<br>
                    </p>
                </div>
            </td>
        </tr>
    </table>
</body>
</html>
