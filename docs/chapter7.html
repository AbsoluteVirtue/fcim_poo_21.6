<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Шаблоны типов</title>
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/LatinModern/mathfonts.css" />
</head>

<header style="position: sticky;top: 0;background: #fff;display: flex;justify-content: space-between;width: 75%;margin: auto;padding: 16px 0;">
    <a href="/fcim_poo_21.6">&laquo; К оглавлению</a>
    <div style="display: flex;width: 50%;justify-content: space-between;">
        <a href="/fcim_poo_21.6/chapter6">&lsaquo; Полиморфизм II</a>
        <a href="/fcim_poo_21.6/chapter7">&Uarr; Вверх</a>
        <a href="/fcim_poo_21.6/chapter8">Полиморфизм III &rsaquo;</a>
    </div>
</header>

<body bgcolor="FFFFFF" link="006666" alink="8B4513" vlink="006666">
    <table width="75%" align="center" border="0" cellpadding="2">
        <tr>
            <td width="80%">
<div align="left">
    <h4>Шаблоны типов</h4>
</div>
<div align="justify">

<p>
    В предыдущей части был задан вопрос: как найти длину массива, не зная заранее какого типа будут его отдельные элементы? Если рассматривать возможные варианты реализации этого в <b>С++</b>, ответа на вопрос будет как минимум два. Но один из них очень специфичен. Предполагая, что длина массива, в первую очередь, нужна для поэлементного поиска в массиве с помощью цикла (чтобы знать, где массив заканчивается), есть встроенный в компилятор способ.
</p>
<pre><code>
int arr[15]{0};
for(auto i : arr) { <b>...</b> }
</code></pre>
<p>
    Такая конструкция цикла называется <code>for-each</code>, и особенность ее в том, что она сама определяет длину переданного контейнера, если он отвечает определенным условиям. В примере выше массив был объявлен как <b>статический</b>, поэтому его размер известен компилятору, соответственно цикл может определить, где массив заканчивается, исходя из заданного размера с помощью <b>арифметики указателей</b>. Особое внимание стоит обратить на ключевое слово <code>auto</code>, которое автоматически определяет тип каждого отдельного элемента массива. Оно является частью реализации выявления типов в <b>С++</b>, что делается с помощью шаблонов типов данных [CPP(d)].
</p>
<p>
    Чтобы четко себе представить, как работает выявление типов в <b>С++</b>, следует разобраться с “шаблонами”, которые выполняют роль переменных типов. Рассмотрим пример объявления функции:
</p>
<pre><code>
<b>template &lt;typename T&gt;</b> size_t length(const <b>T</b>(&a)[15]);
</code></pre>
<p>
    Здесь встречается три новых синтаксических элемента. Ключевое слово <code>template</code> обозначает начало определения шаблона. В самом общем смысле шаблоны являются отдельными сущностями и делятся на несколько категорий: <b>шаблоны классов, шаблоны функций, шаблоны переменных</b> и т.п. Компилятор генерирует код для шаблона тогда, когда шаблон инициализируется. В примере выше создается шаблон функции <code>length</code>, который имеет свой список аргументов в угловых скобках. Параметр у этого шаблона всего один – переменная <code>T</code>, которая принимает типы данных в качестве аргумента, что подчеркивается ключевым словом <code>typename</code>. Эта переменная затем используется в списке аргументов самой функции для обозначения того, что аргумент функции будет такого типа, который будет передан в качестве аргумента шаблона. Например, для массива <code>int arr[15]{0}</code> вызов выглядел бы так: 
</p>
<pre><code>
size_t l = length&lt;int&gt;(arr);

<b>// или так:</b>
size_t l = length(arr);
</code></pre>
<p>
    Соответственно, массив мог бы содержать элементы любого типа, и компилятор бы позволил определить тип уже в ходе работы программы. Но можно пойти еще дальше. Было бы хорошо, если бы компилятор позволял передавать в эту функцию массивы любой длины, а не заранее заданной в определении функции. Шаблоны позволяют сделать и это.
</p>
<pre><code>
<b>template &lt;typename T, size_t N&gt;</b> size_t length(const <b>T</b>(&a)[<b>N</b>]);
</code></pre>
<p>
    Здесь стоит отметить второй параметр в списке аргументов шаблона – имя <code>N</code>, которое должно быть целым беззнаковым числом. Объявив его таковым появляется возможность использовать его в качестве размера аргумента функции. Полностью функция могла бы выглядеть так.
</p>
<pre><code>
template &lt;typename T, size_t N&gt;
size_t length(const T(&a)[N]) {
    size_t i = 0;
    for(; i &lt; N; ++i);
    return i;
}
</code></pre>
<p>
    Синтаксис стал заметно сложнее для восприятия. Но в определенных ситуациях оно того стоит. Во-первых, это позволяет создавать полностью полиморфные функции без использования наследования. Во-вторых это позволяет изменять тип аргумента в будущем без необходимости изменять саму функцию или все ее вызовы, которые уже есть в программе.
</p>
<p>
    Шаблоны классов устроены по похожему принципу. Сначала рассмотрим их применение на примере одного из самых востребованных  классов в <b>С++</b>. В пространстве имен <code>std</code> содержится список различных ключевых слов и типов данных, которые определяются в различных стандартных библиотеках, поставляемых вместе с компилятором. Одна из таких библиотек – <b>vector</b> – представляет собой реализацию <b>динамического массива</b>, которая предлагает альтернативу массивам из языка <b>С</b>, которые создаются на стеке и не изменяются в размерах в ходе работы программы. В отличие от них вектор может “расти” или “уменьшаться” в зависимости от контекста.
</p>
<pre><code>
<b>std::</b>vector&lt;int&gt; a;
<b>std::</b>vector&lt;float&gt; b(10);
<b>std::</b>vector&lt;char&gt; c({‘e’, ‘g’, ‘i’});
</code></pre>
<p>
    Вектор реализует большое количество конструкторов. Выше показаны три разных способа инициализировать объект-вектор: с помощью конструктора по умолчанию, конструктора с параметром типа <code>int</code> и конструктора с параметром типа <code>char</code>. В первом случае вектор останется пустым, но в дальнейшем будет принимать только значения типа <code>int</code>. Во втором случае вектор будет инициализирован массивом из 10 значений типа <code>float</code>. В третьем случае вектор будет инициализирован массивом из трех значений типа <code>char</code>, переданных в виде <b>списка инициализации</b>.
</p>
<p>
    Все три вектора обладают несколькими свойствами, которые либо реализованы как доступные открыто методы, либо активизируются в определенных ситуациях автоматически. Например, получить доступ к элементу вектора можно как минимум тремя способами. Первый способ заимствован из языка <b>С</b> – квадратные скобки с индексом нужного элемента, начиная с нуля, например, <code>c[0]</code> – вернет значение <b>‘e’</b> (число 101). Если элемента по такому индексу не существует, программа прервет свою работу. Второй способ представлен методом <code>at</code>, который также принимает индекс элемента, например, <code>c.at(0)</code> – вернет <b>‘e’</b>. Если элемента по такому индексу не существует, метод вызовет <b>исключение</b><sup>1</sup>, что также может прервать работу программы. Третий способ связан с использованием указателей на элементы вектора. Вектор не позволяет использовать прямые указатели, взамен предоставляя методы, которые возвращают <b>итераторы</b><sup>2</sup> на начало или конец вектора: <code>begin</code> и <code>end</code>. Так, инструкция <code>c.end()</code> вернет объект-итератор, который ведет себя как указатель на первый элемент за пределами вектора. Например, <code>*c.begin()</code> вернет <b>‘e’</b>, а <code>*(c.end() - 1)</code> вернет <b>‘i’</b>.
</p>
<pre><code>
for(size_t i = 0; i &lt; <b>c.size()</b>; ++i) c[i];
for(auto i = <b>b.begin()</b>; i != <b>b.end()</b>; ++i) *i;
for(auto i <b>:</b> a) i;
</code></pre>
<p>
    Пример всех трех способов показан выше. В первом случае используется привычный вид цикла <code>for</code>, который генерирует индексы для последующего доступа к нужным элементам. Метод <code>size</code> используется для точного определения текущего размера вектора. Второй способ получает итератор на первый элемент и с помощью оператора инкремента передвигает итератор до последнего элемента (находящегося непосредственно перед итератором <code>b.end()</code>). Третий вариант использует уже знакомую вам форму цикла <code>for-each</code>, которая позволяет в более краткой форме получить доступ к значению элемента вектора.
</p>
<p>
    Если посмотреть на то, как класс <code>vector</code> объявлен в заголовочном файле своей библиотеки, некоторые элементы могут вызвать особый интерес.
</p>
<pre><code>
template &lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt;&gt;
class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; { <b>...</b> };
</code></pre>
<p>
    Как и ожидалось, вектор объявлен как шаблон, причем список аргументов шаблона включает в себя другой шаблон – необязательный параметр <code>_Alloc</code>, который определяет способ выделения памяти для нужд вектора. Вектор не является базовым классом, а наследует часть своих свойств от другого шаблона класса <code>_Vector_base</code>. Исходя из этого описания можно попробовать написать наивную реализацию вектора самостоятельно.
</p>
<p>
    Пока что не стоит обращать внимание на параметр “аллокатор” и просто его игнорировать. Выделение памяти для работы класса полностью зависит от выбранной стратегии работы с памятью, и она не обязательно должна включать в себя работу с динамической памятью. Также нет необходимости наследовать базовый класс из стандартной библиотеки, так как вы не знакомы с деталями его реализации. Исходя из этого ваша реализация вектора могла бы выглядеть примерно так:
</p>
<pre><code>
template &lt;typename T&gt;
class vector {
public:
    vector() {}
    template &lt;size_t N&gt;
    vector(const T(&list)[N]) : length((N &lt; 100) ? N : 100) {
        for(size_t i = 0; i &lt; this->length; ++i) {
            this->arr[i] = list[i];
        }
    }
    vector(size_t N) : length((N &lt; 100) ? N : 100) {}
    size_t size() { return this->length; }
    T *begin() { return this->arr; }
    T *end() { return this->arr + this->length; }
private:
    T arr[100]{0};
    size_t length{0};
};        
</code></pre>
<p>
    Такой вариант реализации повторяет три способа инициализации вектора, рассмотренных ранее, а также методы <code>begin</code>, <code>end</code>, <code>size</code> – для использования в циклах. В качестве основного механизма вектора выступает массив на 100 значений заданного типа. В качестве итераторов используются указатели на массив. Конструкторы проверяют переданные аргументы для того, чтобы убедиться, что их значения не позволят массиву стать размером больше 100 элементов. Таким образом, становится возможным следующий фрагмент:
</p>
<pre><code>
vector&lt;int> my_vec({10, 20, 30});
for(auto i : my_vec) std::cout &lt;&lt; i;
</code></pre>
<p>
    Благодаря использованию шаблонов созданный таким образом вектор может принимать любой тип данных в качестве основы, и это не повлияет на его работоспособность.
</p>

<br>&nbsp;<br>

<h4>Упражнения</h4>
<p>
    Пример реализации методов <code>begin</code> и <code>end</code>, показанный выше, является “наивным” в том смысле, что он использует указатели для получения доступа к содержимому памяти вектора. В <b>стандартной библиотеке шаблонов</b> для этого используются <b>итераторы</b>, которые являются полноценными объектами, скрывающими указатели от прямого доступа для большинства операций контейнеров. Причем, задача итераторов не только и не столько в том, чтобы скрыть указатели, а в том, чтобы <b>привести интерфейс всех контейнеров к одной форме, не зависящей от реализации контейнеров</b>. Что это подразумевает?
</p>
<p>
    Например, вы уже должны быть знакомы с тем, как реализуются <b>односвязные списки</b>. В отличие от массивов односвязный список не хранит все свои элементы в соседних блоках памяти, поэтому указатель на каждый последующий элемент нужно хранить вместо того, чтобы арифметически расчитывать его позицию, как это делается для массивов. То есть, для односвязного списка реализация методов <code>begin</code> и <code>end</code> через обычные указатели, ничего бы не дала, так как циклы <code>for</code> и <code>for-each</code> используют инкрементирование указателей для перебора элементов контейнера. Это значит, что для такого списка недостаточно сделать методы <code>begin</code> и <code>end</code>, а нужно также перегрузить операторы инкремента, декремента, сложения, вычитания и сравнения указателей. Для самих указателей это сделать крайне сложно, поэтому стоит прибегнуть к стандартному способу решения похожей проблемы: внутри контейнера создать новый тип данных, который ведет себя как указатель, определить для него все вышеперечисленные операции и возвращать методами <code>begin</code> и <code>end</code> объекты этого типа, а не чистые указатели. Попробуйте реализовать такой класс самостоятельно.
</p>
<button>Пример решения</button>
<br>&nbsp;<br>

<h4>Сноски</h4>
<p><sup>1</sup>Исключение (exception, англ.) – лингвистический механизм, который служит для взаимодействия процедур внутри программы, в первую очередь, при возникновении ошибок в логике программы.</p>
<p><sup>2</sup>Итератор (iterator, англ.) – специальный объект, который указывает на отдельный элемент из списка элементов; итератор также может переходить от одного элемента к другому на произвольную дистанцию, используя специальные операторы; в С++ указатели обладают всеми свойствами итератора и полностью аналогичны по своей функциональности итераторам случайного доступа [CPP(e)].</p>

<br>&nbsp;<br>

                    <p>
                        Copyright &copy; 2023 Брынзан, Л. В.<br>
                        GNU General Public License<br>
                        “Commons Clause” License Condition v1.0<br>
                        GPL Attribution-ShareAlike 4.0 International<br>
                    </p>

                </div>
            </td>
        </tr>
    </table>
</body>
</html>
