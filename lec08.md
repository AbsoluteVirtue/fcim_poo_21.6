# Контракты
## Выявление типов

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Функция *prod* определена для двух произвольных параметров. Определение говорит, что если один из аргументов -- пустой список, значение функции равно нулю. Во всех остальных случаях значение функции определено суммой произведений пары элементов в начале каждого списка-аргумента с результатом этой же функции с остатками ("хвостами") обоих списков.

Интересно здесь другое: откуда компилятор знает, что аргументы в параметрах a и b являются списками на самом деле?

    prod ([1, 2, 3], [4, 5, 6])
Для такого вызова компилятор определит функцию самостоятельно следующим образом:

    val prod = fn: int list * int list -> int
Т.е. компилятор определелил символ *prod* как функцию, которая принимает два вектора и возвращает скалярное значение.

Даже если компилятор может определить типы данных аргументов, как он определяет соответствие типов аргументов типам параметров? Все сравнительно просто. Сам факт того, что в функции оба параметра сравниваются с пустыми списками, означает, что типы этих параметров - обобщенные списки. Возвращаемое значение функции обязательно будет целым числом, так как оба определения функции сводятся к целому числу (либо нулю, либо сумме целого числа со значением функции). Отсюда же следует, что списка должны содержать числовые значения, т.к. их отдельные элементы перемножаются.

Этот процесс должен проверить код на удовлетворение ограничений, которые обнаруживаются при определении любой функции. Аппликация функции к аргументу или аргументам генерирует эти такие ограничения (область определения функции должна быть совместима с областью значений функции, иначе определение функции некорректно). Ограничения разрешаются методом последовательного исключения. 

Если для конкретного случая существует строго одно решение, соответствующие типы данных можно определить однозначно. Если существует несколько вохможных решений, функция полиморфна, при этом есть одно "лучшее" решение. Если решений нет, то определение функции неверно в принципе.  

Как компилятор проверяет соответствие значений аргументов требованиям функции? Это может вызвать трудности. Например, если передать функции два списка разной длины, в момент, когда один список уже закончился, умножение будет производиться между первым элементом более длинного списка и пустым множеством. Здесь у компилятора два способа выйти из ситуации: либо позволить функции вычислить значение до этого момента и в итоге сообщить об ошибке, либо проверить длины списков заранее и сообщить об этом во время компиляции. Первый способ присущ динамическим системам типов, а второй -- статическим.
### Перегрузка операторов
Перегрузка операторов может внести дополнительные трудности в систему типов. Чтобы в этом убедиться можно рассмотреть знакомый пример.

    const char * __begin1 = __range1;
    const char * __end1 = __range1 + 10L;
    for (; __begin1 != __end1; ++__begin1) {
        const char & c = *__begin1;
    }
В языке С++ процесс итерирования по коллекции традиционно повторяет идиоматический способ, используемый в языке С -- использование указателей на начало и конец диапазона значений. Если существует два адреса, один из которых был выделен "раньше" второго, и они принадлежат одному множеству адресов, между этими адресами можно исследовать все байты. 

В случаях, когда адреса диапазона недоступны, можно обратиться к итераторам.

    auto __begin1 = __range1.begin();
    auto __end1 = __range1.end();
    for (; ::operator!=(__begin1, __end1); __begin1.operator++())
    {
        const char & c = __begin1.operator*();
    }
Определение цикла в двух примерах почти не отличается. Это возможно благодаря тому, что для итераторов *__begin1* и *__end1* все операторы перегружены так, чтобы их поведение полностью совпадало с указателями. Это добавляет сложности в систему типов, так как не все коллекции, реализующие собственные итераторы, легко могут повторить поведение диапазонов байтов. Например, связные списки не хранят значения в памяти как массивы, и оператор "++" для их итераторов должен быть реализован особым способом.

Другой пример, где неправильное переопределение может привести к серьезным проблемам -- перегрузка оператора "<".

    template <typename _RandomAccessIterator>
    void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                   std::random_access_iterator_tag)
    {
        if (__first == __last) return;
        --__last;
        while (__first < __last)
        {
            std::iter_swap(__first, __last);
            ++__first;
            --__last;
        }
    }
Для иллюстрации выше приводится пример определения стандартного алгоритма. Сравнение *__first < __last* предполагает, что сравниваются значения какого-то диапазона, так как они меняются местами, если первый элемент меньше последнего. Если в эту функцию передать указатели, сравнение указателей может дать неожиданный и часто неправильный результат, так как сравниваться будут их адреса, а порядок байтов в памяти напрямую никак не связан с порядком значений в колелкции.

Отсюда следует, что оператор "<" должен быть перегружен для значений, а не для самих указателей.
    
    friend bool operator<(iterator a, iterator b) { return *a.p < *b.p; }
Подводя промежуточный итог: система типов может проверить отношения между типами значений, участвующих в выражении, но на разработчика ложится ответственность за передачу значений, которые не только соответствуют ограничениям системы типов, но и удовлетворяют логическим требованиям определения той или иной операции.
## Пред-условия и пост-условия
Тщательность проверки ограничений системой типов зависит от вида системы в конкретном языке. Большинство языков не проверяет логические ограничения в рамках системы типов, оставляя это на усмотрение разработчиков. По этой причине во многих языках существуют как официальные, так и неофициальные расширения, которые, например, проверяют аргументы функции на соответствие всем ограничениям. 

В примерах выше таким ограничением было, например, требование, чтобы длины контейнеров были равными. Другой, менее очевидный пример: *int f(double, double)* -- здесь есть две потенциальные проблемы, которые могут возникнуть у пользователей данной функции. Во-первых, неочевидна природа возвращаемого значения (почему целое число и как именно оно вычисляется для двух аргументов). Во-вторых, явно не указаны допустимые значения аргументов, а также возможные отношения между ними.

Тем не менее, эти логические свойства являются важной частью определения данной функции и они неявно подразумеваются каждый раз, когда функция вызывается. Такие правила, которые устанавливаются между вызывающей стороной и вызываемым поведением, называются "контрактом."
### Пред-условие
Для примера выше можно представить себе ситуацию, в которой функция *f* использует оба операнда в арифметических выражениях, где один из них участвует в делении в качестве знаменателя. Это значит, что значение этого операнда не может быть равно нулю, следовательно пользователь и разработчик должны принять решение: кто отвечает за то, чтобы деление на 0 не произошло. С одной стороны, только разработчик функции может изменить поведение функции в случае, когда ноль в знаменатель попадает. С другой стороны, пользователь может предварительно проверять значение нужного аргумента и не передавать 0 в функцию. Это указывает на более глубокую проблему: пользователь заранее может и не знать, что 0 передавать нельзя, потому что это явно нигде не обозначено. 

Соответственно, перед раработчиком стоит две задачи: убедиться, что значения аргументов не могут привести к ошибкам; при этом убедиться, что требования к значениям аргументов очевидны для пользователей. Это часть контракта, и его соблюдение часто зависит от конкретного языка программирования. В идеальном случае система типов языка явно указывает на то, что можно и нельзя передавать, освобождая разработчика от необзодимости обрабатывать "неправильные" значения. В худшем случае значения языком никак не проверяются, и нет никакой возможности сообщить о предварительных требованиях пользователю.

    void set_by_ref(void *p, …);
Выше приводится еще один пример. Функция *set_by_ref* принимает адрес в качестве первого аргумента, изменяя значение по адресу. В качестве адреса можно передать любое целое число, так как система типов языка С позволяет конвертировать десятичные значения в шестнадцатиричные и обратно. Что будет, если передать ноль?

Конвертирование нуля в адрес даст NULL-указатель, который нельзя разыменовывать, а следовательно функция в таком случае вызовет исключение (если повезет). Разработчик надеется, что пользовтель достаточно хорошо знает язык С, чтобы никогда не передавать NULL в качестве аргумента, но пользователь не всегда контролирует этот процесс. Эта дилемма является прямым следствием системы типов языка С. БЫло бы хорошо, если бы она позволяла выразить пред-условие явно. И некоторые реализации стандарта это позволяют сделать.

    void set_by_ref(void *p[static 1], …);
Такая форма определения параметра позволяет проверять на стадии компиляции, что в качестве аргумента не был передан ноль. Если же такой синтаксис недоступен, раработчик вынужден будет дополнительно проверять значения аргументов в функции. Но даже так пользователю не стоит всегда полагаться только на проверки разработчика функции, а проверять значения до вызова функции, пусть даже это может оказаться двойной работой.

Проверка выносится из функции наружу и переходит из области ответственности разработчика в область ответственности пользователя, т.к. разработчик условной библиотеки не может знать заранее все возможные сценарии, в которых его функции будут использоваться, а пользователь эти сценарии организует, поэтому и должен принимать такие решения.
### Пост-условие
Ниже представлен уже знакомый пример с присваиванием перемещением. 
    
    a_ = std::move(b_);
Ответственность за ресурсы переходит от символа *b_* к символу *a_* (то есть, происходит переименование области памяти без копирования). Из этого есть одно важное следствие: последующие манипуляции с объектом *b_* не должны влиять на значение объекта *a_* -- для ссылочных типов данных стандарт С++ предполагает, что объект, на который вызвали функцию *move*, вернулся к своему значению по умолчанию (значение, в которое он устанавливается при вызове соответствующего конструктора).

Т.о. на пользователе лежит ответственность за то, чтобы привести объект-источник в правильное состояние сразу после операции переноса, потому что пользователи ожидают от кода разработчика, что он будет соответствовать стандарту. Такое ожидание называется пост-условием.
### Инварианта
    
    std::vector a {1, 2, 3, 4, 5};
    …
    std::vector b {std::move(a)};
    a.push_back();
    a.size();      
    a.clear();     
Выше приводится типичный пример работы с вектором в языке С++. Вопрос здесь следующий: после перемещения ресурсов из вектора *a*, какие операции над ним остаются легальными с точки зрения стандарта? Например, стандарт предполагает для всех векторов, что условие *size() <= capacity()* всегда выполняется (текущее количество элементов не может юыть больше текущего пространства, выделенного под элементы).

При перемещении ресурсов из объекта ссылочного типа реализация перемещения, промежуточное и конечное состояния объекта-источника контролируются реализацией класса - т.е. разработчиком. Компилятор не может гарантировать правильность состояния объекта после операции перемещения. Эта ответственность лежит на разработчике. Здесь условие *size() <= capacity()* является одной из инвариант класса *vector*. Это значит, что независимо от операции, которую произвели над объектом заданного типа, такие условия должны выполняться всегда.

Возвращаясь к фрагменту кода выше, после перемещения из объекта *a* на него вызывается три метода (порядок вызова не имеет значения). Какие из этих методов можно вызывать на объект, из которого было совершено перемещение?

Метод *push_back* не является легальным, так как для него необходимо знать, сколько ресурсов принадлежит объекту, чтобы определить необходимость расширения памяти под новые ресурсы. Перемещение нарушает инварианту (условие *size() <= capacity()* больше не выполняется).

Метод *size* не является легальным, так как для него должен быть известен текущий размер вектора *a*. Но метод *clear* является легальным, потому что он приводит объект к первоначальному состоянию независимо от текущего состояния, при этом условие *size() <= capacity()* выполняется (объект пуст).

Т.е. в данном примере вызов метода *clear* после перемещения нужен для того, чтобы сохранить инварианты класса vector и позволить продолжить работу с ним далее, что является частью контракта. Например,

    std::vector b {std::move(a)};
    a.clear();     
    a.push_back();
    a.size();      
Данный фрагмент является правильным с точки зрения стандарта, потому что инварианты класса сохранены после перемещения, и вызовы методов *push_back* и *size* будут легальными в новом контексте. Из этого есть другое следствие: инварианты класса допускается временно нарушать, например - в методе самого класса, до тех пор пока метод не произведет одно из следующих действий.

- Не вернет результат;
- не бросит исключение (об этом ниже);
- не вызовет callback-функцию;
- не вызовет функцию, работа которой требует соблюдение инвариант класса;
в любом из этих случаев инварианты необходимо восстановить до выполнения кода, связанного с одним из них.
# Обработка ошибок

