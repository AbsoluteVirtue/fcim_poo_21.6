# Контракты
## Выявление типов

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Функция *prod* определена для двух произвольных параметров. Определение говорит, что если один из аргументов -- пустой список, значение функции равно нулю. Во всех остальных случаях значение функции определено суммой произведений пары элементов в начале каждого списка-аргумента с результатом этой же функции с остатками ("хвостами") обоих списков.

Интересно здесь другое: откуда компилятор знает, что аргументы в параметрах a и b являются списками на самом деле?

    prod ([1, 2, 3], [4, 5, 6])
Для такого вызова компилятор определит функцию самостоятельно следующим образом:

    val prod = fn: int list * int list -> int
Т.е. компилятор определелил символ *prod* как функцию, которая принимает два вектора и возвращает скалярное значение.

Даже если компилятор может определить типы данных аргументов, как он определяет соответствие типов аргументов типам параметров? Все сравнительно просто. Сам факт того, что в функции оба параметра сравниваются с пустыми списками, означает, что типы этих параметров - обобщенные списки. Возвращаемое значение функции обязательно будет целым числом, так как оба определения функции сводятся к целому числу (либо нулю, либо сумме целого числа со значением функции). Отсюда же следует, что списка должны содержать числовые значения, т.к. их отдельные элементы перемножаются.

Этот процесс должен проверить код на удовлетворение ограничений, которые обнаруживаются при определении любой функции. Аппликация функции к аргументу или аргументам генерирует эти такие ограничения (область определения функции должна быть совместима с областью значений функции, иначе определение функции некорректно). Ограничения разрешаются методом последовательного исключения. 

Если для конкретного случая существует строго одно решение, соответствующие типы данных можно определить однозначно. Если существует несколько вохможных решений, функция полиморфна, при этом есть одно "лучшее" решение. Если решений нет, то определение функции неверно в принципе.  

Как компилятор проверяет соответствие значений аргументов требованиям функции? Это может вызвать трудности. Например, если передать функции два списка разной длины, в момент, когда один список уже закончился, умножение будет производиться между первым элементом более длинного списка и пустым множеством. Здесь у компилятора два способа выйти из ситуации: либо позволить функции вычислить значение до этого момента и в итоге сообщить об ошибке, либо проверить длины списков заранее и сообщить об этом во время компиляции. Первый способ присущ динамическим системам типов, а второй -- статическим.
### Перегрузка операторов
Перегрузка операторов может внести дополнительные трудности в систему типов. Чтобы в этом убедиться можно рассмотреть знакомый пример.

    const char * __begin1 = __range1;
    const char * __end1 = __range1 + 10L;
    for (; __begin1 != __end1; ++__begin1) {
        const char & c = *__begin1;
    }
В языке С++ процесс итерирования по коллекции традиционно повторяет идиоматический способ, используемый в языке С -- использование указателей на начало и конец диапазона значений. Если существует два адреса, один из которых был выделен "раньше" второго, и они принадлежат одному множеству адресов, между этими адресами можно исследовать все байты. 

В случаях, когда адреса диапазона недоступны, можно обратиться к итераторам.

    auto __begin1 = __range1.begin();
    auto __end1 = __range1.end();
    for (; ::operator!=(__begin1, __end1); __begin1.operator++())
    {
        const char & c = __begin1.operator*();
    }
Определение цикла в двух примерах почти не отличается. Это возможно благодаря тому, что для итераторов *__begin1* и *__end1* все операторы перегружены так, чтобы их поведение полностью совпадало с указателями. Это добавляет сложности в систему типов, так как не все коллекции, реализующие собственные итераторы, легко могут повторить поведение диапазонов байтов. Например, связные списки не хранят значения в памяти как массивы, и оператор "++" для их итераторов должен быть реализован особым способом.

Другой пример, где неправильное переопределение может привести к серьезным проблемам -- перегрузка оператора "<".

    template <typename _RandomAccessIterator>
    void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                   std::random_access_iterator_tag)
    {
        if (__first == __last) return;
        --__last;
        while (__first < __last)
        {
            std::iter_swap(__first, __last);
            ++__first;
            --__last;
        }
    }
Для иллюстрации выше приводится пример определения стандартного алгоритма. Сравнение *__first < __last* предполагает, что сравниваются значения какого-то диапазона, так как они меняются местами, если первый элемент меньше последнего. Если в эту функцию передать указатели, сравнение указателей может дать неожиданный и часто неправильный результат, так как сравниваться будут их адреса, а порядок байтов в памяти напрямую никак не связан с порядком значений в колелкции.

Отсюда следует, что оператор "<" должен быть перегружен для значений, а не для самих указателей.
    
    friend bool operator<(iterator a, iterator b) { return *a.p < *b.p; }
Подводя промежуточный итог: система типов может проверить отношения между типами значений, участвующих в выражении, но на разработчика ложится ответственность за передачу значений, которые не только соответствуют ограничениям системы типов, но и удовлетворяют логическим требованиям определения той или иной операции.
## Пред-условия и пост-условия
Тщательность проверки ограничений системой типов зависит от вида системы в конкретном языке. Большинство языков не проверяет логические ограничения в рамках системы типов, оставляя это на усмотрение разработчиков. По этой причине во многих языках существуют как официальные, так и неофициальные расширения, которые, например, проверяют аргументы функции на соответствие всем ограничениям. 

В примерах выше таким ограничением было, например, требование, чтобы длины контейнеров были равными. Другой, менее очевидный пример: *int f(double, double)* -- здесь есть две потенциальные проблемы, которые могут возникнуть у пользователей данной функции. Во-первых, неочевидна природа возвращаемого значения (почему целое число и как именно оно вычисляется для двух аргументов). Во-вторых, явно не указаны допустимые значения аргументов, а также возможные отношения между ними.

Тем не менее, эти логические свойства являются важной частью определения данной функции и они неявно подразумеваются каждый раз, когда функция вызывается. Такие правила, которые устанавливаются между вызывающей стороной и вызываемым поведением, называются "контрактом."
### Пред-условие
Для примера выше можно представить себе ситуацию, в которой функция *f* использует оба операнда в арифметических выражениях, где один из них участвует в делении в качестве знаменателя. Это значит, что значение этого операнда не может быть равно нулю, следовательно пользователь и разработчик должны принять решение: кто отвечает за то, чтобы деление на 0 не произошло. С одной стороны, только разработчик функции может изменить поведение функции в случае, когда ноль в знаменатель попадает. С другой стороны, пользователь может предварительно проверять значение нужного аргумента и не передавать 0 в функцию. Это указывает на более глубокую проблему: пользователь заранее может и не знать, что 0 передавать нельзя, потому что это явно нигде не обозначено. 

Соответственно, перед раработчиком стоит две задачи: убедиться, что значения аргументов не могут привести к ошибкам; при этом убедиться, что требования к значениям аргументов очевидны для пользователей. Это часть контракта, и его соблюдение часто зависит от конкретного языка программирования. В идеальном случае система типов языка явно указывает на то, что можно и нельзя передавать, освобождая разработчика от необзодимости обрабатывать "неправильные" значения. В худшем случае значения языком никак не проверяются, и нет никакой возможности сообщить о предварительных требованиях пользователю.

    void set_by_ref(void *p, …);
Выше приводится еще один пример. Функция *set_by_ref* принимает адрес в качестве первого аргумента, изменяя значение по адресу. В качестве адреса можно передать любое целое число, так как система типов языка С позволяет конвертировать десятичные значения в шестнадцатиричные и обратно. Что будет, если передать ноль?

Конвертирование нуля в адрес даст NULL-указатель, который нельзя разыменовывать, а следовательно функция в таком случае вызовет исключение (если повезет). Разработчик надеется, что пользовтель достаточно хорошо знает язык С, чтобы никогда не передавать NULL в качестве аргумента, но пользователь не всегда контролирует этот процесс. Эта дилемма является прямым следствием системы типов языка С. БЫло бы хорошо, если бы она позволяла выразить пред-условие явно. И некоторые реализации стандарта это позволяют сделать.

    void set_by_ref(void *p[static 1], …);
Такая форма определения параметра позволяет проверять на стадии компиляции, что в качестве аргумента не был передан ноль. Если же такой синтаксис недоступен, раработчик вынужден будет дополнительно проверять значения аргументов в функции. Но даже так пользователю не стоит всегда полагаться только на проверки разработчика функции, а проверять значения до вызова функции, пусть даже это может оказаться двойной работой.

Проверка выносится из функции наружу и переходит из области ответственности разработчика в область ответственности пользователя, т.к. разработчик условной библиотеки не может знать заранее все возможные сценарии, в которых его функции будут использоваться, а пользователь эти сценарии организует, поэтому и должен принимать такие решения.
### Пост-условие
Ниже представлен уже знакомый пример с присваиванием перемещением. 
    
    a_ = std::move(b_);
Ответственность за ресурсы переходит от символа *b_* к символу *a_* (то есть, происходит переименование области памяти без копирования). Из этого есть одно важное следствие: последующие манипуляции с объектом *b_* не должны влиять на значение объекта *a_* -- для ссылочных типов данных стандарт С++ предполагает, что объект, на который вызвали функцию *move*, вернулся к своему значению по умолчанию (значение, в которое он устанавливается при вызове соответствующего конструктора).

Т.о. на пользователе лежит ответственность за то, чтобы привести объект-источник в правильное состояние сразу после операции переноса, потому что пользователи ожидают от кода разработчика, что он будет соответствовать стандарту. Такое ожидание называется пост-условием.
### Инварианта
    
    std::vector a {1, 2, 3, 4, 5};
    …
    std::vector b {std::move(a)};
    a.push_back();
    a.size();      
    a.clear();     
Выше приводится типичный пример работы с вектором в языке С++. Вопрос здесь следующий: после перемещения ресурсов из вектора *a*, какие операции над ним остаются легальными с точки зрения стандарта? Например, стандарт предполагает для всех векторов, что условие *size() <= capacity()* всегда выполняется (текущее количество элементов не может юыть больше текущего пространства, выделенного под элементы).

При перемещении ресурсов из объекта ссылочного типа реализация перемещения, промежуточное и конечное состояния объекта-источника контролируются реализацией класса - т.е. разработчиком. Компилятор не может гарантировать правильность состояния объекта после операции перемещения. Эта ответственность лежит на разработчике. Здесь условие *size() <= capacity()* является одной из инвариант класса *vector*. Это значит, что независимо от операции, которую произвели над объектом заданного типа, такие условия должны выполняться всегда.

Возвращаясь к фрагменту кода выше, после перемещения из объекта *a* на него вызывается три метода (порядок вызова не имеет значения). Какие из этих методов можно вызывать на объект, из которого было совершено перемещение?

Метод *push_back* не является легальным, так как для него необходимо знать, сколько ресурсов принадлежит объекту, чтобы определить необходимость расширения памяти под новые ресурсы. Перемещение нарушает инварианту (условие *size() <= capacity()* больше не выполняется).

Метод *size* не является легальным, так как для него должен быть известен текущий размер вектора *a*. Но метод *clear* является легальным, потому что он приводит объект к первоначальному состоянию независимо от текущего состояния, при этом условие *size() <= capacity()* выполняется (объект пуст).

Т.е. в данном примере вызов метода *clear* после перемещения нужен для того, чтобы сохранить инварианты класса vector и позволить продолжить работу с ним далее, что является частью контракта. Например,

    std::vector b {std::move(a)};
    a.clear();     
    a.push_back();
    a.size();      
Данный фрагмент является правильным с точки зрения стандарта, потому что инварианты класса сохранены после перемещения, и вызовы методов *push_back* и *size* будут легальными в новом контексте. Из этого есть другое следствие: инварианты класса допускается временно нарушать, например - в методе самого класса, до тех пор пока метод не произведет одно из следующих действий.
- Не вернет результат;
- не бросит исключение (об этом ниже);
- не вызовет callback-функцию;
- не вызовет функцию, работа которой требует соблюдения инвариант класса;

в любом из этих случаев инварианты необходимо восстановить до выполнения кода, связанного с одним из них.
# Обработка ошибок
Одним из самых частых источников возникновения ошибок в программах является манипуляция состоянием программы каким-то неожиданным способом. Главной причиной создания парадигмы ООП было желание избавиться от необходимости изменять состояние программы напрямую. Как однажды сказал Джо Армстронг (создатель языка Erlang),
> На диске размером 250 гигабайтов всего 2 в степени 250000000000 * 8 возможных комбинаций состояний. А количество атомов во вселенной - примерно 2 в степени 260. Т.е. нужно 2 в степени 7633587786 вселенных, чтобы иметь вероятность найти другой компьютер, находящийся точно в таком же состоянии, что и мой компьютер в конкретный момент времени. Это хорошее объяснение тому, почему ваши программы не работают. Потому что обычно происходит следующее: вы скачиваете что-то на свой компьютер, делаете что-то, и оно не работает; вы открываете Google и находите страницу, на которой сказано, "у меня была точно такая же проблема, сделать надо так", а следом идет десять ответов вроде, "спасибо, мне помогло"; вы думаете, "нашлось решение проблемы", читаете магическое заклинание, и ничего не работает. Вы повторяете весь цикл несколько раз, пока оно наконец не начинает работать, но вы не понимаете почему. Что же с этим делать? Во-первых, есть математика, и можно попробовать доказать математически, что каждая программа правильна, но это подходит только для маленьких программ. Во-вторых, нужно учитывать, что сами компьютеры могут отказать, это неизбежно. Для обработки таких ситуаций одного компьютера недостаточно, нужно два, или десять -- много компьютеров. Репликация системы на множестве компьютеров пропорционально уменьшает шансы того, что все копии системы одновременно выйдут из строя. Это позволяет сделать системы очень надежными, но для этого нужно понимать распределенное, параллельное и многопоточное программирование. Системы, которые строятся нами, должны сами себя исправлять, сами себя настраивать, и самостоятельно развиваться -- они должны быть похожими на биологические системы.

Многое из того, что Армстронг говорит в этой цитате, перекликается со словами Алана Кея, которые приводились в предыдущих главах, и это не случайно. Джо Армстронг начинал свои исследования в языке Smalltalk, затем перешел на Prolog и уже позже продолжил идеи ООП в рамках языка Erlang на базе модели "Актеров" Карла Хьюетта.
## Виды ошибок
В целом, ошибки можно разделить на две категории: логические ошибки, которые являются результатом неправильно написанного кода (можно доказать математически, что код не даст ожидаемый результат); ошибки исполнения, которые являются результатом обработки неправильно сформированных данных. 

    std::vector v {1, 2, 3, 4, 5};
    …
    v.clear();
    v.pop_back();
Фрагмент выше иллюстрирует типичную логическую ошибку. Вызов методов вектора *clear* и *pop_back* в таком порядке не запрещен компилятором, но явно приведет к неопределенному поведению, так как из очищенного вектора удалять нечего. В результате программа может ничего не сделать, а может войти в нелегальное состояние -- это зависит от конкретной версии компилятора.

В свою очередь ошибки исполнения делятся на две подгруппы: восстанавливаемые и невосстанавливаемые.

    auto load_file(size_t handle) {
        auto f = read(handle);
        return f;
    }
В этом примере отсутствует проверка правильно открытого файла. Функция read может не найти файл по заданному идентификатору чтобы открыть поток (например, идентификатор мог быть неправильным), поэтому использование полученной ссылки на открытый файл без проверки приведет к ошибке исполнения.

Цель контрактов -- отделять логические ошибки от ошибок исполнения. В первом примере выше не выполняется пред-условие. Во втором -- пост-условие, т.о. нарушение контракта чревато возникновением ошибок. Но строгое соблюдение контракта не гарантирует, что ошибок возникать не будет. Система всегда подвергается внешним воздействиям, которые разработчик не может контролировать. Например, сбои в системе могут происходить:
- из-за влияния внешней среды (высокая температура, колебания напряжения в сети и т.д.);
- из-за преднамеренных атак на систему злоумышленниками (взлом с помощью известных уязвимостей, "фишинг" и т.д.);
- из-за дефектов компонентов системы;
- из-за не предусмотренного разработчиком поведения пользователей.

Во всех ситуациях обнаружения ошибки должна быть предусмотрена стратегия восстановления системы для того, чтобы она продолжала работу в нормальном состоянии. Можно условно выделить три стратегии:
- переход в безопасный режим (fail-safe);
- сохранение частичной функциональности (fail-soft);
- приостановка работы (fail-hard).

Важно отметить, что приостановка программы не должна совершаться в произвольной части при обнаружении ошибки. Принять решение об остановке может только критически важный код (например, функция *main*). И наоборот, независимый код не должен останавливать работу программы. Например, код библиотеки не должен вызывать остановку программы, т.к. пользователь библиотеки отвечает за это.
## Оповещения об ошибке
Если независимый код обнаруживает нарушение контракта или потенциальную ошибку исполнения, без остановки программы он должен оповестить код пользователя об этом. Существует множество способов это сделать: использовать специальные ключевые слова (*assert*, *signal*, *raise* и т.п.), установить глобальную или локальную переменную-флаг в соответствующее значение (например, *errno*, *EOF*), возвращать специальное значение как результат функции, которое можно проверить -- но не все способы уместны в том или ином контексте. Например, для фрагмента кода ниже можео использовать несколько способов.

    size_t index(int a[n], int find) {
        for (size_t i = 0; i < n; i++)
            if (find == a[i]) return i;
        
        return ???;
    }
Функция *index* должна вернуть индекс элемента, значение которого соответствует второму аргументу. Если искомый элемент найден, функция может вернуть положительное целое число, находящееся в ожидаемом диапазоне. Если же элемент не найден и возвращать нечего, функция должна завершиться легальным способом.
### assert
Один из часто встречающихся способов сообщать об обнаружении ошибки показан ниже.

    size_t index(int a[n], int find) {
        size_t i = 0;
        for ( ; i < n; i++)
            if (find == a[i]) return i;
        
        assert (i != n);
    }
Ключевое слово *assert* проверяет значение булевого выражения в скобках. Если значение выражения -- *false* т.е. ложность, работа программы немедленно завершается с соответствующим сообщением в потоке вывода. Таким образом, этот способ может реагировать на нарушение контракта. Тем не менее, использовать его непосредственно для обработки ошибок не стоит. Во-первых, как уже говорилось выше, не все части программы должны останавливать программу принудительно. Во-вторых, в некоторых языках программирования общепринято "деактивировать" инструкции *assert* при компиляции. 

На практике *assert* используется не для того, чтобы выявлять ошибки в программе, а для того, чтобы указать на предположения, которые заложены в работу той или иной функции, вследствие чего они играют роль формализации условий контракта и в исходный код программы не включаются.
### Специальные возвращаемые значения (in-band error)
Ниже показан альтернативный способ сообщить об ошибке, который часто применяется на практике.

    size_t index(int a[n], int find) {
        for (size_t i = 0; i < n; i++)
            if (find == a[i]) return i;
        return n;
    }
Данная версия возвращает значение ожидаемого типа даже в случае, когда индекс найти невозможно -- возвращается размер исходного массива, который выходит за пределы диапазона возможных индексов, но при этом может участвовать в выражениях, где индекс ожидается в качестве результата, и может быть проверен. 

    size_t m = index(a, n);
    if (m == n) ...
Здесь проверка в пользовательском коде может заранее определить успешный результат функции *index*. При этом, контракт все таки нарушается (пост-условие не выполняется). Исправить это, возвращая другое значение, нельзя, так как никакое из целых чисел, не входящих в правильный диапазон значений, не соответствует ожидаемому, а следовательно, требует проверки результата функции.
### Исключения (exception)
Другой часто используемый способ заключается в вызове исключений.

    size_t index(int a[n], int find) {
        for (size_t i = 0; i < n; i++)
            if (find == a[i]) return i;
        throw std::out_of_range("Not found!");
    }
Ключевое слово *throw* принудительно завершает работу функции и выходит из ее области на стэке, в место вызова. Если "брошенное" таким образом исключение (в примере выше -- объект *out_of_range*) не обработать непосредственно в месте вызова первоначальной функции, в том месте тоже будет завершена работа и выход во внешнюю область на стэке. Если исключение не обрабатывается нигде в цепочке вызовов, при выходе из функции *main* программа закрывается. 

Например, имея следующую структуру, программа завершится при возникновении исключительной ситуации.

    void check() {
        int x[] = {1, 2, 3};
        auto m = index(x, 4);
        return;
    }

    int main() {
        check();
        return 0;
    }
Функция *index* бросит исключение, которое не обрабатывается в функции *check*, которая принудительно завершится, бросив исключение в функцию *main*. В функции *main* исключение тоже не обрабатывается, поэтому она тоже досрочно завершится, и программа будет остановлена. Для обработки ислючений в языке С++ используется пара ключевых слов *try-catch*.

    try {
        auto m = index(a, n);
    } catch ( std::out_of_range &err ) {
        std::cerr << err.what();
    }
Блок *try* обнаруживает необработанные исключения, брошенные кодом, который включен в блок. Программа выходит из блока *try* при первом обнаруженном исключении. При выходе из блока *try* программа продолжается в блоке *catch*, если был брошен соответствующий типу исключения в таком блоке объект.

В примере выше функция *index* бросает исключение типа *out_of_range* в рамках блока *try*, и в месте вызова есть блок *catch* с аргументом такого типа. Когда функция *index* будет прервана исключением, код сразу перейдет к строке *std::cerr << err.what()*, после чего выйдет из блока *catch* и продолжит работу программы. Если бы функция бросала исключение другого типа, этот блок *catch* не может поймать исключение другого типа, и оно бы бросалось дальше -- вплоть до функции *main*.

В языке С++ все стандартные исключения расширяют общий родительский тип данных *std::exception*, поэтому при наличии в программе блока *catch*, который ловит такой тип исключений, все стандартные исключения будут попадать в него, за неимением специализированных блоков.

    try {
        auto m = index(a, n);
    } catch ( std::out_of_range &err ) {
        std::cerr << err.what();
    } catch ( std::exception &err ) {
        std::cerr << err.what();
    }
Если в программе может возникнуть несколько разных типов исключений, и они все объединены общей иерархией, их все можно обрабатывать в одном блоке *try*, как показано в примере выше. Специализации блоков *catch* должны идти сверху вниз, от более специализированного к более общему. Для особых исключений, которые не входят в конкретную иерархию типов данных, нужно объявлять отдельный блок *catch*.

Как видно из примеров выше, семантика работы с исключениями достаточно сложна, и использовать их в коде нужно с умом. На практике они применяются только для исключительных по своей опасности ситуаций (отсюда и название), когда другие стратегии обработки ошибок исчерпаны. Исключения занимают промежуточную позицию между немедленной остановкой программы и восстановлением после возникновения ошибки, так как дают возможность сделать и то, и другое. Тем не менее, их редко используют, так как они влекут за собой множество трудностей в организации кода программы.

Во-первых, исключения в функциях нарушают контракт (не выполняется пост-условие, функция не возвращает значение ожидаемого типа). Во-вторых, исключения "разрывают" код программы аналогично переходам с помощью *goto* (совершая безусловный прыжок из строки с ошибкой в произвольное место программы, где находится подходящий блок *catch*). В-третьих, они вынуждают пользователей обрабатывать исключения в тех местах, где делать это им не хотелось бы, т.е. их тяжело интегрировать в существующий код (так как любая функция, которая бросает исключение, требует добавлять в код блоки *try* и *catch*, что может быть проблематично). В-четвертых, исключения часто тратят непропорционально много ресурсов компьютера, когда их приходится обрабатывать.
### Значения с выбором (optional, expected)
Возникает закономерный вопрос: как сообщить об ошибке пользовательскому коду, не используя исключения и не нарушая контракт? 

Есть традиционный путь использовать возвращаемое значение для оповещении об ошибке, не нарушая контракт -- возвращать "код" ошибки в любом случае (либо ошибка была, либо ее не было), а непосредственно результат функции записывать в дополнительную переменную (либо глобальную, либо ссылочную). 




    void str_build(std::string &s) {
        s += generate_prefix(); // может выйти заранее
        s += generate_suffix(); // может выйти заранее
    }
Восстановление состояния в случае ошибки.

    void str_build(std::string &s) {
        auto tmp = std::string{s};
        tmp += generate_prefix();
        tmp += generate_suffix();
        std::swap(tmp, s);
    }

