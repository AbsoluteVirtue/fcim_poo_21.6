# Контракты
## Выявление типов

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Функция *prod* определена для двух произвольных параметров. Определение говорит, что если один из аргументов -- пустой список, значение функции равно нулю. Во всех остальных случаях значение функции определено суммой произведений пары элементов в начале каждого списка-аргумента с результатом этой же функции с остатками ("хвостами") обоих списков.

Интересно здесь другое: откуда компилятор знает, что аргументы в параметрах a и b являются списками на самом деле?

    prod ([1, 2, 3], [4, 5, 6])
Для такого вызова компилятор определит функцию самостоятельно следующим образом:

    val prod = fn: int list * int list -> int
Т.е. компилятор определелил символ *prod* как функцию, которая принимает два вектора и возвращает скалярное значение.

Даже если компилятор может определить типы данных аргументов, как он определяет соответствие типов аргументов типам параметров? Все сравнительно просто. Сам факт того, что в функции оба параметра сравниваются с пустыми списками, означает, что типы этих параметров - обобщенные списки. Возвращаемое значение функции обязательно будет целым числом, так как оба определения функции сводятся к целому числу (либо нулю, либо сумме целого числа со значением функции). Отсюда же следует, что списка должны содержать числовые значения, т.к. их отдельные элементы перемножаются.

Этот процесс должен проверить код на удовлетворение ограничений, которые обнаруживаются при определении любой функции. Аппликация функции к аргументу или аргументам генерирует эти такие ограничения (область определения функции должна быть совместима с областью значений функции, иначе определение функции некорректно). Ограничения разрешаются методом последовательного исключения. 

Если для конкретного случая существует строго одно решение, соответствующие типы данных можно определить однозначно. Если существует несколько вохможных решений, функция полиморфна, при этом есть одно "лучшее" решение. Если решений нет, то определение функции неверно в принципе.  

Как компилятор проверяет соответствие значений аргументов требованиям функции? Это может вызвать трудности. Например, если передать функции два списка разной длины, в момент, когда один список уже закончился, умножение будет производиться между первым элементом более длинного списка и пустым множеством. Здесь у компилятора два способа выйти из ситуации: либо позволить функции вычислить значение до этого момента и в итоге сообщить об ошибке, либо проверить длины списков заранее и сообщить об этом во время компиляции. Первый способ присущ динамическим системам типов, а второй -- статическим.
### Перегрузка операторов
Перегрузка операторов может внести дополнительные трудности в систему типов. Чтобы в этом убедиться можно рассмотреть знакомый пример.

    const char * __begin1 = __range1;
    const char * __end1 = __range1 + 10L;
    for (; __begin1 != __end1; ++__begin1) {
        const char & c = *__begin1;
    }
В языке С++ процесс итерирования по коллекции традиционно повторяет идиоматический способ, используемый в языке С -- использование указателей на начало и конец диапазона значений. Если существует два адреса, один из которых был выделен "раньше" второго, и они принадлежат одному множеству адресов, между этими адресами можно исследовать все байты. 

В случаях, когда адреса диапазона недоступны, можно обратиться к итераторам.

    auto __begin1 = __range1.begin();
    auto __end1 = __range1.end();
    for (; ::operator!=(__begin1, __end1); __begin1.operator++())
    {
        const char & c = __begin1.operator*();
    }
Определение цикла в двух примерах почти не отличается. Это возможно благодаря тому, что для итераторов *__begin1* и *__end1* все операторы перегружены так, чтобы их поведение полностью совпадало с указателями. Это добавляет сложности в систему типов, так как не все коллекции, реализующие собственные итераторы, легко могут повторить поведение диапазонов байтов. Например, связные списки не хранят значения в памяти как массивы, и оператор "++" для их итераторов должен быть реализован особым способом.

Другой пример, где неправильное переопределение может привести к серьезным проблемам -- перегрузка оператора "<".

    template <typename _RandomAccessIterator>
    void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                   std::random_access_iterator_tag)
    {
        if (__first == __last) return;
        --__last;
        while (__first < __last)
        {
            std::iter_swap(__first, __last);
            ++__first;
            --__last;
        }
    }
Для иллюстрации выше приводится пример определения стандартного алгоритма. Сравнение *__first < __last* предполагает, что сравниваются значения какого-то диапазона, так как они меняются местами, если первый элемент меньше последнего. Если в эту функцию передать указатели, сравнение указателей может дать неожиданный и часто неправильный результат, так как сравниваться будут их адреса, а порядок байтов в памяти напрямую никак не связан с порядком значений в колелкции.

Отсюда следует, что оператор "<" должен быть перегружен для значений, а не для самих указателей.
    
    friend bool operator<(iterator a, iterator b) { return *a.p < *b.p; }
Подводя промежуточный итог: система типов может проверить отношения между типами значений, участвующих в выражении, но на разработчика ложится ответственность за передачу значений, которые не только соответствуют ограничениям системы типов, но и удовлетворяют логическим требованиям определения той или иной операции.
## Предусловия и постусловия
Тщательность проверки ограничений системой типов зависит от вида системы в конкретном языке. Большинство языков не проверяет логические ограничения в рамках системы типов, оставляя это на усмотрение разработчиков. По этой причине во многих языках существуют как официальные, так и неофициальные расширения, которые, например, проверяют аргументы функции на соответствие всем ограничениям. 

В примерах выше таким ограничением было, например, требование, чтобы длины контейнеров были равными. Другой, менее очевидный пример: *int f(double, double)* -- здесь есть две потенциальные проблемы, которые могут возникнуть у пользователей данной функции. Во-первых, неочевидна природа возвращаемого значения (почему целое число и как именно оно вычисляется для двух аргументов). Во-вторых, явно не указаны допустимые значения аргументов, а также возможные отношения между ними.

Тем не менее, эти логические свойства являются важной частью определения данной функции и они неявно подразумеваются каждый раз, когда функция вызывается. Такие правила, которые устанавливаются между вызывающей стороной и вызываемым поведением, называются "контрактом."



Проверка выносится из функции наружу и переходит из области ответственности разработчика в область ответственности пользователя, т.к. разработчик условной библиотеки не может знать заранее все возможные сценарии, в которых его функции будут использоваться, а пользователь эти сценарии организцет, поэтому и должен принимать такие решения.
# Обработка ошибок

