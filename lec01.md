# Введение
Начать обсуждение концепции “объектно-ориентированный подход” в программировании стоило бы с цитаты человека, который первым начал использовать данный термин в своей работе. 

 > “Одним из идеалов в 1960-х для вычислительных систем было не просто использовать их в сфере образования, а создать новое мышление, которое стало необходимым после индустриальной революции с появлением проблемы масштабирования в контексте человеческого бытия. Эйнштейн заметил, что мышление, которое создает для нас проблемы, не поможет нам решить эти проблемы. Нужно другое мышление. Это глубокая мысль!”

Эта цитата принадлежит Алану Кёртису Кею, который работал в исследовательской лаборатории PARC корпорации Xerox, когда ему пришло в голову назвать свои программы объектно-ориентированными. Она может служить лейтмотивом данного курса. Похожую мысль высказал другой известный компьютерный инженер, лауреат премии имени Алана Тьюринга Джон Бакус.

>  “Широко распространенные сегодня языки программирования становятся все больше, но при этом не становятся мощнее. Врожденные дефекты в самом основании делают их опухшими и слабыми: примитивный стиль программирования, унаследованный от своего общего предка – компьютера Фон Неймана, сильная привязка семантики к изменениям состояний в памяти, разделение всего программирования на мир выражений и мир утверждений, невозможность эффективно использовать мощные инструменты для комбинации существующих программ в новые, отсутствие в них полезных математических свойств – для того, чтобы делать правильные умозаключения о компьютерных программах.”

Обе цитаты особо подчеркивают необходимость нового способа мышления для написания хороших компьютерных программ. Объектно-ориентированное программирование было попыткой сделать такое мышление более естественным и оттого – более распространенным.

Такое мышление должно начинаться с модели исчисления, которая будет применяться для решения конкретной задачи. Моделями исчисления могут быть как чисто абстрактные модели (математические), так и хард-модули (физические), а также языки программирования. Сам Бакус выделял четыре критерия оценки любой модели исчисления:
1. Наличие математического обоснования (формального описания).
2. Наличие системы хранения состояния (истории).
3. Семантический тип (поведение).
4. Ясность и полезность.

Если первые три критерия относятся к эффективности программ при решении задач, то последний подчеркивает важность человеческого аспекта программирования: выражают ли программы процесс исчисления ясно; воплощают ли программы концепции, которые помогают формулировать процессы.

Согласно этим четырем критериям Бакус категоризовал модели исчисления следующим образом.
1. Простые модели.
2. Аппликативные модели.
3. Фон-Неймановские модели.
4. Все остальные модели.

Первая категория содержит “машины Тьюринга” – простые конечные автоматы, позволяющие описывать вычислительные процессы с помощью дискретных состояний и переходов между ними. Вторая категория представлена лямбда-исчислением (далее, “λ-исчисление”), автором которого были математик Алонзо Чёрч и его студенты. Третья категория включает современные компьютеры, а также языки программирования, которые их симулируют: вычисления происходят на основе комбинации центрального вычислительного устройства, хранилища данных и соединяющего их провода – “шины”, пропускная способность которой выражена “машинным словом”. В рамках данного курса будут рассматриваться языки, относящиеся к одной из этих трех категорий.

В качестве решения Бакус предлагал новую парадигму программирования, которую он называл “функциональной”. По ходу данного курса станет очевидно, что “объектно-ориентированная” и “функциональная” парадигмы похожи друг на друга не только тем, что они преследовали одну и ту же цель, но и методами, которыми данная цель достигалась.

## Альтернативный стиль программирования
В качестве конкретного примера серьезной проблемы, которая преследовала императивные языки (к таким языкам относятся, в первую очередь, “ассемблерные” языки и те модели, которые их близко повторяют) стоит рассмотреть синдром “воронки Фон Неймана”. Конечное предназначение любой компьютерной программы – изменить данные в хранилище данных. Данные каждый раз передаются на центральное вычислительное устройство по проводу, при этом большая часть передаваемой информации – это адреса, по которым хранятся данные – метаданные. Так создается ситуация, в которой программист оказывается заложником “мышления по одному слову за раз”: каждая переменная изменяется отдельно, каждая инструкция выполняется отдельно, сама операция присваивания вынуждает изменять данные по отдельности. Как отмечал Бакус, “ присваивание делит программирование на два мира: мир выражений справа от присваивания и мир объявлений слева. Все полезные действия происходят в мире выражений”.

Более сложный пример, который приводит Бакус, состоит в решении задачи скалярного произведения двух векторов. Сама задача проста: получить скалярную величину, которая является суммой произведений значений из двух произвольных векторов (списков значений).

    c := 0
    for i := 1 step 1 until n do
        c := c + a[i] * b[i]
Каждая строка представляет собой какое-то утверждение. Каждое утверждение манипулирует состоянием данных в памяти, что никак не выражено в самом тексте программы, за исключением инициализации переменных c и i. Утверждения не структурированы в иерархию (то есть, нет прямого обозначения зависимостей между отдельными утверждениями, которое Бакус называет “синтезом”). Вместо этого используется повторное присваивание, что скрывает первоначальный замысел. Часть данных вводится в программу в качестве служебной информации с неочевидным намерением. Так, переменная n в заголовке цикла никак не привязана к другим значениям синтаксически, при этом она накладывает ограничение на размер обоих векторов, что лишает программу обобщенности (программа будет работать только для векторов такой длины).

Для контраста Бакус предлагает другое решение, заимствованное из мира абстрактной алгебры.

    (Insert +) ∘ (ApplyToAll *) ∘ Transpose
Для того, чтобы убедиться в эквивалентности этих двух решений, следует взять конкретные значения. Для двух списков: (1, 2, 3) и (6, 5, 4) – первое решение аккумулирует в переменной c сумму произведений пар значений. То есть, сумма пар (1 * 6), (2 * 5) и (3 * 4) равна 6 + 10 + 12 = 28.

Для тех же двух списков второе решение вычисляет результат немного иначе. Транспонирование матрицы, состоящей из этих двух списков даст три новых списка: (1, 6), (2, 5) и (3, 4). Затем, перемножение элементов каждого списка даст три скалярных значения: 6, 10 и 12. Наконец, сумма этих трех значений равна 6 + 10 + 12 = 28.

Оба решения дают один и тот же результат. При этом второе решение не использует невидимые состояния (нет переменных), выстраивает строгую иерархию (функциональная композиция, отмеченная оператором ∘ явно указывает на зависимость одних выражений от других), оперирует цельными концепциями (векторами произвольной длины, а не областями памяти), полностью обобщена (нет привязки к конкретным спискам или к конкретной длине списков).

Подытожить пример можно следующим образом. Функциональный стиль предлагает альтернативу тому, как можно представлять себе решения задач вычислимости. Такой стиль предлагает программисту вырваться из тесных рамок, которые ему навязывает архитектура компьютеров. Программирование можно и нужно рассматривать как продолжение алгебры, что дает полную свободу в выборе инструментов для решения задач. Забегая вперед, следует отметить, что Алан Кей предлагал свое решение, исходя из таких же предпосылок.

## λ-исчисление
Перед тем, как перейти к рассмотрению свойств объектно-ориентированного подхода, следует подробней ознакомиться с аппликативным методом вычисления, который стал предпосылкой к появлению как функционального, так и объектно-ориентированного программирования.

Для начала – основные инструменты вычисления, на которых основывается данная модель: функциональная абстракция, аппликация, редукция.

### Абстракция
Следующий простой пример содержит элементарное выражение, которое в совокупности представляет собой абстракцию какого-то вычисления.

    λx.x 
или

    λ: x -> x 
Переменная х слева от точки является функциональным параметром. Переменная x справа от точки является выражением, описывающим результат вычисления. Первоначальное выражение можно представить в виде функции одного переменного, где значением функции является ее аргумент.

### Аппликация
Само вычисление происходит посредством аппликации выражения к какому-то значению.

    (λx.x) (42)
или
    
    λ: x -> x => λ(42) -> 42
Аппликация подразумевает подстановку значения в выражения в качестве аргумента. В примере выше для ясности первая пара скобок содержит само выражение, а вторая - значение. Аппликация выражения к значению “42” приводит к подстановке этого значения в параметр x и имеет своим результатом значение “42”.

### Редукция
Выражения можно комбинировать в любой последовательности.

    (λx.(λy.x)) (1) (2)
В данном примере результатом выражения будет другое выражение. Поэтому список значений справа потребляется по одному значению. Число “1” будет первым аргументом, следовательно результирующее выражение выглядит так: λy.1 – очевидно, что аппликация данного выражения к любому значению сводится к числу “1”, что и будет окончательным ответом. Процесс последовательного решения составных выражений называется редукцией.

Следующие три выражения являются насколько часто применяемыми, что у них есть общепринятые имена. 

| “тождество” | “истинность” | “ложность” |
| :-: | :-: | :-: |
| λx.x | λx.(λy.x) | λx.(λy.y) |

Интересны же они по другой причине, это стоит рассмотреть на отдельном примере.

    ((λx.x) (λx.(λy.x)) (λx.(λy.y)))
или

    ((тождество) (ложность) (истинность))
Три выражения описывают три концепции, которые часто используют для математических доказательств. Интересно же здесь то, как их можно комбинировать для вычислений. Имея комбинацию выражений в виде выражения: ((тождество) (ложность) (истинность)) – какой результат будет, если применить его к конкретному значению? Например, если значением будет другое выражение:

    ((тождество) (ложность) (истинность)) (истинность)
С помощью подстановки можно “раскрыть скобки” в выражении слева. Тождеством истинности является сама истинность, поэтому можно произвести следующую замену.

    (истинность) (ложность) (истинность)
или
    
    (λx.(λy.x)) (ложность) (истинность)
Внизу раскрыта абстракция истинности, чтобы можно было явно записать результат следующей подстановки. Процесс аппликации требует подставить ложность в выражение слева: λложность.(λy.ложность) -> ложность. Таким образом, последний этап редукции выглядит так.

    (ложность) (истинность)
или

    (λx.(λy.y)) (истинность)
Раскрыв выражение слева и подставив последний оставшийся аргумент: λистинность.(λy.y) -> y – полученное значение будет чем угодно, только не истинностью, а значит ложностью. Так, с помощью простейших выражений можно закодировать понятие логического отрицания.

В контексте объектно-ориентированного программирования λ-выражения интересны по нескольким причинам. В первую очередь, тем, что они являются основой для анонимных функций в языках программирования. Самые внимательные читатели должны были заметить, что и в языке С выражения производят значения по схожим правилам, так как компилятор следует определенному порядку (иерархии) для разрешения выражений. Наконец, λ-выражения иллюстрируют силу такого механизма, как функциональная абстракция, с помощью которого декларативно можно описать вычисление любой сложности. В подавляющем большинстве языков программирования семантика функций реализуется по той же схеме.

## Роль абстракций
Примеры выше должны показать, насколько важной концепцией является абстракция на всех уровнях. Если переменные являются абстракцией конкретных значений, обобщая значение, то функции являются уже абстракциями вычислений, обобщая процесс вычисления. 

Объектно-ориентированный подход, как будет показано далее в рамках этого курса, основан на идее абстракции уже функций и типов данных (аналогично функциональному подходу). Перефразируя Андрея Александреску, можно в качестве промежуточного итога сказать, что если в процедурном программировании появляется возможность определять функции и вызывать их, то в объектно-ориентированном программировании можно вызывать функции, которые еще не были определены, а в обобщенном программировании можно писать программы для типов данных, которые еще не были определены.
