/*
Лабораторная работа 2 - Конструкторы

С помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Соответственно, для инициализации внутренних полей необходимо добавить в класс все нужные конструкторы и деструктор.

Конструктор по умолчанию не имеет параметров, ничего не возвращает, инициализирует внутренние поля класса в правильные значения по умолчанию.

Конструктор с параметром типа size_t принимает целое беззнаковое число, которое указывает на желаемый размер коллекции, которую необходимо создать, чтобы сохранить созданный в функции контейнер.

Конструктор с двумя параметрами (указатель – адрес массива целых чисел, целое беззнаковое число – размер этого массива) должен создать контейнер такого же размера, содержащий те же значения, что и массив-аргумент функции.

Конструктор копирования имеет один параметр – константную ссылку (&) на объект заданного класса, создает идентичную копию (deep copy – изменение копии объекта не должно изменять первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения.

Конструктор переноса имеет один параметр – rvalue-ссылку (&&) на объект заданного класса, создает идентичную копию (shallow copy – изменение копии объекта очищает первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения.

Деструктор не имеет параметров. Его задача – освободить память, занимаемую контейнером и установить поля объекта в правильные значения. 

Функция clear из предыдущей лабораторной работы конвертируется в метод класса, поэтому параметров больше не имеет, ничего не возвращает. В этом методе также необходимо освободить память, занимаемую контейнером, и установить поля объекта в правильные значения.

Функция at из предыдущей лабораторной работы конвертируется в метод класса. Метод имеет один параметр – целое число (которое может принимать отрицательные значения), возвращает элемент коллекции из текущего объекта, находящийся по индексу, заданному вторым аргументом. Если второй аргумент отрицательный, необходимо предварительно преобразовать его в соответствующее положительное число, в зависимости от размера коллекции. Если значение второго аргумента не входит в диапазон возможных индексов коллекции, необходимо вернуть элемент коллекции, находящийся на первом или последнем месте, в зависимости от знака индекса.

Метод resize принимает беззнаковое целое число в качестве аргумента – количество элементов, которые должен в себе содержать контейнер после операции. Метод оставляет нужное количество элементов, считая сначала, удаляя остальные. Если size() меньше чем значение аргумента, оставшиеся места в массиве заполняются значениями по умолчанию определяемыми для конкретного типа данных. Асимптотичность метода линейна относительно разницы между величинами size() и значением аргумента – O(n).

Метод assign принимает два аргумента: беззнаковое целое число, обозначающее количество элементов, целое число, содержащее новое значение этих элементов. Метод заменяет элементы коллекции на заданное количество с заданным значением для всех новых элементов.

Метод empty возвращает булевое значение: “истинность”, если коллекция не содержит ни одного элемента, и “ложь” в противном случае.
 
Метод swap принимает ссылку (&) на объект заданного типа и обменивает значения элементов внутренней коллекции с элементами коллекции из аргумента. При этом метод не должен производить операции копирования или переноса над отдельными элементами коллекций, сохраняя все существующие в программе ссылки на отдельные элементы обеих коллекций. Асимптотичность метода константная – O(1).

Метод size возвращает текущий размер коллекции. Асимптотичность метода константная – O(1).

Статический метод is_equal имеет два параметра – два объекта заданного класса, которые необходимо сравнить. Метод возвращает “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их контейнеры. Контейнеры равны, если они содержат равное количество элементов, а также – если значение каждого элемента одного контейнера равно элементу другого контейнера на том же месте. Асимптотичность метода линейна относительно size() – O(n).

Ниже показаны примеры прототипов функций, из которых складывается интерфейс абстрактного типа данных.
*/

#include <cassert>
#include <iostream>
#include <utility>
// остальные необходимые библиотеки здесь

class /* название варианта здесь */ {
private:
    // необходимые поля с данными здесь
public:
    // рекомендуемые прототипы функций:
    ~/* название варианта здесь */();
    /* название варианта здесь */();
    /* название варианта здесь */(size_t);
    /* название варианта здесь */(const int[], size_t);
    /* название варианта здесь */(const /* название варианта здесь */&);
    /* название варианта здесь */(/* название варианта здесь */ &&);
    void clear();
    int at(int);
    void resize(size_t);
    void assign(size_t, int);
    size_t size();
    bool empty();
    void swap(/* название варианта здесь */&);
    static bool is_equal(const /* название варианта здесь */&, const /* название варианта здесь */&);
};

// код для проверки правильности выполнения задания:
using container = /* название варианта здесь */;

int main() {
    int array[] = {1, 4, 7, 9};
    container a(array, 4);
    assert(4 == a.size());
    assert(1 == a.at(0));
    assert(9 == a.at(10));
    container b(a);
    assert(container::is_equal(a, b));
    b.clear();
    assert(b.empty());
    container c;
    assert(c.empty());
    c.assign(3, 7);
    assert(3 == c.size());
    container d(5);
    assert(5 == d.size());
    d.resize(10);
    b.swap(d);
    assert(10 == b.size());
    assert(d.empty());
    container e = std::move(b);
    assert(10 == e.size());
    assert(b.empty());
}
