/*
Лабораторная работа 2 - Конструкторы

Взяв за основу предыдущую лабораторную с помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Соответственно, для инициализации внутренних полей необходимо добавить в класс все нужные конструкторы и деструктор.

Конструктор по умолчанию не имеет параметров, ничего не возвращает, инициализирует внутренние поля класса в правильные значения по умолчанию.

Конструктор с параметром типа size_t принимает целое беззнаковое число, которое указывает на желаемый размер коллекции, которую необходимо создать, чтобы сохранить созданный в функции контейнер.

Конструктор с двумя параметрами (указатель – адрес массива целых чисел, целое беззнаковое число – размер этого массива) должен создать контейнер такого же размера, содержащий те же значения, что и массив-аргумент функции.

Конструктор копирования имеет один параметр – объект заданного класса, создает идентичную копию (deep copy – изменение копии объекта не должно изменять первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения.

Деструктор не имеет параметров. Его задача – освободить память, занимаемую контейнером и установить поля объекта в правильные значения. При этом функция clear из предыдущей лабораторной работы конвертируется в метод класса, поэтому параметров больше не имеет, ничего не возвращает. В этом методе также необходимо освободить память, занимаемую контейнером, и установить поля объекта в правильные значения.

Функция is_equal из предыдущей лабораторной работы конвертируется в статический метод класса, имеет два параметра – два объекта заданного класса, которые необходимо сравнить. Метод возвращает “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их контейнеры. Контейнеры равны, если они содержат равное количество элементов, а также – если значение каждого элемента одного контейнера равно элементу другого контейнера на том же месте.

Функция at из предыдущей лабораторной работы конвертируется в метод класса. Метод имеет один параметр – целое число (которое может принимать отрицательные значения), возвращает элемент коллекции из текущего объекта, находящийся по индексу, заданному вторым аргументом. Если второй аргумент отрицательный, необходимо предварительно преобразовать его в соответствующее положительное число, в зависимости от размера коллекции. Если значение второго аргумента не входит в диапазон возможных индексов коллекции, необходимо вернуть элемент коллекции, находящийся на первом или последнем месте, в зависимости от знака индекса.

Метод resize принимает беззнаковое целое число в качестве аргумента – количество элементов, которые должен в себе содержать контейнер после операции. Метод оставляет нужное количество элементов, считая сначала, удаляя остальные. Если length меньше чем значение аргумента, оставшиеся места в массиве заполняются значениями по умолчанию определяемыми для конкретного типа данных. Асимптотичность метода линейна относительно разницы между величинами length и значением аргумента – O(n).

Метод assign принимает два аргумента: беззнаковое целое число, обозначающее количество элементов, целое число, содержащее новое значение этих элементов. Метод заменяет элементы коллекции на заданное количество с заданным значением для всех новых элементов.

Метод empty возвращает булевое значение: “истинность”, если коллекция не содержит ни одного элемента, и “ложь” в противном случае.
 
Метод swap принимает ссылку на объект заданного типа и обменивает значения элементов внутренней коллекции с элементами коллекции из аргумента. При этом метод не должен производить операции копирования или переноса над отдельными элементами коллекций, сохраняя все существующие в программе ссылки на отдельные элементы обеих коллекций. Асимптотичность метода константная – O(1).

Метод length возвращает текущий размер коллекции.

Функция print принимает константную ссылку на объект заданного типа и выводит элементы контейнера в порядке возрастания.

Ниже показаны примеры прототипов функций, из которых складывается интерфейс абстрактного типа данных.
*/

#include <cassert>
#include <iostream>
// остальные необходимые библиотеки здесь

class abstract_data_t {
public:
    // рекомендуемые прототипы функций:
    ~abstract_data_t();
    abstract_data_t();
    abstract_data_t(size_t);
    abstract_data_t(const int[], size_t);
    abstract_data_t(const abstract_data_t&);
    void clear();
    int at(int);
    static bool is_equal(
        const abstract_data_t&, const abstract_data_t&);
    void resize(size_t);
    void assign(size_t, int);
    size_t length();
    bool empty();
    void swap(const abstract_data_t&);
private:
    // необходимые поля с данными здесь
};

// код для проверки правильности выполнения задания:
int main(int argc, char const *argv[]) {
    int array[] = {1, 4, 7, 9};
    abstract_data_t a(array, 4);
    assert(4 == a.length());
    assert(1 == a.at(0));
    assert(9 == a.at(10));
    for(size_t i = 0; i < a.length(); i++) 
        std::cout << a.at(i) << " ";
    abstract_data_t b(a);
    assert(abstract_data_t::is_equal(a, b));
    b.clear();
    assert(b.empty());
    abstract_data_t c;
    assert(c.empty());
    c.assign(3, 7);
    assert(3 == c.length());
    abstract_data_t d(5);
    assert(5 == d.length());
    d.resize(10);
    b.swap(d);
    assert(10 == b.length());
    assert(d.empty());
}
