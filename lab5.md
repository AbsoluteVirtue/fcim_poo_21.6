# Лабораторная работа 5
## Наследование
### Задание
Необходимо написать код, который иллюстрирует механизм наследования в языке С++. Используя структуры или классы нужно создать иерархию наследования и показать использование ключевых слов public, protected и private в контексте наследования. Также необходимо показать использование множественного наследования, проиллюстрировать потенциальные проблемы, с ним связанные, и способы их решения.

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
## Динамический полиморфизм, интерфейсы
### Дополнительное задание
Взяв предыдущую лабораторную работу за основу необходимо создать иерархию наследования, где класс abstract_data_t выступает в роли интерфейса (то есть, является абстрактным базовым классом для другого класса с реализацией). В коде ниже уже присутствует чисто виртуальный метод (деструктор класса abstract_data_t), это нужно для того, чтобы класс компилятором определялся как чисто абстрактный.

    class abstract_data_t {
    public:
        // методы из предыдущей лабораторной работы здесь как чисто виртуальные

        virtual ~abstract_data_t() = 0;
        virtual int &front() = 0;
        virtual int &back() = 0;
        virtual void push(int) = 0;
        virtual void pop() = 0;
        virtual void extend(const abstract_data_t&) = 0;
    };
Для первоначального класса:

Метод front возвращает значение первого элемента коллекции.

    public:
        int &front() override;
Метод back возвращает значение последнего элемента коллекции.

    public:
        int &back() override;
Метод push принимает один аргумент – целое число – и добавляет значение аргумента в качестве нового элемента в начало (или конец) заданной коллекции.

    public:
        void push(int) override;
Метод pop удаляет первый (или последний) элемент из заданной коллекции.

    public:
        void pop() override;
Метод extend с одним параметром (ссылкой на другую коллекцию того же типа, что и заданная) добавляет значения аргумента в конец заданной коллекции в том же порядке, в каком они встречаются в коллекции-аргументе.

    public:
        void extend(const abstract_data_t&) override;
Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:

    class abstract_data_t {
    public:
        // методы из предыдущей лабораторной работы здесь как чисто виртуальные

        virtual ~abstract_data_t() = 0;
        virtual int &front() = 0;
        virtual int &back() = 0;
        virtual void push(int) = 0;
        virtual void pop() = 0;
        virtual void extend(const abstract_data_t&) = 0;
    };

    inline abstract_data_t::~abstract_data_t() {}

    class example : public abstract_data_t {
    private:
        // необходимые поля здесь
    public:
        // методы из предыдущей лабораторной работы здесь
    
        int &front() override;
        int &back() override;
        void push(int) override;
        void pop() override;
        void extend(const abstract_data_t&) override;
    };
