# Лабораторная работа 5
## Обобщенное программирование, шаблоны функций, статический полиморфизм
### Задание
Необходимо написать код, который иллюстрирует использование шаблонов в языке С++. С помощью ключевых слов auto и template нужно написать обобщенные функции, которые принимают диапазоны любой длины, объекты любого типа, произвольное количество аргументов.

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
## Шаблоны типов
### Дополнительное задание
Используя код из четвертой лабораторной работы необходимо создать шаблонный тип данных, где шаблонный параметр(ы) выступает в роли интерфейса.

    template <typename T, typename U> class example {
    private:

    public:

    };
Метод find принимает аргумент заданного в шаблоне типа, соответствующий типу данных хранящихся в контейнере элементов, и возвращает итератор на элемент контейнера, значение которого равно значению аргумента.

    public:
        iterator find(const T&) const;
Метод insert имеет два параметра: итератор, указывающий на существующий в коллекции элемент, и ссылку на значение заданного для коллекции типа. Метод возвращает итератор на новый элемент коллекции. Метод сохраняет элементы, которые уже существуют в коллекции на момент вызова, сдвигая их на один вправо относительно значения первого аргумента. Если новый размер превышает выделенный до сих пор под коллекцию объем памяти, метод вызывает выделение нового блока памяти. При этом все ссылки и итераторы, существующие в программе, которые указывают на элементы, идущие за значением первого аргумента, становятся недействительными Асимптотичность метода линейная относительно длины оставшейся за индексом части коллекции – O(n).

    public:
        iterator insert(iterator, const T&);
Метод erase принимает один аргумент – итератор, обозначающий желаемую позицию элемента на удаление. Метод возвращает итератор на элемент, следующий за удаленным. Метод сохраняет элементы, которые уже существуют в коллекции на момент вызова, сдвигая их на один влево относительно pos. При этом все ссылки и итераторы, существующие в программе, которые указывают на элементы, идущие за pos, становятся недействительными Асимптотичность метода линейная относительно длины оставшейся за индексом части коллекции – O(n).

    public:
        iterator erase(iterator);
        static size_t erase(example<T>&, const T&);
Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:

    template <typename T, typename U>
    class example {
    private:
        // необходимые поля здесь
    public:
        // методы и классы из четвертой лабораторной работы здесь
        // добавить шаблоны по необходимости

        iterator find(const T&) const;
        iterator insert(iterator, const T&);
        iterator erase(iterator);
        static size_t erase(example<T>&, const T&);
    };
