# Лабораторная работа 2
## Конструкторы, деструктор
### Задание
Используя ключевое слово class, согласно принципам абстракции и инкапсуляции создать тип данных, который содержит несколько конструкторов и деструктор. Каждый конструктор должен создавать объект заданного типа, используя данные другого произвольного типа. Деструктор должен освобождать ресурсы, если они были получены объектом при создании или инициализации. 

Композиция данных и функциональность получившегося абстрактного типа данных может быть произвольной.

В функции main нужно показать работоспособность всех операций, созданных для задания.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.

### Дополнительное задание
С помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Соответственно, для инициализации внутренних полей необходимо добавить в класс все нужные конструкторы и деструктор.

    class example {
    private:

    public:
    
    };
Конструктор по умолчанию не имеет параметров, ничего не возвращает, инициализирует внутренние поля класса в правильные значения по умолчанию.

    public:
        example();
Конструктор с параметром типа size_t принимает целое беззнаковое число, которое указывает на желаемый размер коллекции, которую необходимо создать, чтобы сохранить созданный в функции контейнер.

    public:
        example(size_t);
Конструктор с одним параметром-списком инициализации (вида "{1, 2, 3, 4}", размер списка можно определить с помощью аргумента), либо -- с двумя параметрами (указатель – адрес массива целых чисел, целое беззнаковое число – размер этого массива) должен создать контейнер такого же размера, содержащий те же значения, что и массив-аргумент функции.

    public:
        example(const std::initializer_list<int>&)
        // или
        example(const int[], size_t);
Конструктор копирования имеет один параметр – константную ссылку (&) на объект заданного класса, создает идентичную копию (deep copy – изменение копии объекта не должно изменять первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения.

    public:
        example(const example&);
Конструктор переноса имеет один параметр – rvalue-ссылку (&&) на объект заданного класса, создает идентичную копию (shallow copy – изменение копии объекта очищает первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения.

    public:
            example(example&&);
Деструктор не имеет параметров. Его задача – освободить память, занимаемую контейнером и установить поля объекта в правильные значения. 

    public:
        ~example();
Функция clear из предыдущей лабораторной работы конвертируется в метод класса, поэтому параметров больше не имеет, ничего не возвращает. В этом методе также необходимо освободить память, занимаемую контейнером, и установить поля объекта в правильные значения.

    public:
        void clear();
Функция at из предыдущей лабораторной работы конвертируется в метод класса. Метод имеет один параметр – целое число (которое может принимать отрицательные значения), возвращает элемент коллекции из текущего объекта, находящийся по индексу, заданному вторым аргументом. Если второй аргумент отрицательный, необходимо предварительно преобразовать его в соответствующее положительное число, в зависимости от размера коллекции. Если значение второго аргумента не входит в диапазон возможных индексов коллекции, необходимо вернуть элемент коллекции, находящийся на первом или последнем месте, в зависимости от знака индекса.

    public:
        int at(int);
Метод resize принимает беззнаковое целое число в качестве аргумента – количество элементов, которые должен в себе содержать контейнер после операции. Метод оставляет нужное количество элементов, считая сначала, удаляя остальные. Если size() меньше чем значение аргумента, оставшиеся места в массиве заполняются значениями по умолчанию определяемыми для конкретного типа данных. Асимптотичность метода линейна относительно разницы между величинами size() и значением аргумента – O(n).

    public:
        void resize(size_t);
Метод assign принимает два аргумента: беззнаковое целое число, обозначающее количество элементов, целое число, содержащее новое значение этих элементов. Метод заменяет элементы коллекции на заданное количество с заданным значением для всех новых элементов.

    public:
        void assign(size_t, int);
Метод empty возвращает булевое значение: “истинность”, если коллекция не содержит ни одного элемента, и “ложь” в противном случае.

    public:
        bool empty();
Метод swap принимает ссылку (&) на объект заданного типа и обменивает значения элементов внутренней коллекции с элементами коллекции из аргумента. При этом метод не должен производить операции копирования или переноса над отдельными элементами коллекций, сохраняя все существующие в программе ссылки на отдельные элементы обеих коллекций. Асимптотичность метода константная – O(1).

    public:
        void swap(example&);
Метод size возвращает текущий размер коллекции. Асимптотичность метода константная – O(1).

    public:
        size_t size();
Статический метод is_equal имеет два параметра – два объекта заданного класса, которые необходимо сравнить. Метод возвращает “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их контейнеры. Контейнеры равны, если они содержат равное количество элементов, а также – если значение каждого элемента одного контейнера равно элементу другого контейнера на том же месте. Асимптотичность метода линейна относительно size() – O(n).

    public:
        static bool is_equal(const example&, const example&);

Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:

    class example {
    private:
        // необходимые поля с данными здесь
    public:
        ~example();
        example();
        example(size_t);
        example(const int[], size_t);
        example(const example&);
        example(example &&);
        void clear();
        int at(int);
        void resize(size_t);
        void assign(size_t, int);
        size_t size();
        bool empty();
        void swap(example&);
        static bool is_equal(const example&, const example&);
    };
