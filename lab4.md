# Лабораторная работа 4
## Стандартные алгоритмы С++
### Задание
Необходимо написать программу, иллюстрирующую правильное использование функций из стандартной библиотеки алгоритмов (https://en.cppreference.com/w/cpp/algorithm.html). Например,

    #include <algorithm>
    std::vector<int> v(10, 2);
    std::copy(v.cbegin(), v.cend(), std::ostream_iterator<int>(std::cout, " "));
    if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }))
        std::cout << "All numbers are even\n";

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
## Итераторы
### Дополнительное задание
Взяв за основу предыдущую лабораторную с помощью класса необходимо реализовать для своего варианта класс-итератор, который скрывает внутренние поля с данными. Ниже показаны примеры прототипов, из которых складывается интерфейс итератора и абстрактного типа данных.

Итератор должен скрывать работу с указателями внутри контейнера. Таким образом, в случаях, когда метод класса должен вернуть указатель, он возвращает копию итератора.

    class iterator {
    private:

    public:
    
    };
Конструктор копирования имеет один параметр – константную ссылку (&) на объект заданного класса, создает идентичную копию (deep copy – изменение копии объекта не должно изменять первоначальный объект) заданного класса с внутренними полями, установленными в правильные значения. 

    public:
        iterator(const iterator &);
Префиксный оператор инкремента изменяет итератор, передвигая его на следующее значение в контейнере, и возвращает новую версию итератора. Постфиксный оператор инкремента изменяет итератор, передвигая его на следующее значение в контейнере, но возвращает предыдущую версию итератора.
    
    public:
        iterator &operator++();
        iterator operator++(int);
Оператора разыменования возвращает элемент контейнера, на который указывает текущий итератор.

    public:
        int& operator*();
 Оператор сравнения operator== принимает два аргумента: константную ссылку (&) на объект заданного класса слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргументы равны, и “ложь” в противном случае.     
  
    public:
        friend bool operator==(const iterator &, const iterator &);
        friend bool operator!=(const iterator &, const iterator &);
Для первоначального класса:

Метод assign принимает два итератора на последовательный отрезок памяти заданного типа и заменяет значения в текущем контейнере на значения из заданного отрезка.

    public:
        void assign(iterator, iterator);
Метод begin возвращает итератор на первый элемент контейнера.

    public:
        iterator begin();
Метод end возвращает итератор на первый элемент справа за пределами контейнера, если это контейнер из одного блока памяти. Для контейнеров с другой структурой возвращает такое значение, которое обозначает необходимость прервать итерацию, идущую слева-направо.

    public:
        iterator end();
Метод rbegin возвращает итератор на последний элемент контейнера. Это актуально только для контейнеров, которые позволяют переходить от произвольного элемента к предыдущему.

    public:
        reverse_iterator rbegin();
Метод rend возвращает итератор на первый элемент слева за пределами контейнера, если это контейнер из одного блока памяти. Для контейнеров с другой структурой возвращает такое значение, которое обозначает необходимость прервать итерацию, идущую справа-налево. Это актуально только для контейнеров, которые позволяют переходить от произвольного элемента к предыдущему.

    public:
        reverse_iterator rend();
Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:

    class example {
    private:
        // необходимые поля с данными здесь
    public:
        class iterator {
        private:
            // необходимые поля с данными здесь
        public:
            iterator(const iterator &);
            // остальные конструкторы здесь
            iterator &operator++();
            iterator operator++(int);
            int& operator*();
            friend bool operator==(const iterator &, const iterator &);
            friend bool operator!=(const iterator &, const iterator &);
            // остальные операторы здесь
        };
        // методы из предыдущей лабораторной работы здесь

        example(std::initializer_list<int>);
        example(iterator, iterator);
        auto begin();
        auto end();
        auto rbegin();
        auto rend();
        void assign(iterator, iterator);
    };
