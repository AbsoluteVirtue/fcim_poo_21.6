# Функциональное программирование
> What I loved so much about OOP [...]is that it’s composable. If there’s one thing you should remember [is that] composability is the most important thing in programming.

Решение любой сложной задачи можно свести к серии простых задач. Тем не менее, это подразумевает, что простые решения легко компонуются в одно сложное решение. ООП как парадигма должно было стать инструментом декомпозиции и рекомпозиции программ как раз с той целью, чтобы одного набора простых решений хватало на создание новых решений любой сложности.

При этом, существует категория задач, которую решить таким образом с помощью ООП сложно. Объекты плохо подходят для многопоточного (конкурентного) программирования, так как они скрывают все детали реализации, в том числе и те, которые нужны для правильной синхронизации потоков. Например, ссылочные значения внутри объектов не должны принадлежать нескольким объектам одновременно, что в контексте многопоточного процесса может вызвать условие для "гонки за данными". Это можно решить с помощью "взаимного исключения" -- запирания данных в момент любого доступа, но это делает объект трудным для использования в совокупности с другими проектами.

Функциональное программирование как парадигма решает те же самые задачи. Но делается это не засчет создания объектов, а с помощью обогащения функций некоторыми свойствами, которые делают сами функции полноценными объектами без необходимости хранить данные, что сразу снимает проблемы, присущие "классическим" объектам.

Это подразумевает, что функция может участвовать во всех выражениях и как конкретное значение, и как интерфейс, и как единица вычисления. Благодаря такому подходу функции можно бесконечно компоновать друг с другом, так как любая функция элементарно адаптируется под любой интерфейс -- т.е. становится возможным решение и тех задач, которые решаются с помощью ООП, и тех задач, которые ООП решить не в состоянии.
## Функции и их свойства
Математический смысл функции можно условно свести к тому, что это некое соответствие между двумя значениями из какого-то множества или множеств. Например, запись *2->4* означает, что есть какое-то правило, по которому число 2 может измениться на число 4, тогда функцией будет стрелка между ними, указывающая на направление изменения. Стрелкам удобно давать различные имена. Тогда запись можно сделать более знакомой: *f(2) = 4*, здесь функция обозначается через символ f, его применение к аргументу "2" производит значение "4".

В программировании принято использовать похожую форму записи. Но не во всех языках функции обладают теми же свойствами, что и математические функции.

    int prod (int a[], int b[]) {
        int c = 0;
        for (unsigned long i = 0; i < n; ++i) c += a[i] * b[i];
        return c;
    }
Выше показан уже знакомый пример произведения двух векторов a и b. Это не является функцией в привычном понимании, так как код перечисляет последовательность выражений, каждое из которых было бы функцией. Это, скорее, процедура, которая имитирует функцию все по тем же причинам -- чтобы ее можно было легко компоновать с другими такими же процедурами.

    auto prod (const auto& a, const auto& b) {
        return std::inner_product(a.begin(), a.end(), b.begin(), 0);
    }
Такой вариант уже больше похож на настоящую функцию. Символ *prod* всего лишь "оборачивает" правило *inner_product*, которое является выражением, производящим значение функции. Но, конечно, *inner_product* является процедурой.

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Наконец, такая версия является максимально приближенной к тому, чем функции являются в математическом смысле. Это пример, написанный на языке Scheme, синтаксис которого позволяет описывать лямбда-выражения. Данное выражение представляет собой описание таблицы соответствий примерно такого вида:

|a|b|prod
|-|-|-
|0|.|0
|.|0|0
|.|.|a<sub>1</sub> * b<sub>1</sub> + prod(остаток(а), остаток(b))

Т.е. для случаев, когда оба аргумента - не пустые множества, значением функции является произведение пары первых объектов обоих аргументов в сумме со значением функции для оставшихся объектов. Такая запись позволяет сразу увидеть значение функции в виде одного выражения, а не последовательности выражений.

Функциональное программирование позволяет описывать функции (и объекты) таким образом, чтобы запись включала в себя все правило для получения значения в одном выражении -- декларативно, что часто приводит к необходимости использовать рекурсивную форму. У такого подхода есть и преимущества (нет необходимости изменять состояние объектов, а значит нет препосылок для "гонки за данными"), и недостатки (аналогично выражениям в лямбда-исчислении большие функции очень тяжело читать и проверять на наличие логических ошибок).
## Функции как объекты
Язык С++ позволяет определять функции двумя способами. Первый способ -- в виде процедур -- заимствован из языка С. Второй способ -- в виде объектов -- появился в С++ позднее. Ниже можно увидеть пример обоих подходов.

    bool func_less_abs(double x, double y) {
        return std::abs(x) < std::abs(y);
    }

    struct less_abs {
        bool operator()(double x, double y) const {
            return std::abs(x) < std::abs(y);
        }
    };
Разница двух определений может быть не очевидна, но она достаточно существенна. В первом случае *func_less_abs* является обычной процедурой, которая возвращает значение выражения в место, из которого она вызывается. Во второй случае *less_abs* является стуктурой, которая может вернуть только копию себя посредством своего конструктора. Структура содержит в себе перегруженный оператор вызова, который позволяет использовать объекты стуктуры в качестве процедур.

    std::sort( a.begin(), a.end(), func_less_abs   );
    std::sort( a.begin(), a.end(), less_abs() );
На примере использования обеих версий можно понять их прнципиальное отличие. Если *func_less_abs* передается в виде указателя на процедуру стратегии сортировки, то *less_abs()* является локальным объектом, который конструируется во время инициализации аргумента-стратегии. 

Из этого есть другое важное следствие. Имя такой функции является типом данных, который подвластен всем правилам системы типов. А это значит, что он может участвовать в выражениях аналогично другим типам данных.

Еще одним интересным следствием является возможность возвращать такие объекты как результаты функций.
### Замыкание
Следует рассмотреть более сложный пример.

    auto f(auto x) {
        auto g = [](auto y) {
            return x + y;
        };
        return g;
    }
Функция *f* возвращает копию объекта g, который определен там же. Тип такого объекта зависит от типа как параметра *x*, так и параметра *y*. Предполагая, что тип *x* и *y* -- int, объект g будет какой-то структурой с перегруженным оператором вызова, который принимает один аргумент типа int. Возникает закономерный вопрос: каким образом структура получает доступ к значению *x* каждый раз, когда необходимо инстанциировать объект такой структуры?

    auto a = f(1);
В этом фрагменте объект *a* представляет собой экземпляр структуры, описанной выше. Из определения структуры известно, что его можно вызвать, передав один аргумент произвольного типа:

    auto i = a(2);
В данном случае можно ожидать, что значением переменной *i* будет результат выражения "1 + 2". Из этого следует два важных свойства:
- функции, определенные таким образом, могут хранить конкретные значения в момент инстанциирования;
- выполнение таких функций можно откладывать, потому что конструирование соответствующего объекта только инициализирует нужные переменные, но не вызывает оператор "()". То есть, в отличие от процедур, функции-объекты в С++ используются в два этапа, что дает новые возможности при написании алгоритмов.

Прием создания функций посредством других функций для откладывания последующего вызова называется "частичной аппликацией". Область памяти, которая хранит такую функцию вместе со всеми значениями, с которыми она была инстанциирована, называется замыканием.
### Класс std::function
Структура, которая создавалась компилятором в примерах выше, определена в шаблоне класса std::function. Экземпляры этого класса могут хранить, копировать или вызывать любую цель, которая обладает свойствами CopyConstructible и Callable, что включает в себя как указатели на процедуры, так и структуры с перегруженным оператором вызова, так и лямбда-выражения.

    std::function<bool(double,double)> f = func_less_abs;
    // или
    std::function<bool(double,double)> f = less_abs();
    // или
    std::function<bool(double,double)> f = 
        [](double x, double y){ return std::abs(x) < std::abs(y); };
А

    std::sort(
        a.begin(),
        a.end(),
        [](double x, double y)
            { return std::abs(x) < std::abs(y); } );
П
## Композиция функций
