# Функциональное программирование
> What I loved so much about OOP [...]is that it’s composable. If there’s one thing you should remember [is that] composability is the most important thing in programming.

Решение любой сложной задачи можно свести к серии простых задач. Тем не менее, это подразумевает, что простые решения легко компонуются в одно сложное решение. ООП как парадигма должно было стать инструментом декомпозиции и рекомпозиции программ как раз с той целью, чтобы одного набора простых решений хватало на создание новых решений любой сложности.

При этом, существует категория задач, которую решить таким образом с помощью ООП сложно. Объекты плохо подходят для многопоточного (конкурентного) программирования, так как они скрывают все детали реализации, в том числе и те, которые нужны для правильной синхронизации потоков. Например, ссылочные значения внутри объектов не должны принадлежать нескольким объектам одновременно, что в контексте многопоточного процесса может вызвать условие для "гонки за данными". Это можно решить с помощью "взаимного исключения" -- запирания данных в момент любого доступа, но это делает объект трудным для использования в совокупности с другими проектами.

Функциональное программирование как парадигма решает те же самые задачи. Но делается это не засчет создания объектов, а с помощью обогащения функций некоторыми свойствами, которые делают сами функции полноценными объектами без необходимости хранить данные, что сразу снимает проблемы, присущие "классическим" объектам.

Это подразумевает, что функция может участвовать во всех выражениях и как конкретное значение, и как интерфейс, и как единица вычисления. Благодаря такому подходу функции можно бесконечно компоновать друг с другом, так как любая функция элементарно адаптируется под любой интерфейс -- т.е. становится возможным решение и тех задач, которые решаются с помощью ООП, и тех задач, которые ООП решить не в состоянии.
## Функции и их свойства
Математический смысл функции можно условно свести к тому, что это некое соответствие между двумя значениями из какого-то множества или множеств. Например, запись *2->4* означает, что есть какое-то правило, по которому число 2 может измениться на число 4, тогда функцией будет стрелка между ними, указывающая на направление изменения. Стрелкам удобно давать различные имена. Тогда запись можно сделать более знакомой: *f(2) = 4*, здесь функция обозначается через символ f, его применение к аргументу "2" производит значение "4".

В программировании принято использовать похожую форму записи. Но не во всех языках функции обладают теми же свойствами, что и математические функции.

    int prod (int a[], int b[]) {
        int c = 0;
        for (unsigned long i = 0; i < n; ++i) c += a[i] * b[i];
        return c;
    }
Выше показан уже знакомый пример произведения двух векторов a и b. Это не является функцией в привычном понимании, так как код перечисляет последовательность выражений, каждое из которых было бы функцией. Это, скорее, процедура, которая имитирует функцию все по тем же причинам -- чтобы ее можно было легко компоновать с другими такими же процедурами.

    auto prod (const auto& a, const auto& b) {
        return std::inner_product(a.begin(), a.end(), b.begin(), 0);
    }
Такой вариант уже больше похож на настоящую функцию. Символ *prod* всего лишь "оборачивает" правило *inner_product*, которое является выражением, производящим значение функции. Но, конечно, *inner_product* является процедурой.

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Наконец, такая версия является максимально приближенной к тому, чем функции являются в математическом смысле. Это пример, написанный на языке Scheme, синтаксис которого позволяет описывать лямбда-выражения. Данное выражение представляет собой описание таблицы соответствий примерно такого вида:

|a|b|prod
|-|-|-
|0|.|0
|.|0|0
|.|.|a<sub>1</sub> * b<sub>1</sub> + prod(остаток(а), остаток(b))

Т.е. для случаев, когда оба аргумента - не пустые множества, значением функции является произведение пары первых объектов обоих аргументов в сумме со значением функции для оставшихся объектов. Такая запись позволяет сразу увидеть значение функции в виде одного выражения, а не последовательности выражений.

Функциональное программирование позволяет описывать функции (и объекты) таким образом, чтобы запись включала в себя все правило для получения значения в одном выражении -- декларативно, что часто приводит к необходимости использовать рекурсивную форму. У такого подхода есть и преимущества (нет необходимости изменять состояние объектов, а значит нет препосылок для "гонки за данными"), и недостатки (аналогично выражениям в лямбда-исчислении большие функции очень тяжело читать и проверять на наличие логических ошибок).
## Функции как объекты
Язык С++ позволяет определять функции двумя способами. Первый способ -- в виде процедур -- заимствован из языка С. Второй способ -- в виде объектов -- появился в С++ позднее. Ниже можно увидеть пример обоих подходов.

    bool func_less_abs(double x, double y) {
        return std::abs(x) < std::abs(y);
    }

    struct less_abs {
        bool operator()(double x, double y) const {
            return std::abs(x) < std::abs(y);
        }
    };
Разница двух определений может быть не очевидна, но она достаточно существенна. В первом случае *func_less_abs* является обычной процедурой, которая возвращает значение выражения в место, из которого она вызывается. Во второй случае *less_abs* является стуктурой, которая может вернуть только копию себя посредством своего конструктора. Структура содержит в себе перегруженный оператор вызова, который позволяет использовать объекты стуктуры в качестве процедур.

    std::sort( a.begin(), a.end(), func_less_abs   );
    std::sort( a.begin(), a.end(), less_abs() );
### Класс std::function
Структура, которая автоматически определяет перегруженный оператор вызова "()", уже встроена в язык С++. Она определена в шаблоне класса *std::function*. Экземпляры этого класса могут хранить, копировать или вызывать любую цель, которая обладает свойствами *CopyConstructible* и *Callable*, что включает в себя как указатели на процедуры, так и структуры с перегруженным оператором вызова, так и лямбда-выражения.

    std::function<bool(double,double)> f = func_less_abs;
    // или
    std::function<bool(double,double)> f = less_abs();
    // или
    std::function<bool(double,double)> f = 
        [](double x, double y){ return std::abs(x) < std::abs(y); };
Пример выше показывает все три способа. Переменную *f* можно инициализировать с помощью указателя *func_less_abs*, с помощью объекта типа *less_abs*, с помощью соответствующего лямбда-выражения -- во всех трех случаях переменная будет хранить ссылку на вызываемую цель.

Например, уже имея знакомый вызов стандартной функции сортировки:
    std::sort(
        a.begin(),
        a.end(),
        [](double x, double y)
            { return std::abs(x) < std::abs(y); } );
его можно было бы заменить на эквивалентный:

    std::sort( a.begin(), a.end(), f );
Сама функция *sort* принимает любую цель, до тех пор, пока цель копируема и вызываема. Ниже приводится сокращенный вариант реализации стандартной функции *sort*.

    template <class RandomAccessIterator, class Compare>
    void sort(RandomAccessIterator first, RandomAccessIterator last, 
              Compare comp)
    {
        if (first == last) return;
        for (RandomAccessIterator i = first + 1; i != last; ++i) {
            if (comp(i, first)) {
                auto val = MOVE(*i);
                MOVE_BACKWARD(first, i, i + 1);
                *first = MOVE(val);
            }
            else unguarded_linear_insert(i, val_comp_iter(comp));
        }
    }
Здесь особенно интересен параметр *comp*. Из тела функции видно, что он используется в качестве двоичного предиката, который определяет если нужно менять местами два элемента рассматриваемой последовательности. Тип этого параметра определен как концепция (шаблонный параметр *Compare*), которую компилятор проверит при инстанциировании шаблона *sort*. Из условия *if* понятно, что данный тип должен быть вызываемой целью, которая принимает два аргумента и возвращает значение типа *bool*. Все три способа вызова *sort* , показанные выше, предоставляют объект, который удовлетворяет этим требованиям.

На примере использования всех версий вызываемых целей можно понять их принципиальное отличие. Если *func_less_abs* передается в виде указателя на процедуру стратегии сортировки, то *less_abs()* является локальным объектом, который конструируется во время инициализации аргумента-стратегии. 

Из этого есть другое важное следствие. Имя такой функции является типом данных, который подвластен всем правилам системы типов. А это значит, что он может участвовать в выражениях аналогично другим типам данных.

Еще одним интересным следствием является возможность возвращать такие объекты как результаты функций.
### Замыкание
Следует рассмотреть более сложный пример.

    auto f(auto x) {
        auto g = [=](auto y) {
            return x + y;
        };
        return g;
    }
Функция *f* возвращает копию объекта g, который определен там же. Тип такого объекта зависит от типа как параметра *x*, так и параметра *y*. Предполагая, что тип *x* и *y* -- int, объект g будет какой-то структурой с перегруженным оператором вызова, который принимает один аргумент типа int. Возникает закономерный вопрос: каким образом структура получает доступ к значению *x* каждый раз, когда необходимо инстанциировать объект такой структуры?

    auto a = f(1); // partial application
В этом фрагменте объект *a* представляет собой экземпляр структуры, описанной выше. Прием создания функций посредством других функций для откладывания последующего вызова называется "частичной аппликацией". Из определения структуры известно, что объект *a* можно вызвать, передав один аргумент произвольного типа:

    auto i = a(2); // full application
В данном случае можно ожидать, что значением переменной *i* будет результат выражения "1 + 2". Область памяти, которая хранит такую функцию вместе со всеми значениями, с которыми она была инстанциирована, называется замыканием. Из этого следует два важных свойства:
- функции, определенные таким образом, могут хранить конкретные значения в момент инстанциирования;
- выполнение таких функций можно откладывать, потому что конструирование соответствующего объекта только инициализирует нужные переменные, но не вызывает оператор "()". То есть, в отличие от процедур, функции-объекты в С++ используются в два этапа, что дает новые возможности при написании алгоритмов.
## Композиция функций
> Fractal composition: you build big things out of small things. That’s the fundamental principle of functional programming.

Функциональная композиция является важным свойством, которое позволяет определять новые функции, используя исключительно существующие функции. Формально это можно записать следующим образом:

    z = g ( y ) = g ( f ( x ) ) = g ∘ f ( x )
Здесь подразумевается то, что конечный результат при определении функции *z* выводится из последовательного приложения (аппликации) функции *f* к аргументу *x* и затем функции *g* к значению функции *f*.

Два важных свойства следует из данного определения:
- запись выражает некую последовательность ("императивный" характер вычисления), оставаясь при этом декларативной по форме;
- промежуточный результат (значение функции *у = f(x)*) исчезает из записи.

Таким образом, функции отвечают сразу двум требованиям: они легко компонуемы и они позволяют использовать инкапсуляцию. Другими словами, они также, как и ООП, позволяют писать программы, в которых детали реализации скрыты, а объекты (функции) взаимодействуют друг с другом только посредством передачи сообщений (аргументов).

Простой пример это иллюстрирует. Предположив, что есть набор легко компонуемых функций, эти функции можно комбинировать, чтобы получить более абстрактный интерфейс. Функции *to_lower* и *split* компонуются в любом порядке. Текст "The quick brown fox jumps over the lazy dog" можно либо сначала разбить на подстроки с последующей заменой всех заглавных букв на прописные, а можно сначала заменить все заглавные буквы на прописные, затем разбив текст на подстроки. Т.е. запись:

    split ( to_lower ("The quick brown fox jumps over the lazy dog") )
    // или
    split ∘ to_lower "The quick brown fox jumps over the lazy dog"
аналогична записи:

    for_each ( split ("The quick brown fox jumps over the lazy dog"), to_lower )
    // или
    to_lower ∘ for_each ∘ split "The quick brown fox jumps over the lazy dog"
Соответственно, оба варианта можно использовать в дальнейшем в качестве сервиса, который принимает строку и возвращает список преобразованных "токенов".

    service :: concatenate ∘ to_lower ∘ for_each ∘ split
    // или
    service :: concatenate ∘ split ∘ to_lower

    transform ( "The quick brown fox jumps over the lazy dog", service )
Сервисы точно так же можно "склеивать" вместе, получая "сценарий". Например,

    use-case :: sort ∘ transform
    // или
    use-case :: validate ∘ transform

    use-case ( "The quick brown fox jumps over the lazy dog" )
Склеивая сценарии можно получить полноценное приложение.

    app :: output ∘ process ∘ input
    process :: count ∘ sort ∘ transform ∘ validate

    app ( "The quick brown fox jumps over the lazy dog" )
Такой подход к написанию систем вынуждает программиста выстраивать сложные под-системы из более простых модулей.
## Композиция типов
Т.к. в функциональном программировании функции являются объектами первого порядка и реализуют интерфейсы, инкапсуляцию и т.п., для создания пользовательских типов данных классы использовать нет необходимости. Типы данных рассматриваются как конечные или бесконечные множества объектов. Например, тип *byte* может быть множеством, объектами которого являются все целые числа от -128 до 127. Тип *boolean* может быть множеством, содержащим всего два объекта: *true* и *false*. Остюда следует, что новые типы данных создаются тоже в виде множеств, включающих в себя другие существующие множества.

Между типами могут существовать отношения. Например, тип *void* представляет собой пустое множество, так как он не содержит никаких объектов. Это значит, что невозможно получить значение такого типа, не существует функции, которая возвращает значение типа *void*. При этом существуют функции, которые не принимают аргументов, но производят значения (например, конструкторы). Так, между пустым множеством и всеми остальными типами есть отношение, *void -> T*.

Напротив, если представить себе множество, которое состоит из единственного объекта (*unit*), существует группа отношений вида *T -> unit*, которая означает, что любая функция возвращающая единственное возможное значение может игнорировать тип аргумента (например, функция, возвращающая константу). Аналогично, есть группа отношений вида *unit -> T*.

Так, создание нового типа данных заключается в определении всех отношений этого типа данных с другими типами. Это значит, что новое множество определяется всеми возможными комбинациями отношений между всеми объектами соответствующего множества. Например, имея два множества: *{0, 1, 2}* и *{true, false}*, кобинация всех возможных элементов между ними выглядит так: *{ {0, true}, {1, true}, {2, true}, {0, false}, {1, false}, {2, false} }* -- декартовое произведение элементов двух множеств. Поэтому такие типы называются "типами-произведениями":
    
    // pair :: A * B
    template <typename A, typename B>
    struct pair {
        A a; B b;
    };
В С++ такой тип можно выразить в виде структуры. Для нового типа, состоящего из пар объектов двух других множеств *A* и *B* отношениями будут: два конструктора приведения (по одному из двух первоначальных множеств), конструктор по умолчанию, конструктор копирования, а также две функции, которые принимают пару и производят или значение типа *A*, или значение типа *B*.

Аналогично можно получить вид множества с помощью комбинации двух произвольных множеств (*A* и *B*) с помощью суммы: имея два множества: *{0, 1, 2}* и *{true, false}*, сумма всех возможных элементов между ними выглядит так: *{ 0, 1, 2, true, false }*. Т.о. "тип-сумма" может производить значения любого из множеств, с помощью которых он конструируется. В С++ такой тип можно выразить через объединение (например, шаблон *std::variant*).

    // variant :: A | B
    template <typename A, typename B>
    struct variant {
        union { A a; B b; };
        tag t;
    };
Стоит обратить внимание, что такое объединение должно быть совмещено с отношением, которое определяет тип текущего значения (либо всегда *А*, либо всегда *B*). 

Структуры типов, которые позволяют комбинировать существующие типы согласно этим двум правилам и всем сопутствующим свойствам, называются "алгебраическими". Можно было заметить, что произведение типов похоже на логическую коньюнкцию, а сумма типов -- на дизьюнкцию. По этой причине в некоторых источниках можно встретить другие названия: AND-тип и OR-тип. И действительно, если тип данных определен как *(int * bool)*, в объекте такого типа есть и значение типа int, и значение типа bool. Наоборот, если тип данных определен как *(int | bool)*, в объекте такого типа будет или значение типа *int*, или значение типа *bool*, но не оба сразу.
## Функциональная полнота
Ниже приводится пример простой функции, которая принимает целое число и возвращает целое число.

    int divide_twelve(int divisor) {
        switch (divisor) {
            case 3: return 4;
            case 2: return 6;
            case 1: return 12;
            case 0: return ???; // что возвращать в этом случае?
        }
    }
Функция *divide_twelve* должна возвращать результат деления числа "12" на какое-то другое целое число. Не все делители являются корректными, и выше показан пример одного такого делителя, "0". Для целых чисел результат деления на 0 не определен. Тем не менее, функция гарантирует, что во всех случаях возврата она производит значение типа *int*. Остается вопрос, что возвращать в случае, когда делитель равен нулю.

Первые несколько вариаций, которые можно себе представить, придется отбросить:
- кидать исключение;
- вернуть код ошибки;
- вернуть отрицательное число;
- вернуть "0".

Кидать исключение для таких функций не следует, т.к. исключение не является одним из элементов множества *int* (хотя, в С++ всегда можно кинуть целое число как исключение, но это так или иначе нарушит естественный ход программы). Код ошибки возвращать не следует, потому что он входит во множество *int* и никак не отличим от реального результата деления. Отрицательное число можно вернуть, так как для положительного делителя оно явно не может быть правильным результатом, но для отрицательного делителя оно перестает нести в себе дополнительный смысл.

Более простым решением будет ограничение множества всех входящих данных. Например, множество натуральных чисел не содердит отрицательных или "0":

    int divide_twelve(natural divisor);
В таком случае случаи с некорректным делителем не придется обрабатывать отдельно. Чуть более интересным решением будет расширение множества всех возвращаемых данных.

    std::optional<int> divide_twelve(int divisor) {
        switch (divisor) {
            case 3: return 4;
            case 2: return 6;
            case 1: return 12;
            case 0: return std::nullopt;
        }
    }
Здесь используется специальный тип, который может быть или целым числом, или пустым множеством. Пустое множество явно проверяемо и не несет никаких дополнительных смыслов кроме отсутствия правильного результата. В обоих случаях достигается важное свойство функций. В двух последних примерах функция становится "полной", в том смысле, что для всех входящих значений она обязательно производит корректное возвращаемое значение.
## Параметризация
В качестве очередного примера ниже приводится функция, которая выводит в терминал числа от 1 до 10. 

    void print() {
        for (const auto&& i : std::views::iota(1, 10))
            std::printf(“%i”, i);
    }
Недостатки такой функции уже должны бросаться в глаза. Она ничего не возвращает, при этом изменяет значение локальной переменной в цикле и не может выводить другие последовательности. Все эти недостатки можно исправить с помощью соответствующих параметров.

    void print(const auto& iterable) {
        for (const auto&& i : iterable)
            std::printf(“%i”, i);
    }
Теперь функция выводит любой подходящий диапазон (итерируемый объект) значений, при условии, что все значения будут целыми числами. Это ограничение тоже можно снять, сделав поведение параметром аналогично диапазону значений.

    void for_each(auto callable, const auto& iterable) {
        for (const auto&& i : iterable)
            callable(i);
    }
Функция *callable* теперь отвечает за правильность обработки элементов диапазона *iterable*, т.о. ответственность за совместимость двух параметров теперь лежит на вызывающей стороне. Осталось изменить тип возвращаемого значения. Сперва трудно представить себе, что следует возвращать в такой функции, но если предположить, что она должна быть легко компонуема с другими похожими функциями, нужно подумать о сценариях, в которых она чаще всего будет использоваться.

    auto& for_each(auto callable, const auto& iterable) {
        for (const auto&& i : iterable)
            callable(i);
        return iterable;
    }
Польза параметризации объектов, которые требуются функции для работы, лежит не только в том, что они легче компонуются с другими функциями, но и в том, что функции становятся обобщенными, подходящими под разные случаи. Вот другой пример:

    int prod(int n) {
        int product = 1;
        for (int i = 1; i <= n; i++) product *= i;
        return product;
    }

    int add(int n) {
        int sum = 0;
        for (int i = 1; i <= n; i++) sum += i;
        return sum;
    }
В этих двух функциях большая часть кода совпадает. Если это заметить, можно прийти к их обобщенной версии. Например, отличается стартовое значение переменных-аккумуляторов, что легко поддается параметризации. Другое отличие -- арифметическая операция (в первом случае - сумма, во втором - произведение). Как и в других примерах, это поведение можно параметризовать, так как в обоих случаях -- это бинарная операция.

    auto fold(auto action, const auto& init, const auto& iterable) {
        auto total = init;
        for (const auto&& item : iterable) total = action(total, item);
        return total;
    }
Новая функция подходит теперь для обоих случаев, разница в поведении определяется передаваемыми параметрами.

    auto i = fold( std::multiplies<int>{}, 1, std::views::iota(1, 10) );
    auto i = fold( std::plus<int>{}, 0, std::views::iota(1, 10) );
Библиотека *numeric* в языке С++ содержит набор похожих функций, которые подходят для большинства сценариев, например:
    
    std::ranges::fold_left_first( v.begin(), v.end(), std::plus{} );
Функция *fold_left_first* проходит по указанному диапазону слева направо, аккумулируя возвращаемое значение в переменной с помощью заданного оператора.
## Функции как интерфейсы
Интерфейсы, как правило, ассоциируются с классами и, реже, с наследованием. Особенно сильно это выражено в языке С++, где до введения в язык шаблонов интерфейсы было принято определять как абстрактные базовые классы в иерархии наследования. Из-за этого нелегко себе представить функции в роли интерфейсов. Ниже приводится простой пример для иллюстрации.

    struct abstract_less_abs {
        virtual bool less_abs(double x, double y) const = 0;
    };

    bool func_less_abs(double x, double y);
В данном случае есть абстрактный класс-интерфейс *abstract_less_abs* и функция *func_less_abs*. Так как интерфейс требует, чтобы реализация принимала два числа и возвращала результат типа *bool*, любая реализация из дочернего класса обязана иметь определение, которое с этим согласуется. Интересно то, что для интерфейса, который состоит из небольшого количества функций, это же условие будет выполняться и без класса-обертки: сами функции, его реализующие, требуют, чтобы аргументы соответствовали каким-то правилам; сами функции гарантируют, что вернут значение какого-то типа. Т.е. функции уже являются интерфейсами, такими интерфейсами, которые содержат только одну функцию.

Ценность таких интерфейсов может показаться сомнительной. Ее можно увидеть если вспомнить некоторые из принципов SOLID, которые дают рекомендации по написанию интерфейсов. Например, принцип единственной ответственности утверждает, что у отдельно взятого модуля должна быть только "одна причина для изменения". То есть, произвольный интерфейс не должен содержать методы или функции, которые не служат одной и той же группе задач. С другой стороны, принцип разделения интерфейсов рекомендует создавать разные интерфейсы под разные нужды клиентов, чтобы изменение требований одного клиента не затрагивало параллельно созданные интерфейсы.

Из этого можно сделать неожиданный вывод: если оба этих принципа рассматривать в пограничных ситуациях, выходит, что лучшие интерфейсы -- это такие, которые содержат только по одной функции, как в примере выше. Из этого и выходит правило, что каждая функция -- это интерфейс.

    class strategy {
        strategy(abstract_less_abs& st);
        int calculate(int x) { return mst.less_abs(x); }
    };
Пример выше определяет класс, который использует интерфейс *abstract_less_abs*. Как в этой ситуации заменить класс на простую функцию, которая будет выполнять роль интерфейса?
