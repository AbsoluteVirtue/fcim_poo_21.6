# Функциональное программирование
> What I loved so much about OOP [...]is that it’s composable. If there’s one thing you should remember [is that] composability is the most important thing in programming.

Решение любой сложной задачи можно свести к серии простых задач. Тем не менее, это подразумевает, что простые решения легко компонуются в одно сложное решение. ООП как парадигма должно было стать инструментом декомпозиции и рекомпозиции программ как раз с той целью, чтобы одного набора простых решений хватало на создание новых решений любой сложности.

При этом, существует категория задач, которую решить таким образом с помощью ООП сложно. Объекты плохо подходят для многопоточного (конкурентного) программирования, так как они скрывают все детали реализации, в том числе и те, которые нужны для правильной синхронизации потоков. Например, ссылочные значения внутри объектов не должны принадлежать нескольким объектам одновременно, что в контексте многопоточного процесса может вызвать условие для "гонки за данными". Это можно решить с помощью "взаимного исключения" -- запирания данных в момент любого доступа, но это делает объект трудным для использования в совокупности с другими проектами.

Функциональное программирование как парадигма решает те же самые задачи. Но делается это не засчет создания объектов, а с помощью обогащения функций некоторыми свойствами, которые делают сами функции полноценными объектами без необходимости хранить данные, что сразу снимает проблемы, присущие "классическим" объектам.

Это подразумевает, что функция может участвовать во всех выражениях и как конкретное значение, и как интерфейс, и как единица вычисления. Благодаря такому подходу функции можно бесконечно компоновать друг с другом, так как любая функция элементарно адаптируется под любой интерфейс -- т.е. становится возможным решение и тех задач, которые решаются с помощью ООП, и тех задач, которые ООП решить не в состоянии.
## Функции и их свойства
Математический смысл функции можно условно свести к тому, что это некое соответствие между двумя значениями из какого-то множества или множеств. Например, запись *2->4* означает, что есть какое-то правило, по которому число 2 может измениться на число 4, тогда функцией будет стрелка между ними, указывающая на направление изменения. Стрелкам удобно давать различные имена. Тогда запись можно сделать более знакомой: *f(2) = 4*, здесь функция обозначается через символ f, его применение к аргументу "2" производит значение "4".

В программировании принято использовать похожую форму записи. Но не во всех языках функции обладают теми же свойствами, что и математические функции.

    int prod (int a[], int b[]) {
        int c = 0;
        for (unsigned long i = 0; i < n; ++i) c += a[i] * b[i];
        return c;
    }
Выше показан уже знакомый пример произведения двух векторов a и b. Это не является функцией в привычном понимании, так как код перечисляет последовательность выражений, каждое из которых было бы функцией. Это, скорее, процедура, которая имитирует функцию все по тем же причинам -- чтобы ее можно было легко компоновать с другими такими же процедурами.

    auto prod (const auto& a, const auto& b) {
        return std::inner_product(a.begin(), a.end(), b.begin(), 0);
    }
Такой вариант уже больше похож на настоящую функцию. Символ *prod* всего лишь "оборачивает" правило *inner_product*, которое является выражением, производящим значение функции. Но, конечно, *inner_product* является процедурой.

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Наконец, такая версия является максимально приближенной к тому, чем функции являются в математическом смысле. Это пример, написанный на языке Scheme, синтаксис которого позволяет описывать лямбда-выражения. Данное выражение представляет собой описание таблицы соответствий примерно такого вида:

|a|b|prod
|-|-|-
|0|.|0
|.|0|0
|.|.|a<sub>1</sub> * b<sub>1</sub> + prod(остаток(а), остаток(b))

Т.е. для случаев, когда оба аргумента - не пустые множества, значением функции является произведение пары первых объектов обоих аргументов в сумме со значением функции для оставшихся объектов. Такая запись позволяет сразу увидеть значение функции в виде одного выражения, а не последовательности выражений.

Функциональное программирование позволяет описывать функции (и объекты) таким образом, чтобы запись включала в себя все правило для получения значения в одном выражении -- декларативно, что часто приводит к необходимости использовать рекурсивную форму. У такого подхода есть и преимущества (нет необходимости изменять состояние объектов, а значит нет препосылок для "гонки за данными"), и недостатки (аналогично выражениям в лямбда-исчислении большие функции очень тяжело читать и проверять на наличие логических ошибок).
## Функции как объекты
Язык С++ позволяет определять функции двумя способами. Первый способ -- в виде процедур -- заимствован из языка С. Второй способ -- в виде объектов -- появился в С++ позднее. Ниже можно увидеть пример обоих подходов.

    bool func_less_abs(double x, double y) {
        return std::abs(x) < std::abs(y);
    }

    struct less_abs {
        bool operator()(double x, double y) const {
            return std::abs(x) < std::abs(y);
        }
    };
Разница двух определений может быть не очевидна, но она достаточно существенна. В первом случае *func_less_abs* является обычной процедурой, которая возвращает значение выражения в место, из которого она вызывается. Во второй случае *less_abs* является стуктурой, которая может вернуть только копию себя посредством своего конструктора. Структура содержит в себе перегруженный оператор вызова, который позволяет использовать объекты стуктуры в качестве процедур.

    std::sort( a.begin(), a.end(), func_less_abs   );
    std::sort( a.begin(), a.end(), less_abs() );
### Класс std::function
Структура, которая автоматически определяет перегруженный оператор вызова "()", уже встроена в язык С++. Она определена в шаблоне класса *std::function*. Экземпляры этого класса могут хранить, копировать или вызывать любую цель, которая обладает свойствами *CopyConstructible* и *Callable*, что включает в себя как указатели на процедуры, так и структуры с перегруженным оператором вызова, так и лямбда-выражения.

    std::function<bool(double,double)> f = func_less_abs;
    // или
    std::function<bool(double,double)> f = less_abs();
    // или
    std::function<bool(double,double)> f = 
        [](double x, double y){ return std::abs(x) < std::abs(y); };
Пример выше показывает все три способа. Переменную *f* можно инициализировать с помощью указателя *func_less_abs*, с помощью объекта типа *less_abs*, с помощью соответствующего лямбда-выражения -- во всех трех случаях переменная будет хранить ссылку на вызываемую цель.

Например, уже имея знакомый вызов стандартной функции сортировки:
    std::sort(
        a.begin(),
        a.end(),
        [](double x, double y)
            { return std::abs(x) < std::abs(y); } );
его можно было бы заменить на эквивалентный:

    std::sort( a.begin(), a.end(), f );
Сама функция *sort* принимает любую цель, до тех пор, пока цель копируема и вызываема. Ниже приводится сокращенный вариант реализации стандартной функции *sort*.

    template <class RandomAccessIterator, class Compare>
    void sort(RandomAccessIterator first, RandomAccessIterator last, 
              Compare comp)
    {
        if (first == last) return;
        for (RandomAccessIterator i = first + 1; i != last; ++i) {
            if (comp(i, first)) {
                auto val = MOVE(*i);
                MOVE_BACKWARD(first, i, i + 1);
                *first = MOVE(val);
            }
            else unguarded_linear_insert(i, val_comp_iter(comp));
        }
    }
Здесь особенно интересен параметр *comp*. Из тела функции видно, что он используется в качестве двоичного предиката, который определяет если нужно менять местами два элемента рассматриваемой последовательности. Тип этого параметра определен как концепция (шаблонный параметр *Compare*), которую компилятор проверит при инстанциировании шаблона *sort*. Из условия *if* понятно, что данный тип должен быть вызываемой целью, которая принимает два аргумента и возвращает значение типа *bool*. Все три способа вызова *sort* , показанные выше, предоставляют объект, который удовлетворяет этим требованиям.

На примере использования всех версий вызываемых целей можно понять их принципиальное отличие. Если *func_less_abs* передается в виде указателя на процедуру стратегии сортировки, то *less_abs()* является локальным объектом, который конструируется во время инициализации аргумента-стратегии. 

Из этого есть другое важное следствие. Имя такой функции является типом данных, который подвластен всем правилам системы типов. А это значит, что он может участвовать в выражениях аналогично другим типам данных.

Еще одним интересным следствием является возможность возвращать такие объекты как результаты функций.
### Замыкание
Следует рассмотреть более сложный пример.

    auto f(auto x) {
        auto g = [=](auto y) {
            return x + y;
        };
        return g;
    }
Функция *f* возвращает копию объекта g, который определен там же. Тип такого объекта зависит от типа как параметра *x*, так и параметра *y*. Предполагая, что тип *x* и *y* -- int, объект g будет какой-то структурой с перегруженным оператором вызова, который принимает один аргумент типа int. Возникает закономерный вопрос: каким образом структура получает доступ к значению *x* каждый раз, когда необходимо инстанциировать объект такой структуры?

    auto a = f(1); // partial application
В этом фрагменте объект *a* представляет собой экземпляр структуры, описанной выше. Прием создания функций посредством других функций для откладывания последующего вызова называется "частичной аппликацией". Из определения структуры известно, что объект *a* можно вызвать, передав один аргумент произвольного типа:

    auto i = a(2); // full application
В данном случае можно ожидать, что значением переменной *i* будет результат выражения "1 + 2". Область памяти, которая хранит такую функцию вместе со всеми значениями, с которыми она была инстанциирована, называется замыканием. Из этого следует два важных свойства:
- функции, определенные таким образом, могут хранить конкретные значения в момент инстанциирования;
- выполнение таких функций можно откладывать, потому что конструирование соответствующего объекта только инициализирует нужные переменные, но не вызывает оператор "()". То есть, в отличие от процедур, функции-объекты в С++ используются в два этапа, что дает новые возможности при написании алгоритмов.
## Композиция функций
> Fractal composition: you build big things out of small things. That’s the fundamental principle of functional programming.

Функциональная композиция является важным свойством, которое позволяет определять новые функции, используя исключительно существующие функции. Формально это можно записать следующим образом:

    z = g ( y ) = g ( f ( x ) ) = g ∘ f ( x )
Здесь подразумевается то, что конечный результат при определении функции *z* выводится из последовательного приложения (аппликации) функции *f* к аргументу *x* и затем функции *g* к значению функции *f*.

Два важных свойства следует из данного определения:
- запись выражает некую последовательность ("императивный" характер вычисления), оставаясь при этом декларативной по форме;
- промежуточный результат (значение функции *у = f(x)*) исчезает из записи.

Таким образом, функции отвечают сразу двум требованиям: они легко компонуемы и они позволяют использовать инкапсуляцию. Другими словами, они также, как и ООП, позволяют писать программы, в которых детали реализации скрыты, а объекты (функции) взаимодействуют друг с другом только посредством передачи сообщений (аргументов).

Простой пример это иллюстрирует. Предположив, что есть набор легко компонуемых функций, эти функции можно комбинировать, чтобы получить более абстрактный интерфейс. Функции *to_lower* и *split* компонуются в любом порядке. Текст "The quick brown fox jumps over the lazy dog" можно либо сначала разбить на подстроки с последующей заменой всех заглавных букв на прописные, а можно сначала заменить все заглавные буквы на прописные, затем разбив текст на подстроки. Т.е. запись:

    split ( to_lower ("The quick brown fox jumps over the lazy dog") )
    // или
    split ∘ to_lower "The quick brown fox jumps over the lazy dog"
аналогична записи:

    for_each ( split ("The quick brown fox jumps over the lazy dog"), to_lower )
    // или
    to_lower ∘ for_each ∘ split "The quick brown fox jumps over the lazy dog"
Соответственно, оба варианта можно использовать в дальнейшем в качестве сервиса, который принимает строку и возвращает список преобразованных "токенов".

    service :: concatenate ∘ to_lower ∘ for_each ∘ split
    // или
    service :: concatenate ∘ split ∘ to_lower

    transform ( "The quick brown fox jumps over the lazy dog", service )
Сервисы точно так же можно "склеивать" вместе, получая "сценарий". Например,

    use-case :: sort ∘ transform
    // или
    use-case :: validate ∘ transform

    use-case ( "The quick brown fox jumps over the lazy dog" )
Склеивая сценарии можно получить полноценное приложение.

    app :: output ∘ process ∘ input
    process :: count ∘ sort ∘ transform ∘ validate

    app ( "The quick brown fox jumps over the lazy dog" )
Такой подход к написанию систем вынуждает программиста выстраивать сложные под-системы из более простых модулей.
## Композиция типов
Т.к. в функциональном программировании функции являются объектами первого порядка и реализуют интерфейсы, инкапсуляцию и т.п., для создания пользовательских типов данных классы использовать нет необходимости. Типы данных рассматриваются как конечные или бесконечные множества объектов. Например, тип *byte* может быть множеством, объектами которого являются все целые числа от -128 до 127. Тип *boolean* может быть множеством, содержащим всего два объекта: *true* и *false*. Остюда следует, что новые типы данных создаются тоже в виде множеств, включающих в себя другие существующие множества.

Между типами могут существовать отношения. Например, тип *void* представляет собой пустое множество, так как он не содержит никаких объектов. Это значит, что невозможно получить значение такого типа, не существует функции, которая возвращает значение типа *void*. При этом существуют функции, которые не принимают аргументов, но производят значения (например, конструкторы). Так, между пустым множеством и всеми остальными типами есть отношение, *void -> T*.

Напротив, если представить себе множество, которое состоит из единственного объекта (*unit*), существует группа отношений вида *T -> unit*, которая означает, что любая функция возвращающая единственное возможное значение может игнорировать тип аргумента (например, функция, возвращающая константу). Аналогично, есть группа отношений вида *unit -> T*.

Так, создание нового типа данных заключается в определении всех отношений этого типа данных с другими типами. Это значит, что новое множество определяется всеми возможными комбинациями отношений между всеми объектами соответствующего множества. Например, имея два множества: *{0, 1, 2}* и *{true, false}*, кобинация всех возможных элементов между ними выглядит так: *{ {0, true}, {1, true}, {2, true}, {0, false}, {1, false}, {2, false} }* -- декартовое произведение элементов двух множеств. Поэтому такие типы называются "типами-произведениями":
    
    // pair :: A * B
    template <typename A, typename B>
    struct pair {
        A a; B b;
    };
В С++ такой тип можно выразить в виде структуры. Для нового типа, состоящего из пар объектов двух других множеств *A* и *B* отношениями будут: два конструктора приведения (по одному из двух первоначальных множеств), конструктор по умолчанию, конструктор копирования, а также две функции, которые принимают пару и производят или значение типа *A*, или значение типа *B*.

Аналогично можно получить вид множества с помощью комбинации двух произвольных множеств (*A* и *B*) с помощью суммы: имея два множества: *{0, 1, 2}* и *{true, false}*, сумма всех возможных элементов между ними выглядит так: *{ 0, 1, 2, true, false }*. Т.о. "тип-сумма" может производить значения любого из множеств, с помощью которых он конструируется. В С++ такой тип можно выразить через кортеж (например, шаблон *std::variant*).

    // tuple :: A | B
    template <typename A, typename B>
    struct tuple {
        union { A a; B b; };
        tag t;
    };
Стоит обратить внимание, что такой кортеж должен содержать еще одно отношение, которое определяет тип значения, которое можно сконструировать (либо всегда *А*, либо всегда *B*). Структуры типов, которые позволяют комбинировать существующие типы согласно этим двум правилам и всем сопутствующим свойствам, называются "алгебраическими".

Можно было заметить, что произведение типов похоже на логическую коньюнкцию, а сумма типов -- на дизьюнкцию. По этой причине в некоторых источниках можно встретить другие названия: AND-тип и OR-тип. И действительно, если тип данных определен как *(int * bool)*, в объекте такого типа есть и значение типа int, и значение типа bool. Наоборот, если тип данных определен как *(int | bool)*, в объекте такого типа будет или значение типа *int*, или значение типа *bool*, но не оба сразу.
## Функциональная полнота
