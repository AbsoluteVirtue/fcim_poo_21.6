# Лабораторная работа 7
## Обработка ошибок, исключения
### Задание
Необходимо написать код, который иллюстрирует использование исключений для обработки исключительных ситуаций. Используя ключевые слова throw, try и catch, нужно обработать несколько разных ислючений. Также нужно показать эффект исключений разных типов в рамках одного блока try-catch и восстановление программы после обработки исключения.

Далее нужно создать свой тип исключений -- так, чтобы его обработка гармонично сочеталась с обработкой встроенных типов ислючений.

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
## Контрактное проектирование, концепции
### Дополнительное задание
Используя код из предыдущей лабораторной, необходимо дополнить методы своего класса(или классов) проверками во время компиляции для соблюдения контрактов и отсутствия неопределенности в поведении программы. Например, контейнеры, которые предоставляют метод push_back подвержены неопределенному поведению в случаях, когда этот метод вызывается на пустой контейнер. 
> If empty() is true, the behavior is undefined.

Другими словами, поведение метода невозможно предугадать, так как стандарт языка по этому поводу ничего не может сказать (более того, компилятор имеет право предположить, что эта ситуация никогда не произойдет). Реализация метода в таком случае может быть любой.

    void pop_back_hardened(const auto &data) {
        if constexpr (
            requires { 
                { data.empty() };
                { data.pop_back() };
            }
        ) if (data.empty()) data.pop_back();
    }
-- фрагмент кода выше использует ключевое слово requires, которое позволяет определить некоторое ограничение на заданный тип или объект. В данном примере ограничивается возможность вызова pop_back на котнейнер data, если у него нет методов pop_back и empty.
> https://en.cppreference.com/w/cpp/language/constraints.html

Проверкам с использованием ключевого слова requires можно задавать имена, такие именованные проверки называются концепциями и определяются с помощью ключевого слова concept.

    template <class T> 
    concept poppable = requires (T c) {
        { c.empty() } -> std::same_as<bool>;
        { c.pop_back() } -> std::same_as<void>;
    };

    void pop_back_hardened(poppable auto &data) {
        if (data.empty()) data.pop_back();
    }
Ключевое слово concept расширяет шаблоны типов, позволяя накладывать ограничения на шаблонные параметры. В новом примере блок requires определен как концепция и может быть включен в функцию на правах шаблонного параметра. Дополнительно, можно проверять. Концепции используют библиотеку type_traits.
> https://en.cppreference.com/w/cpp/meta.html

Перечень встроенных в стандартную библиотеку концепций можно посмотреть по ссылке: 
> https://en.cppreference.com/w/cpp/concepts.html

Другой способ проверять выполнение предусловия или постусловия при вызове методов -- использовать ключевые слова pre, post:

    void pop_back_hardened(int dividend, int divisor) pre(!data.empty()) {
        data.pop_back();
    }
Данный способ пока что не поддерживается современными компиляторами.
> https://en.cppreference.com/w/cpp/language/contracts.html
