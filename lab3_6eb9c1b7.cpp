/*
Лабораторная работа 3 - Перегрузка операторов

Используя предыдущую лабораторную с помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Для реализации простейших операций над объектами класса необходимо добавить в класс все нужные операторы. Ниже показаны примеры прототипов, из которых складывается интерфейс абстрактного типа данных.

Оператор присваивания копированием operator= принимает один аргумент – константную ссылку (&) на объект заданного класса. Оператор выполняет замену всех элементов коллекции объекта слева  от оператора на копии элементов коллекции объекта справа от оператора. Данный оператор семантически схож с конструктором копирования, поэтому в некоторых ситуациях они могут быть взаимозаменяемы. Оператор присваивания возвращает ссылку на измененный объект. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.

Оператор присваивания переносом operator= принимает один аргумент – rvalue-ссылку (&&) на объект заданного класса. Оператор выполняет замену всех элементов коллекции объекта слева от оператора на элементы коллекции объекта справа от оператора. Объект справа очищается. Данный оператор семантически схож с конструктором переноса, поэтому в некоторых ситуациях они могут быть взаимозаменяемы. Оператор присваивания возвращает ссылку на измененный объект. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.

Оператор сравнения operator== принимает два аргумента: константную ссылку (&) на объект заданного класса слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их коллекции. Коллекции равны, если они содержат равное количество элементов, а также – если значение каждого элемента одной коллекции равно элементу другой коллекции на том же месте. Данный оператор повторяет логику метода is_equal. Аналогично реализуется обратный оператор сравнения operator!=. 

Оператор сравнения operator< принимает два аргумента: константную ссылку (&) на объект заданного класса слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргумент слева от оператора строго меньше аргумента справа от оператора, и “ложь” в противном случае. Сравнение производится лексикографически. Аналогично реализуются операторы operator<=, operator>, operator>=.

Оператор ввода из потока данных operator>> принимает два аргумента: ссылку (&) на поток данных слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из потока данных слева в объект справа от оператора. Оператор возвращает ссылку на измененный поток ввода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат. 

Оператор вывода в поток данных operator<< принимает два аргумента: ссылку (&) на поток данных слева от оператора и ссылку (&) на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из объекта справа в поток данных слева от оператора. Оператор возвращает ссылку на измененный поток вывода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.

Оператор доступа по индексу operator[] принимает единственный аргумент – беззнаковое целое число, обозначающее позицию элемента в массиве. возвращает ссылку на элемент коллекции, находящийся по заданному индексу. В отличие от метода at не проверяет индекс на несоответствие размеру коллекции. В случаях, когда pos >= size(), поведение метода не определено. Асимптотичность метода постоянная – O(1).

Метод count принимает один аргумент – целое число – и возвращает количество элементов коллекции, значение которых равно значению аргумента.

Метод contains принимает один аргумент – целое число – и возвращает булевое значение: “истинность”, если значение аргумента равно значению хотя бы одного элемента коллекции, и “ложь” в противном случае.
*/

#include <cassert>
#include <iostream>
#include <sstream>
#include <utility>
// остальные необходимые библиотеки здесь

class /* название варианта здесь */ {
private:
    // необходимые поля здесь
public:
    // методы из предыдущей лабораторной работы здесь

    // рекомендуемые прототипы функций:
    /* название варианта здесь */ &operator=(const /* название варианта здесь */&);
    friend bool operator==(const /* название варианта здесь */&, const /* название варианта здесь */&);
    friend bool operator!=(const /* название варианта здесь */&, const /* название варианта здесь */&);
    friend bool operator<(const /* название варианта здесь */&, const /* название варианта здесь */&);
    friend bool operator>(const /* название варианта здесь */&, const /* название варианта здесь */&);
    friend bool operator<=(const /* название варианта здесь */&, const /* название варианта здесь */&);
    friend bool operator>=(const /* название варианта здесь */&, const /* название варианта здесь */&);
    int &operator[](size_t);
    friend std::ostream &operator<<(std::ostream&, const /* название варианта здесь */&);
    friend std::istream &operator>>(std::istream&, /* название варианта здесь */&);
    bool contains(int);
    size_t count(int);
};

// код для проверки правильности выполнения задания:
using container = /* название варианта здесь */;

int main() {
    std::stringstream ss{"1 3 5 7 9"};
    container a(5);
    ss >> a;
    assert(5 == a.size());
    assert(1 == a[0]);
    assert(9 == a[4]);
    std::cout << a;
    container b{a};
    assert(a == b);
    assert(3 == b[1]);
    assert(7 == b[3]);
    b[4] = 0;
    assert(0 == b[4]);
    assert(!b.contains(9));
    assert(b < a);
    assert(a > b);
    std::cout << b;
    container c;
    assert(0 == c.size());
    c = b;
    assert(b == c);
    c[1] = c[2] = 7;
    assert(7 == c[1]);
    assert(7 == c[2]);
    assert(3 == c.count(7));
    std::cout << c;
    b = container({1, 3, 5, 7, 9});
    assert(5 == b.size());
    assert(1 == b[0]);
    assert(9 == b[4]);
    c = std::move(b);
    assert(9 == c[4]);
    assert(c.contains(7));
    assert(b.empty());
    assert(b < c);
}
