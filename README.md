# FCIM.POO21.6 -- Объектно-ориентированное программирование, вступительный курс

## Лекция 1

Прежде чем обсуждать историю и основные концепции, стоящие за понятием "объектно-ориентированный", необходимо вспомнить базовые принципы структурного или "дата-ориентированного" программирования. Язык С++ изначально разрабатывался как надмножество языка С с полной прямой совместимостью, в следствие чего многие нюансы работы с языком С плавно перешли в С++.

В качестве примера можно рассмотреть устройство массивов в языке С. Вспомним, что массив представляет собой переменную, содержащую адрес того байта, с которого начинается секция, выделенная под весь массив. В этом смысле массивы являются образом виртуальной памяти процесса, так как они полностью повторяют ее структуру: получить доступ к любому из байтов можно по известному адресу, который играет роль индекса. Используя арифметику указателей можно перейти на любой другой адрес, инкременировав или декрементировав указатель.

Отсюда следует, что массив не является типом данных в привычном понимании. Тип данных - это, в перую очередь, метод присвоения какого-то значения байтам в памяти компьютера (данным). Такое значение выражается в операциях, которые определены для этих данных, и свойствам, которые присущи этим данным. Массив не имеет свойств, присущих только ему, и операций, определенных только для него. Вместо этого массив подвержен операциям, определенным для указателей, и обладает свойствами указателей.

Так, для доступа к произвольному элементу массива достаточно обратиться к его указателю и прибавить нужное количество "скачков" от него в нужную сторону, после чего полученный таким образом адрес необходимо разыменовать.

    int a[10];
    int *p_in_a = a + 2; 
    int x_of_a = *p_in_a;

    // или 

    int x_of_a = *(a + 2); 

    // аналогично укороченной форме записи

    int x_of_a = a[2];

Единственной операцией здесь, которая ассоциируется непосредственно с массивами, является инициализация массива как сплошного блока памяти, равного 10 значениям типа int. Таким образом мы видим, что массивы в С -- это ссылки на уже существующие участки памяти, которые ассоциируются с конкретным именем при объявлении массива в программе. Статический массив полезен тем, что его размер известен компилятору (так как мы указываем его явно при инициализации). В случае с динамическим массивом эта информация компилятору не доступна, что делает массив аналогичным указателю соответствующего типа.

int *a = (int *)malloc(sizeof(int) * 10);

И даже в случае со статическими массивами, при передаче их в функцию в качестве аргументов они "разлагаются" до обычных указателей, теряя информацию о своем первоначальном размере.

    unsigned int count(int a[10])
    {
        return sizeof(a) / sizeof(int);
        // вернет 2, так как размер переменной a будет равен размеру указателя (8 байтов)
        // а не размеру статического массива (40 байтов), т.о. 8/4 = 2.
    }

Такое поведение является следствием большого "возраста" языка С, который создавался во времена компьютеров, обладавших очень небольшим запасом оперативной памяти. Для экономии драгоценных байтов разработчики пошли на хитрость, сделав все аргументы-массивы такого же размера как аргументы-указатели. И это поведение сохраняется во всех компиляторах С++.

Теперь рассмотрим пример реализации массива в С++.

    #include <array>

    unsigned int count(std::array<int, 10> &a)
    {
        return sizeof(a) / sizeof(int);
    }

    std::array<int, 10> a;
    unsigned int len_of_a = count(a);

Здесь размер массива определится правильно -- 10 элементов. Это возможно благодаря двум свойствам. Первое свойство перекочевало из языка С. Оно относится к структурам данных (struct). Конкретней, состоит в том, что структуры передаются в функции как полноценные копии значений всех полей. Благодаря этому статические массивы, заключенные в структуру, копируются полностью, что позволяет определить их размер из структуры.

    struct c_struct
    {
        int v[10];
    };

    unsigned int count(c_struct a)
    {
        return sizeof(a.v) / sizeof(int);
    }

    c_struct a;
    unsigned int len_of_a = count(a);

Второе свойство заключается в том, что структуры позволяют создавать новые типы данных, которым можно задать определенное поведение с помощью методов, которые были добавлены в С++. Одним из таких инструментов является возможность определять функции внутри структур и скрывать данные структуры от внешнего доступа.

    struct cpp_struct
    {
        unsigned int count()
        {
            return sizeof(v) / sizeof(int);
        }
    private:
        int v[10];
    };

unsigned int len_of_a = cpp_struct().count();

Здесь важно отметить тот факт, что функция вызывается через оператор-точку, как любое другое поле структуры. Такие функции называются "методами структуры" и имеют ряд полезных свойств, главным из которых является полный доступ к другим полям родительской структуры. 

Другой важный момент -- ключевое слово private, добавленное в С++ для запрета доступа к полям структуры извне. Это логическое следует из идеи "типа данных". Если мы создаем свой тип, он должен определять операции над собой и формулировать представление своих данных. Но если позволить внешнему коду изменять внутренние поля структуры в обход определенных им операций, нарушается целостность данных, нарушаются свойства типа, обязательные к соблюдению -- инварианты. отсюда и возникла необходимость скрывать поля структуры, давая возможность воздействовать на данные того или иного типа используя его методы, которые однозначно определяют условия изменения данных. Так ярлык private скрывает все поля, находящиеся непосредственно под ним. В противоположность ему ярлык public делает все поля под собой доступными извне.

    class cpp_struct 
    {
        int v[10];
    public:
        unsigned int count()
        {
            return sizeof(v) / sizeof(int);
        }
    };

Обратите внимание на использование ключевого слова class. Оно является аналогом struct в языке С, но с добавлением семантики уровней доступа. При использовании этого варианта для определения структуры все поля по умолчанию скрыты.

Таким образом структуры удобно использовать для реализации динамических массивов. Несмотря на то, что размер такого массива не определить через использование sizeof, для этих целей можно создать служебную переменную, скрытую от внешнего воздействия.

    class cpp_struct 
    {
        int *v;
        unsigned int length;
    public:
        unsigned int count()
        {
            return length;
        }
    };

В этом случае необходим метод, который задает определенные значения скрытым полям согласно определенным правилам.

    void cons(unsigned int n)
    {
        v = new int [n];
        length = n;
    }

Этот метод будет гарантировать правильность данных в обоих полях, так как устанавливает их значения одновременно на основе одного и того же аргумента. Это называется "состоянием" объекта -- значения внутренних полей инициализированной структуры в заданный момент времени. Суть скрытых полей заключается в сохранении состояния объекта и защиты от изменения состояния извне в обход правил, заданных его типом данных.

Единственным затруднением будет возможность вызова этого метода для одной и той же переменной несколько раз подряд.

    cpp_struct a;
    a.cons(5);
    a.cons(10);

Нетрудно заметить, что в таком случае информация о 5 элементах, созданных при первом вызове, будет утеряна -- заменена информацией о новых 10 элементах. Такая утечка памяти должна быть предвидена заранее.

    void cons(unsigned int n)
    {
        delete [] v;
        v = new int [n];
        length = n;
    }

Но есть более надежный способ добиться нужного эффекта -- "конструктор". Конструкторы типа -- это специализированные методы, которые вызываются при создании переменной заданного типа. Так как они вызываются не на переменную, а в момент ее создания, они обладают несколькими дополнительными свойствами. Во-первых они не могут иметь возвращаемое значение. Во-вторых, они не могут иметь произвольное имя. В-третьих, они не могут быть вызваны больше одного раза.

class cpp_struct 
{
    int *v;
    unsigned int length;
public:
    unsigned int count()
    {
        return length;
    }

    cpp_struct(unsigned int n) : v(new int [n]), length(n) {}
};

Выше показан пример конструктора, который заменяет функциональность метода cons. Обратите внимание на его имя (совпадает с именем родительской структуры), отсутствие возвращаемого типа данных, а также специальный синтаксис обращения к полям структуры (список инициализации позволяет вызывать конструкторы других типов). Благодаря этой особенности структур языка С++ становится возможным такое объявление переменной.

    cpp_struct a(10);
    unsigned int len_of_a = a.count();

Скобки явно указывают на вызов конструктора, который принимает целые числа в качестве аргумента. Причем, если бы структура этого конструктора не имела, компилятор бы синтезировал пустой конструктор самостоятельно, такой конструктор не принимает никаких аргументов и не устанавливает полям своей структуры никакие значения.

    cpp_struct() {}

Следовательно, переменная такого типа может быть инициализирована, но будет иметь неинициализированные внутренние поля, что для полей примитивных типов не так важно, но для указателей может иметь плохие последствия. Из-за этого поля внутри структуры принято инициализировать до вызова конструкторов.

    class cpp_struct 
    {
        int *v{nullptr};
        unsigned int length{0};
    };

Другим методом, который будет синтезирован компилятором в случае его отсутствия в структуре, является "деструктор". Деструкторы аналогичны "конструкторам по умолчанию", и вызываются при исчезновении переменной из программы (когда заканчивается область видимости, внутри которой переменная была объявлена). Компилятор синтезирует его в таком виде.

    ~cpp_struct() {}

При работе с динамически выделенной памятью оставлять деструктор без изменений не следует, потому что тело деструктора является лучшим местом для освобождения памяти, занимаемой объектом.

    ~cpp_struct()
    {
        delete [] v;
    }

Деструктор в структуре может быть только один, конструкторов может быть сколько угодно, при условии, что их списки аргументов отличаются. Это позволяет определить множество способов создания переменных заданного типа, которые будут присущи этому типу (так как они конструкторы определены внутри него), а также определить единственный правильный способ уничтожать переменные заданного типа. 

Пользователи такого типа освобождаются от необходимости создавать специальные функции для инициализации полей такой структуры и вручную освобождать память, которая для них выделяется конструкторами, что делает этот тип данных "абстрактным" (данные и операции над ними определены самим типом, и их конкретная реализация не нужна для пользования таким типом).
