# Управление ресурсами в С++
## Конструкторы, деструктор и другие синтезируемые функции
Конструкторы в C++ выполняют две задачи. Во-первых, они инициализируют поля с данными объекта подходящими значениями. Во-вторых, они запрашивают ресурсы (файлы, области памяти и т.д.) у операционной системы для нужд объекта. Таким образом, объект после конструирования отвечает за ресурсы, ему выделенные, в том числе - и за их своевременное освобождение. В предыдущей части говорилось о том, что сборщик мусора в языке SIMULA помогал назначать стартовые значения для атрибутов объекта при его создании и очищать память, занятую объектом при его удалении. Конструкторы и деструкторы выполняют аналогичную функцию в языке С++.

"Resource acquisition is initialization" -- это выражение, которое официально используется для обозначения данной идиомы. То есть, получение ресурсов объектом должно происходить при инициализации объекта. Это нужно для того, чтобы избежать возможных проблем. Например, в языке С можно объявлять переменную без конкретного значения.
    
    int x;
    int y = 3.141519 * sqrt(x, 2);
Другой пример - возможные утечки памяти в языке С.
    
    {
        int *p = malloc(sizeof(int) * x);
    }
    // здесь вызывать free(p) уже поздно
RAII решает обе этих проблемы.

Так как конструирование объектов происходит согласно определенным правилам, пользовательские классы получают конструкторы и деструктор даже если они не определены для класса явно. Например, должна быть возможность копировать объекты при инициализации, даже если нет соответствующего конструктора, иначе нельзя было бы написать так:

    var x;
    var y = x; // переменная y будет инициализирована конструктором копирования

По этой же причине должен в классе всегда быть доступен оператор присваивания:

    var z = y;
    x = z; // переменная x будет изменена оператором присваивания копированием

В данный момент в языке С++ существует шесть специальных методов (функций) класса, которые должны быть определены всегда.
* Конструктор по умолчанию.
* Деструктор.
* Конструктор копирования. 
* Оператор присваивания копированием.
* Конструктор переноса
* Оператор присваивания переносом.

Не все эти методы могут быть правильно определены компилятором для произвольного класса, поэтому существуют специальные правила автоматического определения ("синтезирования") для них. Например, если программист определяет любой другой конструктор в своем классе не из этого списка, компилятор не синтезирует конструктор по умолчанию. Это сделано для того, чтобы избежать нежелательных вызовов синтезированного конструктора по умолчанию. 

Другим примером является конструктор переноса. Если пользователь явно задает свой конструктор переноса, компилятор не только пропустит конструктор по умолчанию, но и удалит конструктор копирования. Правило связано с тем, что если пользователь сам задал конструктор переноса, это означает, что правила копирования его объекта нетривиальны, и компилятор не может сам принимать решение о том, как правильно их копировать. Полностью правила синтезирования описаны в соответствующей таблице (http://howardhinnant.github.io/classdecl.html).

Сложность в запоминании всех возможных комбинаций синтезированных методов породила множество правил хорошего тона при создании пользовательских классов.

## Правило "трех"
Первое такое правило звучит следующим образом:
> Если в классе определен (или явно удален) либо деструктор, либо конструктор копирования, либо конструктор переноса, обязательно определять (или удалять) все три.

Делать так следует, в первую очередь, из-за правил вызова конструкторов и деструктора. Например, указатель на объект, при вызове оператора new вызывается конструктор соответствующего класса, а при вызове оператора delete - деструктор. Если сам указатель можно удалить руками, то ресурсы, на которые он ссылается, удалить можно только деструктором. При этом копирование таких объектов неизбежно приведет к дублированию адресов на ресурсы, а следовательно - к двойному освобождению. Вот простой пример:

    vector a;
    vector b(4);  // здесь без деструктора утечка памяти
    vector c = a; // здесь без конструктора копирования двойное освобождение
    c = b;        // здесь без оператора присваивания утечка памяти при замене

Чтобы не случилось ни одной из ошибок в примере выше, необходимо явно объявить нужные методы.

    class vector {
    private:
        int *p{nullptr};
        int *n{nullptr};
        int *cap{nullptr};
    public:
        ~vector() { delete[] p; } // деструктор
        vector(const vector &other) :  // конструктор копирования
            p(new int[other.n - other.p]), 
            n(p + (other.n - other.p)), 
            cap(n) 
        {
            std::copy(other.p, other.n, p);
        }
        vector& operator=(const vector &other) {  // оператор присваивания копированием
            if(&other != this) {
                delete[] p;
                p = new int[other.n - other.p];
                n = p + (other.n - other.p);
                cap = n;
                std::copy(other.p, other.n, p);
            }
            return *this;
        }
        // все остальное
    };
## Умные указатели

## Правило "нуля"
> Не написанный код неправильным быть не может.

Это правило непосредственно вытекает из "умных" указателей и является рекомендацией на все случаи. Оно подразумевает использование готовых решений везде, где это возможно, не только для работы с указателями, а вобще с любыми ресурсами. Например, если необходимо создать класс-контейнер, зачастую лучше будет использовать готовый STL-контейнер вместо написания своего.
    
    class queue {
    public:
        ~queue() = default;
        queue() = default;
        queue(const queue&) = default;
        queue& operator=(const queue&) = default;
        void push(int v) {
            data.push_back(v);
        }
    private:
        std::vector<int> data;
    };

В примере выше класс "очередь" не требует отдельных конструкторов и деструктора, которые не реализованы для стандартного вектора, так как единственное поле с данными в классе - стандартный вектор, для которого все правила инициализации, копирования, переноса и очищения уже определены.

    try {
        queue p;
        p.push(1);
        // throw here
    } catch(const std::exception& e) {
        std::cerr << e.what() << '\n';
    }

Если здесь произойдет исключение, и на переменную p будет вызван синтезированный деструктор, он передаст исполнение деструктору вектора, который освободит память, занимаемую значением "1". Таким образом, программисту можно сконцентрироваться на написании интерфейса очереди и не думать лишний раз о работе с памятью.
## Семантика переноса
Перенос был введен в язык для того, чтобы позволить программисту контролировать передачу ресурсов одного объекта другому и явно обозначать ситуации, где это происходит. Например, если какой-то контейнер выходид за пределы области видимости, и его ресурсы вот-вот будут очищены, их можно перенести в свободную переменную такого же типа, когда есть необходимост ресурсы сохранить. Это позволит избежать лишнего выделения памяти, заимствовав память уничтожаемого вектора.

    void f(const vector&); // #1
    void f(vector&&);      // #2

    int main(int argc, char const *argv[])
    {
        vector a = {1, 2, 3, 4};
        f(a);            // #1
        f({1, 2, 3, 4}); // #2
        f(std::move(a)); // #2
    }

Для обозначения функций, которые осуществляют перенос вместо копирования, используется специальный квалификатор &&, как в примере выше. Функция *f* #2 будет вызвана только на объект, из которого разрешается переносить ресурсы. Функция *move* используется для обозначения таких объектов. Ниже показано определение функции move.

    template <typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept { 
        return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); 
    }

То есть, функция конвертирует переданное как аргумент выражение в тип, обозначенный "&&", что принудительно вызовет версию функции f с параметром такого типа (в данном примере -- void f(vector&&)).
### Правило "пяти"
Это означает, что для пользовательских классов при наличии деструктора и конструктора копирования нужно определять и конструктор переноса (и в пару к нему -- оператор присваивания переносом).

    class vector {
        // сначала код из примера выше согласно правилу "трех"
        vector(vector &&other) noexcept : // конструктор переноса
            p(std::exchange(other.p, nullptr)), 
            n(std::exchange(other.n, nullptr)), 
            cap(std::exchange(other.cap, nullptr)) {}   
        vector& operator=(vector &&other) noexcept {  // оператор присваивания переносом
            vector tmp(std::move(other));
            tmp.swap(*this);
            return *this;
        }
    };
### Правило "четырех с половиной"

    class vector {
        unique_ptr<int[]> p;
    public:
        ~vector() = default;
        vector()  = default;
        vector(const vector &other) : 
            p(make_unique<int[]>(other.n - other.p.get())), 
            n(p.get() + (other.n - other.p.get())), 
            cap(n) 
        {
            std::copy(other.p.get(), other.n, p.get());
        }
        vector(vector &&other) noexcept = default;    
        void swap(vector &other) noexcept {
            std::swap(p, other.p);
            std::swap(n, other.n);
            std::swap(cap, other.cap);
        }
        vector& operator=(vector other) {
            other.swap(*this);
            return *this;
        }
        friend void swap(vector &left, vector &right) noexcept {
            left.swap(right);
        }   
    };
