# Полиморфные типы данных
## Определение "объектно-ориентированного подхода"
В 2020 году на одной из крупных конференций, посвященных языку С++, Джон Калб, программист из Microsoft/Amazon, сделал следующее заявление.

> Фраза "ООП" звучит как определение в себе, "это программирование, построенное вокруг объектов". Но если обратиться к соответствующей литературе или к академическому сообществу, там дадут совсем другое определение. ОО-программы почти всегда подразумевают использование каких-то отношений и иерархии наследования. Поэтому мое определение ООП в контексте С++, и это не обсуждается -- парадигма программирования в С++ с использованием полиморфизма, основанного на динамической функциональной диспетчеризации посредством виртуальных функций. 

Нетрудно себе представить, как такое определение может сформироваться под влиянием заявлений Бьярне Строуструпа, Роберта Мартина и др. Как правило, они на первое место ставят динамический полиморфизм и наследование. Удивляет то, с каким постоянством люди готовы игнорировать то, что об ООП говорил и говорит Алан Кей.

К чести Бьярне Строуструпа стоит отметить, что он с годами к термину "ООП" немного охладел.

> Я в думал и думаю до сих пор, что нет единого "правильного" способа писать все программы, и дизайнеру языка нечего заставлять программистов использовать определенный стиль. У дизайнера языка есть обязательство вдохновлять на и поддерживать разнообразие стилей и техник, которые показали себя как эффективные, и предоставлять возможности и инструменты, помогающие программистам избегать известных ловушек и проблем.

В этом создатели языка С++ преуспели.

    int c = 0;
    for (std::size_t i = 0; i < 3; ++i) c += a[i] * b[i];
    // или
    int c = std::inner_product(a.begin(), a.end(), b.begin(), 0);
    // или
    int c = std::ranges::fold_left_first(
        std::views::zip(a, b) | std::views::transform(
            [](auto t) { return std::get<0>(t) * std::get<1>(t); }), 
        std::plus<>());

Фрагменты выше представляют собой один и тот же алгоритм, написанный в трех разных стилях: структурном, "ОО", функциональном -- все три поддерживаются в С++. Стоит помнить, что современное программирование эволюционировало из трех высокоуровневых языков: Lisp, Algol и Smalltalk. Из первого выросла функциональная парадигма, из второго -- структурная парадигма, а из третьего -- объектно-ориентированная. Вдобавок, Lisp и Algol были первыми высокоуровневыми языками общего назначения. Их влияние на все современные языки огромно. Неудивительно, что в С++ за почти 50 лет с момента его создания постепенно перекочевали техники и инструменты из других влиятельных языков. 

Может создаться впечатление, что Строуструп прав, и стиль не имеет значения до тех пор, пока написанный код выполняет то, что задумано программистом. Но есть и другая сторона медали. Как сказал Алан Лавджой,

> Все языки программирования эквивалентны согласно принципу Чёрча-Тюринга. Какая тогда разница какой язык программирования использовать? Разница есть, потому что Тюринг описывал то, что можно вычислить, но не как быстро, и не как легко такое вычисление выразить в коде, реализовать, протестировать и выпустить в производство. Если вы не считаете, что нотация имеет значение, тогда подумайте о том, чем отличается арифметика римских цифр от арифметики арабских. Никогда не пробовали поделить в столбик, используя римские цифры? 

Эти два противоположных взгляда имеют прямое отношение к ООП. Как отмечал Джон Калб, ООП, в первую очередь, ассоциируется с динамическим полиморфизмом, которое достигается в С++ с помощью наследования и виртуальных функций. Но что он не стал говорить -- это наличие в языке других способов получить динамический полиморфизм, без использования наследования. В предыдущих частях обсуждалось об альтернативе наследованию -- шаблонах функций и типов, но они позволяют получить статический полиморфизм. Для динамического полиморфизма применяются дискриминированные типы.
## Карта объектно-ориентированного программирования
Чтобы попробовать понять, по какой причине ООП стал ассоциироваться с наследованием, а не с более общей (абстрактной) идеей динамического полиморфизма на уровне классов, стоит посмотреть на развитие парадигмы с "высоты птичьего полета". Основные источники, из которых Алан Кей черпал вдохновение -- это проекты, разрабатываемые в MIT, связанные с исследованиями искусственного интеллекта. В первую очередь это были идеи, непосредственно повлиявшие на создание языков Lisp и Algol, но параллельно с ними разрабатывались и другие технологии, самыми интересными из которых в контекте развития ООП были язык Logo и система Plex.

Алан Кей столкнулся с Logo и Plex еще до того, как стал работать над языком Smalltalk. Plex была идеей Дага Росса, который имел непосредственное отношение к развитию языка Algol: классы были внедрены в язык как непосредственная реализация идей Росса. С другой стороны, Сазерленд, работавший тогда над смежными проектами, заимствовал идею Plex для реализации Sketchpad. Параллельно Маккарти развивал теорию языка Lisp, которым Алан Кей позже активно пользовался. Как он сам говорил, наибольшее влияние на появление ООП как концепции имели: система Planner Карла Хьюита (на основе Logo), Sketchpad Сазерленда и Simula, которая была ответвлением Algol.

(тут диаграмма)

Т.о., абстрактные типы данных, оформившиеся как идея в ходе разработки языка Algol, приняли форму классов в ветке Simula, откуда были заимствованы в Smalltalk и С++ независимо друг от друга. При этом Smalltalk впитал в себя идею наследования поведения из Sketchpad и абстракции поведения из Lisp, когда С++ зациклился на идее наследования из Simula.

Т.е., объекты в Smalltalk и объекты в C++ первоначально были очень схожи, они описывали похожие концепции (инкапсуляция и абстракция поведения) и выполняли похожие задачи (реализация и композиция). Но если в Smalltalk фокус был на взаимозаменяемости объектов, в С++ упор делался на строгость системы типов. В обоих языках изначально классы были некими описаниями "замыканий" с возможностью предварительного определения всех блоков кода для них в виде списка методов, а объекты -- именованными замыканиями.
## Опять про динамический полиморфизм
Дискриминированные объединения (также называемые мечеными объединениями, дизъюнктными объединениями или типами-суммами) широко используются в языках программирования, в частности, в функциональных языках -- для достижения динамического полиморфизма. О возможности использования таких типов данных в дизайне языков говорил еще в 1966 году "Тони" Хоар.

> В какой-то момент программисту, как правило, понадобится выяснить к какому подклассу принадлежит запись, на которую ссылается переменная. Этого можно добиться с помощью конструкции, известной как дискриминатор класса записи.

Это было сказано по отношению к реализации системы типов в языке Algol. Как видно из цитаты, полиморфизм подтипов уже тогда реализовывался без наследования -- с использованием дискриминированных объединений. 

    record class expression (
        subclasses
            constant (real value);
            variable (string printname);
            pair ...
    );

    consider e when constant then ...
               when variable then ...
               when pair     then ...
Выше показан пример того, как эта идея реализовывалась тогда. Из интересного можно отметить использование слова *class*, а также встроенную в язык конструкцию для определения конкретного "подтипа". В одной из предыдущих частей иллюстрировался следующий пример. 

    enum tag { Circle, Line, ... };

    union types {
        Circle circle;
        Line line;
        ...
    };

    struct GeoObj {
        tag tag_;
        types type_;
    };

    void draw(const GeoObj& var) {
        switch(var.tag_) {
        case Circle:
            var.type_.circle.draw();
            break;
        case Line:
            var.type_.line.draw();
            break;
        case ...:
        ...
        }
    }
Заметно, что семантически идея здесь повторяет Algol практически полностью, но синтаксически значительно отличается, потому что С++ не предоставляет встроенный механизм разрешения задачи выбора правильного варианта типа данных. Это одна из причин, по которым подтипы было принято реализовывать через наследование абстрактного базового класса.

    struct GeoObj {
        virtual void draw() const = 0;
    };

    class Circle : public GeoObj {
    public:
        virtual void draw() const override;
    };

    class Line : public GeoObj {
    public:
        virtual void draw() const override;
    };

    void draw(const GeoObj& var) {
        var.draw();
    }
Синтаксически разница, на первый взгляд, значительна. Благодаря использованию виртуальных функций компилятор берет на себя принятие решения по вызову правильной реализации метода, исходя из типа данных объекта. То есть, вместо таблицы, написанной в месте вызова, пишется иерархия классов, которая отражается в виртуальной таблице, синтезированной компилятором. В результате, связь пользовательского кода с деталями реализации типа данных ослаблена, выбор происходит посредством интерфейса. Функция *draw* теперь обобщена.

Тем не менее, польза от этого минимальна, так как кроме обобщенной функции *draw* ничего не изменилось. С другой стороны, то, что правила выбора одного из вариантов скрыты, замысел разработчика перестает быть понятным конечному пользователю. Другими словами, общее количество написанного кода не изменилось, ответственность за выбор поведения была перенесена со стороны пользователя, который знает какого именно эффекта он хочет добиться, на сторону разработчика интерфейса, который не может знать, как именно его код будет использоваться, и вынужден предугадывать возможные сценарии. Пользователь же полностью зависит от доступных в интерфейсе методов. Т.е. он вынужден либо принимать всё, либо не использовать ничего.

Напрашивается вывод, что в Simula наследование не было изначально введено для достижения динамического полиморфизма, а стало так использоваться позднее уже в С++ с легкой руки программистов, которым нужен был "простой" способ добиться нужного эффекта каким-то путем, не связанным с мечеными объединениями, которые тогда широко применялись в других языках (включая Simula).

По этим причинам (удар по производительности и сложность семантики наследования) в С++ обобщенное программирование регулярно реализуется с помощью шаблонов.

    template <class GeoObj>
    void draw(const GeoObj& var) {
        var.draw();
    }
Как можно увидеть из нового примера, шаблоны позволяют избавиться от необходимости предварительно реализовывать все возможные варианты. Не нужна иерархия наследования, но исчезает динамический полиморфизм. Для большинства пользователей это не так важно, статический полиморфизм чаще предпочтителен, так как позволяет использовать систему типов языка для проверки правильности алгоритмов. 

Динамический полиморфизм все же является основополагающим принципом ООП, так как возможность свободно заменять любые объекты на любые другие с "экстремально поздним" связыванием типа аргумента намного легче достижима в динамическом контексте. Для таких случаев в С++ добавили специальный шаблон. 
## std::variant
Класс std::variant в С++ инкапсулирует обобщенное объединение, т.е. ему можно задать типы данных для всех возможных вариантов хранимых данных (откуда и название).

    std::variant<int, long, std::string> var;
    var.index();                // 0
    std::get<0>(var);           // 0
    std::get<int>(var);         // 0
    var = “hello”;             
    var.index();                // 2
    std::get<2>(var);           // “hello”
    std::get<std::string>(var); // “hello”
    var = 42;                   // var.index() == 0
    var = 77L;                  // var.index() == 1

В отличие от обычных объединений, std::variant обладает информацией о том, какой тип данных сейчас активен. И если задаются типы во время компиляции, то определяется текущий активный тип в ходе работы -- динамически. На примере выше показано, как это выглядит. Метод index указывает на тип активного объекта, метод std::get позволяет либо по индексу, либо по типу получить хранящееся значение.

    auto create_picture() {
        std::vector<std::variant<int, long, double, char>> p;
        p.push_back(42);   // p[0].index() == 0
        p.push_back('R');  // p[1].index() == 3
        p.push_back(.069); // p[2].index() == 2
        return p;
    }

Пример выше иллюстрирует гетерогенную коллекцию (вектор вариантов), каждый элемент которой может быть отдельным, не повторяющимся нигде в коллекции типом данных. Это пример динамического полиморфизма. Причем, нет необходимости использовать ссылки, умные указатели, базовый абстрактный класс и т.д. Работа с вариантом позволяет использовать значения напрямую.

Для сравнения с примером наследования, ниже представлен тот же самый интерфейс, но теперь уже реализованный с помощью std::variant. 
 
    using GeoObj = std::variant<Circle, Line, …>;
    void draw(const GeoObj& var) {
        switch(var.index()) {
        case 0:
            std::get<0>(var).draw();
            break;
        case 1:
            std::get<1>(var).draw();
            break;
        case ...:
        ...
        }
    }
Код организован как попытка воссоздать виртуальную таблицу вручную, и под таким углом преимущество std::variant над виртуальными функциями не так очевидно.
### "Visitor" pattern

    struct Visitor {
        void operator()(const Circle& c)       
        const {
            c.draw();
        }
        void operator()(const Line& l) 
        const {
            l.draw();
        }
    };

    void draw(const GeoObj& var) {
        std::visit(Visitor(), var);
    }
В новом примере

ООП -- это идея Lisp, доведенная знающими людьми до абсолюта, позже подобранная посторонними людьми и доведенная до абсурда.