# Полиморфные типы данных
## Определение "объектно-ориентированного подхода"
В 2020 году на одной из крупных конференций, посвященных языку С++, Джон Калб, программист из Microsoft/Amazon, сделал следующее заявление.

> Фраза "ООП" звучит как определение в себе, "это программирование, построенное вокруг объектов". Но если обратиться к соответствующей литературе или к академическому сообществу, там дадут совсем другое определение. ОО-программы почти всегда подразумевают использование каких-то отношений и иерархии наследования. Поэтому мое определение ООП в контексте С++, и это не обсуждается -- парадигма программирования в С++ с использованием полиморфизма, основанного на динамической функциональной диспетчеризации посредством виртуальных функций. 

Нетрудно себе представить, как такое определение может сформироваться под влиянием заявлений Бьярне Строуструпа, Роберта Мартина и др. Как правило, они на первое место ставят динамический полиморфизм и наследование. Удивляет то, с каким постоянством люди готовы игнорировать то, что об ООП говорил и говорит Алан Кей.

К чести Бьярне Строуструпа стоит отметить, что он с годами к термину "ООП" немного охладел.

> Я в думал и думаю до сих пор, что нет единого "правильного" способа писать все программы, и дизайнеру языка нечего заставлять программистов использовать определенный стиль. У дизайнера языка есть обязательство вдохновлять на и поддерживать разнообразие стилей и техник, которые показали себя как эффективные, и предоставлять возможности и инструменты, помогающие программистам избегать известных ловушек и проблем.

В этом создатели языка С++ преуспели.

    int c = 0;
    for (std::size_t i = 0; i < 3; ++i) c += a[i] * b[i];

    int c = std::inner_product(a.begin(), a.end(), b.begin(), 0);

    int c = std::ranges::fold_left_first(
        std::views::zip(a, b) | std::views::transform(
            [](auto t) { return std::get<0>(t) * std::get<1>(t); }), 
        std::plus<>());

Фрагменты выше представляют собой один и тот же алгоритм, написанный в трех разных стилях: структурном, "ОО" и функциональном -- все три в той или иной степени поддерживаются в С++. Стоит помнить, что современное программирование эволюционировало из трех высокоуровневых языков: Lisp, Algol и Smalltalk. Из первого выросла функциональная парадигма, из второго -- структурная парадигма, а из третьего -- объектно-ориентированная. Вдобавок, Lisp и Algol были первыми высокоуровневыми языками общего назначения. Их влияние на все современные языки огромно. Неудивительно, что в С++ за почти 50 лет с момента его создания постепенно перекочевали техники и инструменты из других влиятельных языков. 

Может создаться впечатление, что Строуструп прав, и стиль не имеет значения до тех пор, пока написанный код выполняет то, что задумано программистом. Но есть и другая сторона медали. Как сказал Алан Лавджой,

> Все языки программирования эквивалентны согласно принципу Чёрча-Тюринга. Какая тогда разница какой язык программирования использовать? Разница есть, потому что Тюринг описывал то, что можно вычислить, но не как быстро, и не как легко такое вычисление выразить в коде, реализовать, протестировать и выпустить в производство. Если вы не считаете, что нотация имеет значение, тогда подумайте о том, чем отличается арифметика римских цифр от арифметики арабских. Никогда не пробовали поделить в столбик, используя римские цифры? 

Эти два противоположных взгляда имеют прямое отношение к ООП. Как отмечал Джон Калб, ООП, в первую очередь, ассоциируется с динамическим полиморфизмом, которое достигается в С++ с помощью наследования и виртуальных функций. Но что он не стал говорить -- это наличие в языке другого способа получить динамический полиморфизм, без использования наследования. В предыдущих частях обсуждалось об альтернативе наследованию -- шаблонах функций и типов, но они позволяют получить статический полиморфизм. Для динамического полиморфизма применяются дискриминированные типы.
## std::variant
Класс std::variant инкапсулирует обобщенное объединение, т.е. ему можно задать типы данных для всех возможных вариантов хранимых данных (откуда и название).

    std::variant<int, long, std::string> var;
    var.index();                // 0
    std::get<0>(var);           // 0
    std::get<int>(var);         // 0
    var = “hello”;             
    var.index();                // 2
    std::get<2>(var);           // “hello”
    std::get<std::string>(var); // “hello”
    var = 42;                   // var.index() == 0
    var = 77L;                  // var.index() == 1

В отличие от обычных объединений, std::variant обладает информацией о том, какой тип данных сейчас активен. И если задаются типы во время компиляции, то определяется текущий активный тип в ходе работы -- динамически. На примере выше показано, как это выглядит. Метод index указывает на тип активного объекта, метод std::get позволяет либо по индексу, либо по типу получить хранящееся значение.

    auto create_picture() {
        std::vector<std::variant<int, long, double, char>> p;
        p.push_back(42);   // p[0].index() == 0
        p.push_back('R');  // p[1].index() == 3
        p.push_back(.069); // p[2].index() == 2
        return p;
    }

Пример выше иллюстрирует гетерогенную коллекцию (вектор вариантов), каждый элемент которой может быть отдельным, не повторяющимся нигде в коллекции типом данных. Это пример динамического полиморфизма. Причем, нет необходимости использовать ссылки, умные указатели, базовый абстрактный класс и т.д. Работа с вариантом позволяет использовать значения напрямую.

    auto pic = create_picture();
    for (const auto& obj : pic) {
        switch(obj.index()) {
        case 0:
            auto value = std::get<0>(obj);
            ...
            break;
        case 1:
            auto value = std::get<1>(obj);
            ...
            break;
        ...
        }
    }

Выбор подходящего согласно определенному типу действия может выглядет как показано в фрагменте кода выше. Ситуация выглядит, как попытка воссоздать виртуальную таблицу вручную, и под таким углом преимущество std::variant над виртуальными функциями не так очевидно. Подробней об этом будет ниже.
# Карта объектно-ориентированного программирования
Конечно, внимательный человек заметил, что похожий код упоминался значительно раньше, в одной из предыдущих частей.

    enum tag { Circle, Line, ... };

    union types {
        Circle circle;
        Line line;
        ...
    };

    struct GeoObj {
        tag tag_;
        types type_;
    };

    void draw(const GeoObj& var) {
        switch(var.tag_) {
        case Circle:
            var.type_.circle.draw();
            break;
        case Line:
            var.type_.line.draw();
            break;
        case ...:
        ...
        }
    }

Дискриминированные объединения (также называемые мечеными объединениями, дизъюнктными объединениями или типами-суммами) широко используются в языках программирования, в частности, в функциональных языках -- для достижения динамического полиморфизма. О возможности использования таких типов данных в дизайне языков говорил еще в 1966 году "Тони" Хоар.

> В какой-то момент программисту, как правило, понадобится выяснить к какому подклассу принадлежит запись, на которую ссылается переменная. Этого можно добиться с помощью конструкции, известной как дискриминатор класса записи.

Это было сказано по отношению к реализации системы типов в языке Algol. Как видно из цитаты, полиморфизм подтипов уже тогда реализовывался без наследования -- с использованием дискриминированных объединений. Из этого напрашивается вывод, что наследование не было изначально введено в Simula для достижения динамического полиморфизма, и стало так использоваться позднее уже в С++ с легкой руки программистов, которым нужен был "простой" способ добиться нужного эффекта каким-то путем, не связанным с мечеными объекдинениями, которые тогда широко применялись.


## Определение "объектно-ориентированного подхода"
ООП -- это идея Lisp, доведенная знающими людьми до абсолюта, позже подобранная посторонними людьми и доведенная до абсурда.