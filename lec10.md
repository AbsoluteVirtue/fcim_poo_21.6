# Принципы SOLID
Слово SOLID в программировании имеет особое значение. Само слово ничего не значит, являясь аббревиатурой из первых букв нескольких сокращенных фраз (SRP, OCP, LSP, ISP, DIP), значение которых будет раскрыто ниже. Это пять "принципов" проектирования программного обеспечения, которые выделил и сгруппировал в 2000 году известный под псевдонимом "дядюшка Боб" автор Роберт Мартин. Принципами их назвали в шутку, намекая на их важность для программирования в той же мере, в какой известные физические открытия (принцип исключения Паули, принцип неопределенности Гейзенберга и т.п.) стали важными для науки в 19-м веке. Прежде, чем разобрать каждый принцип в отдельности, стоит рассмотреть то, насколько их значимость для программирования на самом деле высока.

Роберт Мартин несколько лет назад получил письмо, в котором ему задавали вопрос, нужны ли принципы SOLID в современном программировании. В письме говорилось, 
> много лет SOLID был стандартной частью нашего процесса найма на работу, но с недавних пор один из менеджеров стал сомневаться в мудрости такого подхода.

Это письмо перекликается с сомнениями, которые уже достаточно давно высказываются в среде профессиональных разработчиков. Например, один из принципов, который подразумевает декомпозицию систем для высшей степени модульности, сейчас не так важен, потому что современные системы (например, "микросервисы") заранее проектируются как маленькие независимые коспоненты, а не как части "монолита". Другой пример -- наследование, которое является центральным аспектом другого популярного принципа, при этом в разработке наследование используется редко, т.к. современные языки его не поощряют.

Мартин на это отвечает, что программное обеспечение не так сильно изменилось, как может показаться: программы все еще пишут, используя аналоги *if*, *while* и присваивания -- последовательно, итеративно, с возможностью выбора. Противники его идей отмечают, что решением проблем, с которыми принципы SOLID призваны бороться, является упрощение кода приложения. Тем не менее, 
> простота не так просто достижима, для этого нужна дисциплина, поддерживаемая хорошими базовыми принципами. Другими словами, простота вырастает из принципов. Дисциплина  держит программистов в рамках, благодаря которым они пишут простой код. Лучший способ получить сложную чушь -- это сказать всем "быть проще" и больше никак их не направить.

В этом анекдоте утверждаются две вещи, которые неоспоримы:
- принципы SOLID действительно считаются если не законами, то рекомендациями, с которыми должен быть знаком каждый начинающий программист, и их знание часто проверяется во время интервью;
- есть больше количество людей, которые считают их если не вредными, то как минимум бесполезными.

Мнение Мартина по этому воводу понятно, ведь он сформулировал эти принципы как некий свод правил "хорошего тона". Но важно также прислушаться к мнению его противников. Например, есть обоснованные претензии к терминам "простой код" или "чистый код". Какой код считается чистым? Принципы SOLID не дают критериев оценки.
> Вместо этого предлагаются последовательности действий, которые сделают код чистым. Другими словами, не существует программы, которую можно запустить, чтобы она сказала "код чистый" или "код не чистый". У нас есть только действия, которые надо совершить, после чего код чист. Если посмотреть на принципы SOLID, ни один из них не является процессом, который происходит на компьютере. Эти принципы происходят только в ваших головах. Они являются критериями того, какой код программист разрешает себе писать. Это фильтр вымышленных метрик, которые не соответствуют измеримому эффекту на процессор.

Как будто в подтверждение этих слов некоторые крупные специалисты говорят, что начинающих программистов в первую очередь нужно учить тому, как использовать наследование, делегацию вызовов, приведение типов, а не тому, как писать циклы -- это "правильное" программирование. Тем не менее, Мартин всегда мудро говорит, что принципы солид не являются строгими правилами.
> Это не законы. Это не прописные истины. Это заявления вида, "если есть по яблоку в день, будешь здоров." Это хороший принцип, хороший совет, но не истинная правда и не правило.
## Мотивация
Первоначальная идея, стоявшая за необходимостью сформулировать эти принципы, заключалась в том, что Мартину нужно было описать общепринятые на тот момент решения часто возникающих проблем, которые он называл шаблонами проектирования. Цель проектирования программного обеспечения лежит в определении "формы" и структуры того или иного разрабатываемого приложения, чтобы эту форму постепенно можно было заполнить деталями реализации -- это высокоуровневая архитектура приложения. Заполнение структуры происходит согласно установленной цели программного продукта. Цель определяется модулями и их каналами коммуникации, из которых состоит проект: классами, библиотеками, функциями и т.п. Принципы SOLID призваны установить некие пути, по которым легче следовать при выборе и реализации отдельных модулей.
### Симптомы плохого проекта
Мартин выделяет четыре свойства архитектуры систем, которые указывают на плохой дизайн приложений.
1. Косность -- стойкость к изменениям.
2. Хрупкость -- неустойчивость при малейших изменениях.
3. Неподвижность -- непереносимость кода из проекта в проект.
4. Вязкость -- сложность в применении хороших практик при работе с кодом проекта.

> Rigidity – every change causes a cascade of subsequent changes in dependent modules; managers fear to allow engineers to fix non-critical problems, they don’t know when the engineers will be finished.

Первый симптом – косность – описывает тенденцию кода программ к усложнению работы с ним по мере накапливания кода. В особенности это проявляется при попытках внести в код даже самые незначительные изменения. Любое изменение неизбежно вызывает необходимость делать изменения во всех смежных модулях или файлах, которые зависят от изменяемого кода, вызывая эффект “снежного кома”. В условиях активного процесса разработки люди, отвечающие за успешность всего проекта, опасаются давать свое разрешение на внесение таких изменений даже в тех случаях, когда изменения нужны для исправления незначительных ошибок. Эти опасения вызваны предыдущим горьким опытом, который показывает, что попытки исправить что-то в программе могут привести к необходимости переписывать множество модулей. Из этого следует, что невозможно даже приблизительно установить, сколько времени понадобится инженерам для решения той или иной проблемы. Если такие случаи повторяются систематически, игнорирование мелких ошибок рискует превратиться в официальную политику менеджмента.
> Fragility – the breakage occurs in areas that have no conceptual relationship with the area that was changed; software is impossible to maintain, the probability of breakage increases with time; developers seem like they have lost control of their software.

Второй симптом – хрупкость – тесно связан с первым. Если программа теряет работоспособность каждый раз, когда в код вносятся изменения, из-за того, что эти изменения неизбежно вызывают конфликты в коде зависимых модулей, менеджмент теряет доверие к своим инженерам. Создается впечатление, что исправление одних проблем порождает еще больше новых проблем в программе. Особенно трудными последствиями опасны ситуации, когда “ломается” код, никак концептуально не связанный с измененным кодом. В такой ситуации менеджмент и пользователи теряют доверие к разработчикам, так как создается впечатление, что разработчики потеряли контроль над ситуацией.

> Immobility – one engineer discovers that he needs a module that is similar to another engineer’s; the module has too much baggage that it depends upon; the work and risk required to separate the desirable parts are too great to tolerate.

Третий симптом - еподвижность - описывает ситуации, в которых код, написанный в рамках одного проекта, невозможно использовать для других проектов. Такие ситуации могут возникнуть, если какой-то модуль реализует поведение, которое нужно повторить в другой программе. Неизбежно возникает соблазн перенести весь модуль целиком, чтобы сэкономить время. К сожалению, может случиться так, что модуль имеет большое количество зависимостей, и перенос модуля вместе с интеграцией в новый проект займет больше времени, чем написание всех алгоритмов с нуля.

> Viscosity – of the design and of the environment; faced with a change, engineers find more than one way to make the change, and some ways preserve the design while others don’t (they are hacks); if the design preserving methods are harder to employ than hacks, the viscosity of the design is high; if the development environment is slow and inefficient (long compile times, hard source control process etc.)

Четвертый симптом - вязкость - можно разделить на два вида: возникающий в дизайне или - в среде разработки. Если внесение изменений в код проекта, следуя всем договоренностям и стандартам, установленным для проекта, сопряжено с трудностями, появляется соблазн сэкономить время за счет игнорирования стандартов и ограничений. Появляется тенденция к тому, что неправильный код писать легко, а правильный – трудно. В этом выражается вязкость дизайна. 

Вязкость среды разработки выражается в том, что инструменты разработки трудно использовать эффективно. Например, если компиляция занимает много времени, инженеры перестают вносить мелкие изменения в код даже в тех случаях, когда это необходимо. Либо изменения делаются не так, как этого требует дизайн программы, а так, чтобы сократить время компиляции как можно сильнее.

Симптомы, перечисленные выше, часто рассматриваются как признаки плохой архитектуры программного обеспечения. Эти признаки часто называют неофициальным термином “гнилой код” (code rot). Первоочередная причина, как правило, в том, что требования к программе меняются в ходе разработки, при этом новые требования не поддерживаются первоначальным дизайном. Часто изменяющиеся требования к дизайну порождают сложные цепочки зависимостей и добавление новых зависимостей с каждым изменением. Способ борьбы с деградацией дизайна приложения – управление зависимостями с помощью блокирования путей проникновения зависимостей в дизайн (что Мартин называет "dependency firewall"). Это является главной причиной использования принципов SOLID.
## Open Closed
> A module should be open for extension but closed for modification

Самый важный, по мнению Мартина, принцип был заимствован у Бертрана Мейера. Ключ к достижению такого эффекта – в абстракции. Для начала - пример, который противоречит данному принципу.

    struct Modem {
        enum Type { hayes, courrier, ernie} type;
    };

    struct Hayes { 
        Modem::Type type; 
        // ..
    };

    struct Courrier {
        Modem::Type type; 
        // ..
    };

    struct Ernie {
        Modem::Type type; 
        // ..
    };

    void LogOn( Modem &m, string& pno, string& user, string& pw ) {
        if (m.type == Modem::hayes)    DialHayes((Hayes&)m, pno);
        if (m.type == Modem::courrier) DialCourrier((Courrier&)m, pno);
        if (m.type == Modem::ernie)    DialErnie((Ernie&)m, pno);
        // .. 
    }
В примере выше роль модуля со стороними зависимостями играет функция *LogOn*. Его зависимость -- структура *Modem*, которая является обобщением конкретных моделей модемов. Функция должна выполнять код, связанный с конкретной моделью, но тип модема функции заранее не известен, и поэтому он будет определяться динамически. Сразу возникает проблема с расширением этого модуля. Если в стороннем модуле появятся структуры для новых моделей модемов, функцию *LogOn* придется изменять.

Мартин же говорит, что необходимо изменить поведение модуля, не меняя его исходный код. Этого можно добиться несколькими способами, самым очевидным из них является наследование.

    struct Modem {
        virtual void Dial(const string &pno) = 0;
    };

    struct Hayes : Modem { 
        void Dial(const string &pno) override;
        // ..
    };

    void LogOn(Modem &m, string &pno, string &user, string &pw){
        m.Dial(pno);
        // .. 
    }
Наследуя абстрактный класс *Modem*, структура *Hayes* (и другие похожие структуры, представляющие разные модели модемов) расширяет базовое поведение всех модемов. Функция *LogOn* все так же зависит от структуры *Modem*, но теперь между функцией и структурой существует контракт -- люое расширение базовой структуры *Modem* гарантирует предоставлять свою реализацию метода *Dial* с интерфейсом, который ожидает функция *LogOn*. Это значит, что при появлении новых видом модемов в системе функцию *LogOn* изменять не придется.

    template <typename _Modem>
    void LogOn(_Modem &m, string &pno, string &user, string &pw) {
        m.Dial(pno);
        // .. 
    }
Такого же эффекта в С++ можно добиться с помощью шаблонов, так как пропала необходимость делать выбор реализации метода *Dial* динамически. В любом случае, эффект от такого подхода заключается в возможности написать код один раз, проверить его на правильность и больше никогда не менять.
> If you don’t have to change working code, you aren’t likely to break it.

## Liskov Substitution
> Subclasses should be substitutable for their base classes

Принцип подстановки утверждает, что "клиент" (пользователь) базового класса не должен терять доступ к функциональности, если происходит подстановка объекта, тип которого является произвольным подклассом. Для того, чтобы понять мотивацию, стоящую за этим принципом, нужно точно определить, что такое "подкласс".

В своей известной работе "Абстракции данных и иерархии" Барбара Лисков (в чью честь принцип назван) пишет,
> если для каждого объекта о1 типа S существует объект о2 типа T, т.о. что для всех программ P, которые определены посредством T, поведение P не изменится, когда вместо o1 подставляется o2 -- S является подтипом T.

Например, два (возможно независимых друг от друга) типа данных: список и множество, могут быть использованы в одном и том же контексте, т.к. оба предназначены для хранения упорядоченных наборов данных. Программа, хранящая данные в списке, в зависимости от операций на списке, которые используются в ней, может заменить список на множество (для ускорения поиска), при условии, что методы списка и методы множества имеют одинаковый интерфейс. При этом множество не является подтипом списка (даже если оно реализовано с помощью наследования списка), потому что операции добавления и удаления элементов на множествах отличаются семантически. Если добавить одно и то же значение в список, его размер увеличится на 2, в то время, как такое же добавление в множество увеличит его размер на 1 (в множестве не может быть дубликатов значений).

И наоборот, если программа использует множество, заменить его на список нельзя, так как нарушается асимптотичность операций, потенциально нарушается и поведение (список не гарантирует отсортированный порядок) - нарушается контракт, а следовательно список не будет подтипом множества. Другой пример нарушения этого принципа: очередь и стек, т.к. добавление и удаление происходят по-разному (LIFO против FIFO).  

Т.е. наследования мало для того, чтобы получить подтип, потому что недостаточно предоставлять все операции своего "супертипа" в подтипе, их семантика тоже должна быть полностью сохранена, т.к. правильность программы при замене одного на другой не должна нарушаться. Примерами подтипов могут быть деки по отношению к динамическим массивам (std::deque и std::vector), т.к. повторяют все операции доступа к элементам и изменения состава контейнера. 

Соответственно, подкласс -- это класс, который описывает подтип (традиционно, с помощью наследования). Тогда любой модуль, который использует конкретный класс, может использовать любой из его подклассов. Даже в таких ситуациях могут возникнуть трудности. Например, для геометрических фигур, можно заметить, что все круги -- это частные случаи овала (фокусы которого совпадают в центре).

    class Ellipse {
        Point focusA;
        Point focusB;
        double axis;
    public:
        void SetF(Point, Point);
        void SetA(double);
        double Area();
        // ...
    };

    struct Circle : Ellipse {
        void SetF(Point a, Point b) {
            focusA = a; focusB = a;
        }
        double Area();
        // ...
    };

    void User(Ellipse &e) {
        Point a, b;
        e.SetF(a, b); 
        assert(e.GetFoci() == {a, b});
    }
Исходя из такого предположения, можно создать иерархию классов, как показано в примере выше. Проблема такой реализации может подкрасться незаметно. Принцип подстановки нарушается, если для такой реализации круга в функцию *User* передать объект типа *Circle*. Реализация функции зависит от конкретного поведения объекта: после установки фокусов объекта в координатах *a* и *b*, проверка должна подтвердить эти координаты. Данный контракт будет кругом нарушен, потому что у него нет второго фокуса.

Можно предварительно проверять предусловие.

    void User(Ellipse &e) {
        if(typeid(e) != typeid(Ellipse))
            return;
        Point a, b;
        e.SetF(a, b); 
        assert(e.GetFoci() == {a, b});
    }
Но в таком случае зависимость между пользовательским кодом и реализацией функции становится явной. Как правило, нарушения LSP одновременно указывают на нарушение OCP.

Можно перевернуть иерархию, ведь все овалы технически являются общими случаями круга.

    class Circle {
        Point center;
        double radius;
    public:
        void SetC(Point);
        void SetR(double);
        double Area();
    };

    class Ellipse : Circle {
        Point focusB;
    public:
        void SetF(Point a, Point b) {
            Circle::center = a; focusB = b;
        }
        double Area();
    };
Здесь обнаруживается другой подводный камень: вычисление площади эллипса отличается от вычисления площади круга, поэтому для круга нужно переопределить метод *Area*. Это немедленно нарушит контракт в примере ниже.

    void User(Circle &c) {
        Point a, b; double r;
        c.SetC(a, b);  c.setR(r);
        assert(c.Area() == f(a, b, r));
    }
Функция *User* делает некоторое предположение относительно площади фигуры, которое не будет верным в случае передачи в функцию объекта типа *Ellipse*. Проверка предусловия и в этом примере вызовет ошибку.

Оба примера показывают, что наследование не является гарантией того, что один класс является корректным подклассом другого. Даже если синтаксически подкласс существует, семантически он может нарушать принцип подстановки, а значит в данном случае объекты этих связанных иерархически типов не взаимозаменяемы.

(Очевидное следствие из этих двух примеров: наследование данных является плохим примером использования наследования, во избежание возникновения проблем наследовать нужно поведение).
## Dependency Inversion
> Depend upon abstractions, not upon concretions.
