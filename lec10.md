# Принципы SOLID
Слово SOLID в программировании имеет особое значение. Само слово ничего не значит, являясь аббревиатурой из первых букв нескольких сокращенных фраз (SRP, OCP, LSP, ISP, DIP), значение которых будет раскрыто ниже. Это пять "принципов" проектирования программного обеспечения, которые выделил и сгруппировал в 2000 году известный под псевдонимом "дядюшка Боб" автор Роберт Мартин. Принципами их назвали в шутку, намекая на их важность для программирования в той же мере, в какой известные физические открытия (принцип исключения Паули, принцип неопределенности Гейзенберга и т.п.) стали важными для науки в 19-м веке. Прежде чем разобрать каждый принцип в отдельности, стоит рассмотреть то, насколько их значимость для программирования на самом деле высока.

Роберт Мартин несколько лет назад получил письмо, в котором ему задавали вопрос, нужны ли принципы SOLID в современном программировании. В письме говорилось, 
> много лет SOLID был стандартной частью нашего процесса найма на работу, но с недавних пор один из менеджеров стал сомневаться в мудрости такого подхода.

Это письмо перекликается с сомнениями, которые уже достаточно давно высказываются в среде профессиональных разработчиков. Например, один из принципов, который подразумевает декомпозицию систем для высшей степени модульности, сейчас не так важен, потому что современные системы (например, "микросервисы") заранее проектируются как маленькие независимые коспоненты, а не как части "монолита". Другой пример -- наследование, которое является центральным аспектом другого популярного принципа, при этом в разработке наследование используется редко, т.к. современные языки его не поощряют.

Мартин на это отвечает, что программное обеспечение не так сильно изменилось, как может показаться: программы все еще пишут, используя аналоги *if*, *while* и присваивания -- последовательно, итеративно, с возможностью выбора. Противники его идей отмечают, что решением проблем, с которыми принципы SOLID призваны бороться, является упрощение кода приложения. Тем не менее, 
> простота не так просто достижима, для этого нужна дисциплина, поддерживаемая хорошими базовыми принципами. Другими словами, простота вырастает из принципов. Дисциплина  держит программистов в рамках, благодаря которым они пишут простой код. Лучший способ получить сложную чушь -- это сказать всем "быть проще" и больше никак их не направить.

В этом анекдоте утверждаются две вещи, которые неоспоримы:
- принципы SOLID действительно считаются если не законами, то рекомендациями, с которыми должен быть знаком каждый начинающий программист, и их знание часто проверяется во время интервью;
- есть больше количество людей, которые считают их если не вредными, то как минимум бесполезными.

Мнение Мартина по этому воводу понятно, т.к. он сформулировал эти принципы как некий свод правил "хорошего тона". Но важно также прислушаться к мнению его противников. Например, есть обоснованные претензии к терминам "простой код" или "чистый код". Какой код считается чистым? Принципы SOLID не дают критериев оценки.
> Вместо этого предлагаются последовательности действий, которые сделают код чистым. Другими словами, не существует программы, которую можно запустить, чтобы она сказала "код чистый" или "код не чистый". У нас есть только действия, которые надо совершить, после чего код чист. Если посмотреть на принципы SOLID, ни один из них не является процессом, который происходит на компьютере. Эти принципы происходят только в ваших головах. Они являются критериями того, какой код программист разрешает себе писать. Это фильтр вымышленных метрик, которые не соответствуют измеримому эффекту на процессор.

Как будто в подтверждение этих слов некоторые крупные специалисты говорят, что начинающих программистов в первую очередь нужно учить тому, как использовать наследование, делегацию вызовов, приведение типов, а не тому, как писать циклы -- это "правильное" программирование. Тем не менее, Мартин всегда мудро говорит, что принципы солид не являются строгими правилами.
> Это не законы. Это не прописные истины. Это заявления вида, "если есть по яблоку в день, будешь здоров." Это хороший принцип, хороший совет, но не истинная правда и не правило.
## Мотивация
Первоначальная идея, стоявшая за необходимостью сформулировать эти принципы, заключалась в том, что Мартину нужно было описать общепринятые на тот момент решения часто возникающих проблем, которые он называл шаблонами проектирования. Цель проектирования программного обеспечения лежит в определении "формы" и структуры того или иного разрабатываемого приложения, чтобы эту форму постепенно можно было заполнить деталями реализации -- это высокоуровневая архитектура приложения. Заполнение структуры происходит согласно установленной цели программного продукта. Цель определяется модулями и их каналами коммуникации, из которых состоит проект: классами, библиотеками, функциями и т.п. Принципы SOLID призваны установить некие пути, по которым легче следовать при выборе и реализации отдельных модулей.
### Симптомы плохого проекта
Мартин выделяет четыре свойства архитектуры систем, которые указывают на плохой дизайн приложений.
1. Косность -- стойкость к изменениям.
2. Хрупкость -- неустойчивость при малейших изменениях.
3. Неподвижность -- непереносимость кода из проекта в проект.
4. Вязкость -- сложность в применении хороших практик при работе с кодом проекта.

Rigidity – every change causes a cascade of subsequent changes in dependent modules; managers fear to allow engineers to fix non-critical problems, they don’t know when the engineers will be finished.

Fragility – the breakage occurs in areas that have no conceptual relationship with the area that was changed; software is impossible to maintain, the probability of breakage increases with time; developers seem like they have lost control of their software.

Immobility – one engineer discovers that he needs a module that is similar to another engineer’s; the module has too much baggage that it depends upon; the work and risk required to separate the desirable parts are too great to tolerate.

Viscosity – of the design and of the environment; faced with a change, engineers find more than one way to make the change, and some ways preserve the design while others don’t (they are hacks); if the design preserving methods are harder to employ than hacks, the viscosity of the design is high; if the development environment is slow and inefficient (long compile times, hard source control process etc.)
