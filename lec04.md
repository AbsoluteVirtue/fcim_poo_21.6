# Smalltalk и инкапсуляция в ООП
## Источники вдохновения
Алан Кей указывал на Sketchpad, SIMULA и LISP как на основные системы, с которых он брал пример при разработке концепции ООП. Но в большой статье, посвященной истории языка Smalltalk, он упоминает менее известные примеры технологий, которые, тем не менее, также оказали на его подход к дизайну компьютерных систем большое влияние.

## Работа над FLEX
В 1961 году Алан Кей работал программистом на департамент обороны США перед тем как начать работать над своими собственными системами в университете Юты. Он отвечал за работу компьютеров системы Burroughs 220. На этих компьютерах не было операционной системы, и программисты должны были работать с памятью и файлами напрямую. Кто-то из предшественников Алана Кея на должности программиста написал свою файловую систему для этих компьютеров. Она разделяла все файлы на три части:
* структуры данных произвольного размера и формата;
* процедуры, доступные на Burroughs 220 "из коробки", которые могли обновлять данные в структурах;
* массив указателей на процедуры, описанные во второй части.
Дословно,
> "Очевидно, что это была отличная идея, которая использовалась во многих последующих системах до тех пор, пока всех не заставили перейти на COBOL и не похоронили ее."

Тут может броситься в глаза два интересных момента:
1. Точно такая же система использовалась в Sketchpad для описания "мастера" экземпляров.
2. Похожая идея использовалась в SIMULA 67 для развития концепции процесса и окончательного варианта с классами.

Эту идею Алан Кей принес с собой в университет Юты, куда его пригласили на позицию аспиранта. Первым его заданием стало прочитать диссертацию Сазерленда о Sketchpad, а вторым -- разобраться, почему копия компилятора Algol, которая лежала в департаменте, не запускалась на местных компьютерах. При ближайшем рассмотрении оказалось, что это вовсе не Algol, а какой-то никому не известный язык SIMULA, написанный на базе Algol.

> "От SIMULA я заимствовал идею заменить связывание значений параметров и присваивание значений переменным на "цели". Худшее, что можно разрешить программисту -- это ковыряться во внутреннем состоянии объекта, даже если состояние представлено абстрактно. Вместо этого объекты должны быть представлениями высокоуровневого поведения, которые удобно использовать в качестве динамических компонентов." 

Таким образом, основные представления об организации процессов в компьютерных программах сложились под влиянием этих трех систем. Под впечатлением от Sketchpad, а также от статьи Гордона Мура, в которой появилось предсказание о темпах роста производительности компьютеров (см. "Закон Мура"), Алан Кей принял решение разработать концепцию персонального компьютера. Для этого нужно было разработать собственный язык, который воплощает новые идеи, подчерпнутые из других работ, в жизнь в новой парадигме.
### Объектно-ориентированный подход
> "Новая парадигма разработки для решения сложных проблем профессиональными программистами и для решения простых проблем новичками. Объектно-ориентированный дизайн -- это удачная попытка качественно улучшить эффективность процесса моделирования сложных динамических систем и пользовательских отношений с этими системами, которые стали возможны благодаря кремниевому взрыву."

Главными мотивационными факторами для разработки этой парадигмы были:
1. Необходимость в лучшей схеме для поддержания модульности сложных систем посредством скрытия деталей реализации.
2. Необходимость в более гибкой версии присваивания, которую впоследствии можно вовсе убрать. 

Важность сокрытия деталей реализации для ООП станет понятна позднее. Важность отсутствия операции присваивания уже упоминалась в статье Джона Бакуса, где подчеркивалась природа присваивания "по одному слову за раз" как негативный аспект в "традиционных" языках программирования. Алан Кей видел в присваивании и другие недостатки. 

Так, присваивание должно быть обобщенной операцией. Компьютеры до распространения ООП в основном оперировали значениями двух видов: l-lvalue ("левосторонние") и r-value ("правосторонние") -- где первая буква обозначает отношение значения к оператору присваивания. Такое разделение делает выражения очень ограниченными, так как не все выражения могут быть левыми операндами присваивания. Для объектов, которые Алан Кей задумывал реализовать в рамках своей системы, такое присваивание не подходило.

В качестве примера он приводит простое выражение:

    a[55] := 0
где имя "а" означает массив. Проблема такой записи в том, что даже если в массиве уже по заданному индексу есть значение "0", оператор присваивания все равно его вынужден заменить на тот же "0". Это произойдет потому, что оператор "[]" должен сначала разыменовать область памяти и вернуть значение по ссылке, так как оператор ":=" требует слева от себя l-value. Было бы лучше в таком случае использовать другую форму выражения: 

    a(55, ':= ', 0)
которая может предварительно проверить все операнды перед тем, как обращаться по ссылке и изменять значение в памяти. То есть, по замыслу Алана Кея запись ":=" должна быть не оператором, а индексом в таблице возможных процедур, описывающих поведение объекта.

В итоге, Алан Кей взял лучшие решения из Burroughs (мастер-версия объекта и ее экземпляры, которые ссылались на мастер указателями), SIMULA (класс и его экземпляры, организованные в иерархию "префикс-подкласс", процессы как сопрограммы), Sketchpad (абстрактные типы данных и инкапсуляция) для своей системы FLEX.

    while i <= 1 to 30 by 2 ^ j <= 2 to k by 3 do j<- j * i;
Выше показан пример кода FLEX, где в качестве цикла выступает процесс, который можно при желании приостановить, чтобы потом продолжить с той же инструкции ("генератор"). Это было возможно благодаря организации программ в комбинацию подпрограмм, которые могли быть независимыми друг от друга, аналогично подходу, который использовался в SIMULA. Сопрограммы FLEX были аналогами "объектов" в SIMULA. 
> “Объекты являются чем-то сродни соответствию между множеством объектов и множеством поведений объектов.”

Еще одной малоизвестной системой была IMP, идея которой залючалась в создании специальных формальных грамматик, где каждая "фраза" могла играть роль процедуры, семантиеское определение которой можно было написать в рамках других определений, доступных на том этапе. Алан Кей увидел в этом возможный "мост" между "процедурными" и "объектными" системами: каждый объект мог быть синтаксическим интерпретатором сообщений, которые ему посылаются. Благодаря этой одной идее можно было получить бескончено расширяемый язык, аналогично формальным грамматикам.

Чтобы более четко себе представить такую систему, можно посомтреть на компьютерную сеть, где одни компьютеры отправляют другим компьютерам запросы. Чтобы правильно обработать запрос и ответить на него, адресат должен понимать сообщение в запросе. По аналогии объекты в "объектном" языке могли играть роль "сервера", который предоставляет услуги другим объектам. Объект сам определял: предоставлять услугу или нет -- в зависимости от установленных отношений между адресатом и адресантом.
### Влияние Lisp на ООП
Основная идея, которая была заимствована из Lisp -- это комбинация механизма "позднего связывания" и возможности универсальной композиционности вычисляющих элементов, которая "раскрывала простоту программирования" и позволяла писать программы любой сложности.

> "Одним воскресным вечером я сидел и читал исходный код "eval-apply" цикла, на котором базировалась исполняющая часть Lisp, и он заставил меня пересмотреть мое мнение относительно такого способа вычисления. Я обратился к книге Питера Дойча, посвященной языку Lisp, которая включала в себя полную реализацию интерпретатора для компьютеров PDP-1. Подход, который он использовал, был похож на тот, который я применял для компьютера с FLEX (сам FLEX основывался на языке Euler Никлауса Вирта, а тот, в свою очередь, был интерпретацией Lisp на базе языка Algol). То, как код организовывался в Lisp, отличалось от Algol. Однажды привыкнув к такому способу, было намного легче мыслить о фундаментальных вопросах, чем в Euler или Algol."

Одна из ключевых идей языка заключалась в том, как и когда значения привязываются к выражениям или переменным. Например, если λ-выражение является аргументом функции, что делать с ее свободными переменными (внешними относительно тела выражения)? Этот вопрос был в итоге решен с помощью создания "замыканий", и он повлиял на то, как объекты ведут себя в Smalltalk.

> "Как такое выражение рассматривать в другой среде? Нужно ли искать значения свободных переменных динамически? Это может быть полезным свойством. Связать глобальные переменные с их значениями в вызывающей среде и запаковать список значений в λ-выражение (что очень похоже на принцип устройства объектов в SIMULA). Или можно искать значения глобальных переменных динамически в вызывающей среде. Тоже может быть полезным аналогично thunk-объектам в Algol ('вызов по имени'.)"

Семантика языка Lisp полностью основывалась на идее функций как объектов, но самыми важными компонентами были не функции, а λ-выражения, "ленивые" символы и условные операторы ("специальные формы"). Причем, последние два были выражены в языке посредством λ-выражений. Специальные формы были реализованы в виде FEXPR -- пользовательских функций, которые не вычисляли значения своих аргументов (для высокой производительности). Обычные же функции (встроенные и пользовательские) были реализованы в виде EXPR -- они вычисляли значения аргументов при вызове. Алан Кей считал такую двойственность дефектом языка, который в остальных аспектах был близок к идеалу. Он считал, что весь язык надо было бы базировать на идее FEXPR -- "ленивых" функциональных форм.

Несмотря на это, Алан Кей часто пользовался Lisp. Существует анекдот о событии, с этим связанным, произошедшим в ходе одной из конференций. Ален Ньюэлл, разработчик нового языка IPL-V делал презентацию своего детища, пытаясь убедить других участников переходить на этот язык. Ему предложили доказать полезность языка, решив простую задачу: для произвольного списка целых чисел передвинуть все нечетные в начало списка, а все четные в конец списка. Задачу нужно было решить за время, которое потребуется участникам для подписания протокола встречи. Ньюэлл возился с решением больше 30 минут. Алан Кей, который присутствовал на встрече, предложил решение, написанное на Lisp за 5 минут:

    oddsEvens (x) = append (odds (x), evens (x)) 
        where odds(x) = if null(x) or null(tl(x)) then x 
              else hd(x) and odds(ttl(x)) 
              evens(x) = if null(x) or null(tl(x)) then nil 
              else odds(tl(x))

Как он потом говорил,
> "Характеристика языка, позволяющая писать решения задач в декларативной форме, при этом оставаясь полноценными программами, является очень привлекательной и элегантной частью языков такого рода. Я в очередной раз убедился, что 'точка зрения стоит 80 очков интеллекта.' Я не был умнее в той ситуации, но у меня был намного лучший инструмент для организации мыслей, который усиливал мои возможности."
## Работа над Smalltalk
Ключевой принцип языка Lisp заключался в том, что "он позволял программисту учиться большему -- частично благодаря возможности делать больше попыток и чаще менять подход -- чем в любой другой системе для программирования. Особенно важно это было в случаях, когда возникала необходимость в чем-то, что сама система не предоставляла в готовом виде. Мета-рефлексивные свойства Lisp предоставляли программисту больше вариантов все равно сделать что-то полезное." Это выразилось в подходе, который Алан Кей применил для реализации своего следующего пректа.

По итогам своей работы над FLEX Алан Кей перешел работать в исследовательский центр компании Xerox -- PARC, где ему доверили разрабатывать концепцию первого персонального компьютера. Для этой цели Алан Кей начал разрабатывать новый язык программирования, который он назвал Smalltalk. Этот язык впитал в себя идеи из FLEX, а также некоторые удачные решения из языка LOGO, системы логического моделирования PLANNER (предок языка Prolog) и некоторых других прорывных технологий того времени. 

Идея интерпретатора Lisp с циклом "eval-apply" была реализована в Smalltalk в качестве универсального вычислительного механизма на уровне каждого объекта. Объект получал возможность независимо от других объектов интерпретировать инструкции, для него предназначенные. Другими словами, язык предоставлял возможность объектам парсить текстовые сообщения сразу, интерпретировать их и исполнять токены напрямую. Это было сделано, в первую очередь, для того, чтобы позволить писать программы в разных стилях: парсер позволял легко расширять его возможности, добавляя объектам новые виды "поведения", а также предельно ясного описания механизмов вычисления значений выражений.

Классы в Smalltalk выглядели как функции и могли использоваться вместо функций, сохраняя возможность создавать на их основе экземпляры с собственной областью памяти (как "замыкания" в Lisp). Это позволяло писать эквивалентные программы в разных стилях. Например, факториал можно было выразить экстенсивно (как отдельный класс fact):

    to fact n (^if :n=O then 1 else n'fact n-l) 
или интенсивно, в рамках класса integer: 

    (... *! >> (^:n=0 >> (1)(n-1)!) )
Алан Кей особенно подчеркивал важность идей, заложенных в Lisp:

> "Если задуматься о паре процессов “eval” и “apply”, которые составляют интерпретатор [Lisp]: “apply”, по сути, отправляет сообщение какому-то объекту, особенно в случае, если вычисление значения параметра можно доверить самому принимающему объекту, и если принимающий объект является замыканием. Остается только ослабить зависимости между всеми элементами этого механизма, как сделано для других идей в Lisp, и получится простой фундамент для иного взгляда на вычислимость и программирование."

Вычисление в Smalltalk-71 производилось методом "pattern-matching" аналогично Lisp: 

    to T 'and' :y do 'y' 
    to F 'and' :y do F
    
    to 'factorial' 0 is 1 
    to 'factorial' :n do 'n'factorial n-l'

    to 'fact' :n do 'to 'fact' n do factorial n. ^ fact n'
    
    to :e 'is-member-of [] do F 
    to :e 'is-member-of :group 
        do 'if e = first of group then T 
            else e is-member-of rest of group'
Философия языка Smalltalk выглядела так:
1. Все является объектом. 
2. Объекты общаются друг с другом посылая и получая сообщения (которые тоже представлены объектами).
3. Объекты обладают своей памятью (которая тоже представлена объектами).
4. Каждый объект -- это экземпляр класса (который должен сам быть объектом).
5. Класс содержит описание поведения всех своих экземпляров (в виде объектов).
6. Обработка списка инструкций (программы) заключается в передаче управления первому объекту в списке, который рассматривает весь оставшийся список как сообщение для себя.

Дизайн Smalltalk должен был быть рекурсией понятия "компьютер" целиком. Алан Кей хотел отойти от практики разделения программ на структуры данных, процедуры, функции и т.п., общепринятые в других языках программирования. Ведь затем их надо связывать друг с другом для получения нужного эффекта. Без таких связей, независимо друг от друга, эти фундаментальные элементы были бесполезны. Функции не имеют смысла без данных, структуры не имеют смысла без операций над своими данными. 

Поэтому каждый объект в Smalltalk должен предоставлять возможности всего компьютера. Благодаря этому любая часть программы может игнорировать конкретные объекты (типы данных), которые используются в ней, ведь они взаимозаменяемы. Главным является то, что они правильно себя ведут, а не то, как именно их поведение описано внутри конкретного класса.

Другими словами, объект в Smalltalk -- это универсальная вычислительная единица, поэтому особенно важным было следить за тем, где (в какой среде исполнения -- замыкании) и когда (насколько поздно) вычисляются значения выражений. Это зависело от того, какие данные передаются в сообщении конкретному объекту. В диссертации Дейва Фишера о структурах управления в языках программирования Алан Кей нашел элегантное решение этой задачи.

Algol 60 требовал разделять динамическую привязку подпрограмм от доступа к глобальному статическому состоянию программы. Фишер показал, как можно обобщить оба этих механизма и с помощью такой абстракции симулировать большое разнообразие сред управления. Например, задачу по хранению замыканий в "стековой" памяти ("funarg problem") Фишер предложил решить с помощью таблицы, в которой соответствующие ссылки на глобальное состояние ассоциируются с выражениями и функциями, которые должны быть в последтствии вычислены. Таким образом, свободные переменные, на которые замыкание ссылается, будут правильными участками памяти, которые подразумевает код программы. Похожий подход позже получит общее название "ленивая оценка". Алан Кей называл это "рефлектным дизайном."

## Зарождение парадигмы ООП
Сокрытие деталей реализации (то, как объекты были реализованы с SIMULA 67) естественным образом привело к тому, что для сообщений необходимо было определять обобщенное (generic) поведение. В функциональном мире для обозначения такого механизма использовалось слово "полиморфизм", которое означало функции, принимающие аргументы произвольного типа. Алан Кей ту же самую идею распространял на сообщения -- вид и форма сообщения принимающему объекту заранее не известны.

Сокрытие состояния объекта естественным образом привело к тому, что для изменения состояния необходимо было отказаться от операции присваивания.

> "Большинство значений переменных внутри экземпляра находятся в динамических отношениях друг с другом, эти отношения поддерживаются деталями реализации. Поэтому давать возможность изменять состояние объекта напрямую извне опасно."

Алан Кей ввел правило для каждого объекта: как минимум включать в свой интерфейс метод-сеттер. Это позволяет контролировать процесс изменения внутреннего состояния объекта и сохранять динамические отношения между локальными или статическими переменными класса.

> "Правда, большинство людей использует сеттеры просто для симуляции присваивания во внутреннюю переменную, а это противоречит духу и намерению настоящего ООП."

Because control is passed to the class before any of the rest of the message is considered---the class 
can decide not to receive at its discretion----complete protection is retained. Smalltalk-72 objects are 
"shiny" and impervious to attack.

Of course, the whole idea of Smalltalk (and OOP in general) is to define everything intensionally. 
And this was the direction of movement as we learned how to program in the new style. There were a number of revolutionary architectures to see in the early 60s — Sketchpad, Lisp (basically Lisp 1.5), the B5000 (a computer that could directly execute byte-codes completely safely, and was essentially a multiprocess “Simula machine” before there was a Simula), and APL (not yet implemented, but in Iverson’s book). And, even Algol (with its recursion, call by name, nested block structure, etc. was revolutionary at the time). (And there was quite a lot more to see as well, especially some of the meta systems for generating languages from metalanguages, etc.)

Four techniques used together--persistent state, polymorphism, instantiation, and methods-as-goals for the object--account for much of the power. None of these require an "object-oriented language" to be employed--ALGOL 68 can almost be turned to this style--and OOPL merely focuses the designer's mind in a particular fruitful direction. However, doing encapsulation right is a commitment not just to abstraction of state, but to eliminate state oriented metaphors from programming.

But objects do have "world lines" of changes in time. This can be thought of as a history of versions of the object in which the -relationships- are in accord. There are no race conditions in this scheme ... an object is only visible when it is stable and no longer computing.

P.S.: Smalltalk seems much more a notation, that can do nothing but build domain specific languages. Ruby isn't object oriented at the level Smalltalk is, is still falls back to procedural constructs and special syntax for many things. Smalltalk, is pure, objects all the way down, at every level, even the simplest and most common domain specific language of all, predicate logic. When you create a domain specific language in Smalltalk, your code never looks different than code provided by the compiler writer himself, it's one syntax to rule them all.

Smalltalk shares this trait with languages such as Lisp and Scheme, truly growable languages that put you, the programmer, in charge of what language you want, not some compiler writer who might take six more years to add some feature you just got to have now. When you need a new language feature in Smalltalk, you simply add it. It's a feeling that once you've become accustomed to, you can't live without, and one you don't quite get with Ruby.