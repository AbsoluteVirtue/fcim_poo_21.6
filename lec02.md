# Что значит "объектно-ориентированный"?
Если поискать информацию о термине "объектно-ориентированный" в произвольных открытых источниках, в большинстве случаев приводится пример "трех китов ООП":
* инкапсуляция;
* наследованиеж;
* полиморфизм.

Эпиграфом может служить цитата известного дизайнера Грэди Буча, взятая из книги "Object-Oriented Analysis, Design and Implementation".

> "Язык считается объектным, если он напрямую поддерживает абстракцию данных и классы. Объектный язык является объектно-ориентированным, если он поддерживает наследование и полиморфизм."

Возможно, именно отсюда и пошла традиция привязывать три этих явления к ООП. Данный курс попытается доказать, что ни один из этих элементов не является критической частью ООП в отдельности. 

Инкапсуляция в Smalltalk (первом официально "объектно-ориентированном" языке) - это результат неправильных выводов, сделанных Аланом Кеем под влиянием дизайна Sketchpad (где инкапсуляции не было) и языка Simula (где она носила схематичный характер, о чем речь пойдет ниже).

Наследование никогда не было составной частью ООП, и даже в языке С++ от наследования какой-то общей структуры ушли к наследованию общего поведения через интерфейсы, а в итоге от него отказались в пользу статического полиморфизма. Тем не менее, наследование заслуживает более подробного рассмотрения, так как первоначально широко применялось в Smalltalk, в последствии оказавшись ненужным.

Полиморфизм - это свойство системы типов, которое само собой не подталкивает использовать объекты, скорее, являясь инструментом к достижению высокой степени обобщенности в коде. Полиморфизму будет посвящена отдельная глава. 

Начать стоит с изучения двух базовых элементов, о которых говорит Буч в своей книге: абстрактных данных и классов. И не только потому, что эти понятия сейчас тесно связаны с ООП. Алан Кей пользовался этими механизмами во время работы над языком Smalltalk, что требует их более внимательного рассмотрения.

В середине 1960х годов Кей работал в новой команде разработки, где ему порекомендовали ознакомиться с двумя на тот момент новыми примерами инновационного использования компьютерных технологий. Первой технологией была система компьютерного дизайна Sketchpad Айвана Сазерленда, которая стала одной из самых значимых работ в сфере компьютерных технологий. Второй был язык программирования Simula, использующий новую концепцию "классов как процессов" в качестве основного инструмента организации кода.

Зная о том, что в группе по разработке языка Algol высказывались идеи об использовании "абстрактных типов данных" (которые условно были названы PLEX Дагласом Россом, о ком подробней будет сказано далее), Кей попытался объединить идею "плексов" из Algol, классов из Simula и обощенных структур данных из Sketchpad.

Общая идея системы, над которой он работал, заключалась в создании сети компьютерных процессов, которая не позволяет процессам напрямую изменять состояния друг-друга. Вместо этого процессы должны были отправлять друг другу запросы в виде правильно сформированных сообщений. Так, для изменения какого-то значения один процесс посылал сообщение с новым значением другому процессу, который отвечал за данную область памяти. Процесс-получатель читал сообщение и принимал окончательное решение о том, нужно ли изменять значение в памяти или нет. Это позволяло программисту, работающему в такой системе, вместо простых инструкций с присваиванием значений отдельным переменным писать более абстрактные инструкции, описывающие желаемый окончательный результат. Процессы же сами должны были выбирать правильные инструкции для достижения результата.

## Объекты
Эта концепция появилась не на пустом месте. Кей был биологом по первому образованию и часто обращался к билогии за вдохновением. Для своей системы он выбрал поведение биологических клеток, которые защищены от внешнего мира мембраной, но могут обмениваться информацией с другими клетками с помощью специальных белков и соответствующих рецепторов. Кею эта модель нравилась тем, что систему, построенную по такому принципу, можно расширять до бесконечности, получая результат любой сложности (по аналогии с тем, как из одних и тех же клеток с помощью ДНК получаются разные организмы).

Кей предполагал, что и в компьютерных системах возможно создание программы любой сложности из обобщенных процессов, которые работают каждый по своим правилам, отвечают каждый за свою зону ответственности и взаимодействуют друг с другом согласно определенным протоколам. Прототипом такой системы стал Интернет, к разработке которого Кей тоже приложил свою руку. Если рассматривать процессы как отдельные компьютеры, объединенные в компьютерную сеть, в таком сценарии компьютеры могут взаимодействовать друг с другом только посредством отправки сообщений другим компьютерам, оставаясь независимыми вычислительными объектами, данные которых скрыты от остальных компьютеров в одной с ними сети. Таким образом компьютеры инкапсулируют данные в памяти и вычислительный процесс, а объединение таких процессов в общую сеть позволяет умножать их вычислительные возможности.

Это привело Алана Кея к простой модели, согласно которой могла быть написана любая компьютерная программа:
* базовой исполняющей сущностью является вычислительный процесс;
* процесс создает и поддерживает операции над сегментами данных в памяти;
* операции поддерживают параллельное исполнение;
* процессы должны отвечать на события (где событие - event - понимается как действие, распознаваемое в системе, происходящее асинхронно основному выполнению программы, которое может быть как-то программой обработано в ответ на соответствующий сигнал от системы);
* и т.д.

Кей называл свои процессы "объектами", откуда и пошел термин "объектно-ориентированное программирование". Поэтому данный курс будет использовать следующее определение объекта в дальнейшем.

Объект - это описание вычислительного процесса или семейства процессов, которое скрывает свои данные от внешней среды и может работать независимо от других объектов, взаимодействуя с ними с помощью сообщений, отправленных согласно какому-то протоколу.

Далее будут рассмотрены более подробно три главных примера, которые использовал в своей работе Алан Кей: абстрактные типы данных, классы и обобщенные структуры данных.

## Sketchpad – a man-machine graphical communication system
Чтобы в полной мере оценить важность Sketchpad для ООП, надо отметить, что Алан Кей называл эту работу "наверное, самой значимой дипломной работой в истории". Стоит только добавить, что Кей также называл Sketchpad первой "объектно-ориентированной" системой. Несколько свойств Sketchpad были напрямую переняты в Smalltalk, для того, чтобы он мог быть по-настоящему объектно-ориентированным языком.

### Master - instance
В Sketchpad дизайнер оперировал световым пером для того, чтобы создавать на экране компьютера чертежи. Чертежи организовывались в иерархию, в которой была главный чертеж (master drawing), изменения которого отражались на всеъ копиях главного чертежа. Копии или "экземпляры" (instances) создавались на основе главного чертежа, повторяя все его свойства, причем изменения одной копии никак не отражались на остальных элементах чертежа. Экземпляры можно было использовать для создания новых "рекурсивных" иерархий любой степени вложенности. Этот принцип позже лег в основу иерархий наследования, которые создавались в Smalltalk.

### Constraints
Между фигурами на чертежах устанавливались определенные отношения. Например, можно было обозначить две линии отдельной фигуры параллельными, чтобы независимо от последующих манипуляций (повороты, уменьшение, увеличение экземпляров) это свойство гарантированно сохранялось. За сохранение таких отношений - атомарных ограничений - отвечал отдельный процесс.

За управление объектами, своевременное и правильное применение процедур к ним и т.п. отвечал процесс "разрешения ограничений", который решал динамическую задачу, когда задача по манипуляции фигурой ставилась действиями пользователя. То есть, пользователю нет необходимости явно задавать все шаги, нужные для правильного поворота экземпляра, достаточно просто обозначить свое намерение посредством интерфейса программы, и "решатель" запускал все нужные процедуры в правильной последовательности. Такая "непроцедурная" система описания программ стала одним из самых ранних примеров декларативного программирования.

### Абстрактный тип данных
В системе Sketchpad была определена иерархия - "вселенная" - возможных объектов: скаляров, точек в системе координат, строк текста и т.д. Возможные ограничения тоже формировали одну ветку данной иерархии. Все элементы данной иерархии описывались структурами данных в памяти программы. Все они имели общие свойства, но также каждый тип объекта имел уникальные свойства, которые отличали его от других типов объектов. Так, все структуры содержали поле "тип", для динамического определения типа текущего экземпляра; поле "имя" позволяло называть экземпляры; поле "вид" обозначало характер отображения; поле "дисплей" хранило процедуру ("подпрограмму") для отображения экземпляра; поле "движение" определяло процедуру для трансформаций на экране и т.д. Таким образом, в одной записи в памяти инкапсулировались и данные, и возможные операции над этими данными. 

Алан Кей понимал, что такой подход является хорошей моделью для его системы независимых объектов, которые можно комбинировать в любой конфигурации. На его вопрос Сазерленду: как тому удалось сделать первую интерактивную графическую программу, первый декларативный язык программирования и первую объектно-ориентированную систему - Сазерленд отвечал, что он просто тогда не знал, что это сложно.

Несмотря на это, у Sketchpad было одно свойство, которое Алан Кей не стал переносить в свою систему. Как он позже объяснял:

> "Еще одной важной системой, созданной в этот период, была Thinglab Алана Борнинга - первая серьезная попытка пойти дальше, чем Sketchpad. Алан придумал красивый подход к решению задач с ограничениями, в котором разрешающий процесс не обязан был быть всезнающим (т.е. не требовал знать состояние всей системы в каждый момент времени)."

Это важное замечание, которое дает представление о том, что Алан Кей считал критичным для дизайна объектно-ориентированных систем. Сокрытие данных было одним таким критичным свойством. Оно позволяло полностью отказаться от операций присваивания в языке и, как следствие, мотивировать программиста мыслить о программах в новой парадигме.

## SIMULA - Monte Carlo simulation language
> "SIMULA должен быть задачно-ориентированным языком, не компьютеро-ориентированным, даже если это подразумевает заметное увеличение работы, которую компьютер должен будет выполнять."

Это слова одного из разработчиков языка SIMULA, который разрабатывался в Норвегии начиная с 1962 года. Первоначально предназначенный для симуляции событий в сложных индустриальных системах (конкретней, в "сетях дискретных событий"), язык со временем превратился в систему, позволявшую создавать иерархии сущностей в рамках какой-то классификации. Язык был надстройкой для языка Algol 60, что в некоторой мере ограничивало возможности разработчиков компилятора для SIMULA (например, работа с памятью в Algol вынуждала выбирать не самые лучшие решения для реализации компилятора). Как говорил другой разработчик в том же 1962 году:
> "Уже сейчас понятно как описывать системы с очередями для событий в нашем Монте Карло компиляторе, и были разработаны концепции, позволяющие легко описывать большие **классы** ситуаций."

Слово "классы" стоит отдельно выделить, так как оно будет иметь большое значение для ООП в дальнейшем.

В первых версиях языка основным элементом дизайна был "процесс". Этот модуль был простейшим элементом в программе, и программа состояла из комбинаций процессов, взаимодействующих друг с другом. Процессы могли быть двух видов: станции (активные компоненты) или клиенты (пассивные компоненты).

        system <identifier> := <station list>
        station <identifier>;<statement>
        customer <customer list>
Клиенты можно было организовать в список:

        <identifier>(<list of characteristics>)[<upper limit of customers>] 
Станция состояла из очереди и сервиса (операций, которые описывали правила обращения и реализовались на языке Algol). Очередь -- это упорядоченное "множество" процессов, где идея множества повторяла похожую концепцию из языка Algol (condition variables), которые манипулировались двумя специальными операциями wait и signal. Сервисы представляли собой абстракцию "работы", а вся программа -- сеть (граф) сервисов.

Клиент состоял из переменных, которые выполняли роль его "характеристик". Все клиенты имели общую переменную "время" и общую процедуру "позиция", которые использовались для симуляций. Клиент создавался сервисом какой-то станции, после чего он передавался в очередь либо этой же, либо другой станции. Из очереди клиент попадает в сервис соответствующей станции. Если сервис не помещал клиент в одну из очередей, клиент удалялся.

Со временем множества были изменены таким образом, чтобы в них можно было хранить процессы любых видов. Это делалось с помощью указателей на процессы. Такое "абстрактное множество" было реализовано в виде связного циклического списка и стало основой обобщенных списков в языке. Дополнительным эффектом такого подхода была возможность хранить один и тот же процесс в разных списках одновременно, используя ссылки ("элементарные объекты") на него.

Эти изменения потребовали отказаться от коцепции "сети сервисов", что сделало необходимым инкапсулировать все данные в соотвествующем процессе.

    inspect <process reference>
        when passenger do ...
        when staff do ...
        otherwise ...
Система стала коллекцией процессов вместо графа событий и переходов между ними. Каждый процесс был отдельным объектом в памяти. Процессы хранились на стеке, а стек в Algol был не очень удобен для работы таких программ. Программы описывали параллельные процессы, которые на стеке не могли выполняться параллельно. Для решения этой проблемы была написана новая система выделения памяти, где вместо одномерного стека память выделялась в двумерном массиве-таблице. Это позволило создавать процессы не просто как структуры данных, а как полноценные подпрограммы, которые были легко параллелизуемы.

        system Airport := arrivals, counter, fee collector, control, lobby;
        customer passenger (fee paid) [500];
                Boolean fee paid;
        station counter;
        begin accept (passenger) select:
                (first) if none: exit;
                hold (normal (2, 0.2));
                route (passenger) to:
                        (if fee paid then control else fee collector)
        end;

Основным итогом этих переработок стало то, что операции и данные хранились вместе, инкапсулированные в единый процесс.
> "Данные и операции над ними должны быть вместе, и самые полезные модули в программах содержат и то, и другое."

Так как процессы обращались друг к другу напрямую, необходимо было переделать механизмы доступа к атрибутам процесса. Была заимствована идея "классов-записей" "Тони" Хора, которую разрабатывали для Algol. Компилятор проверял доступность характеристик процесса через наличие правильной ссылки, Во время работы программы к ссылкам на процесс имели доступ его подпроцессы ("подклассы").

Это навело разработчиков на мысль, что те или иные процессы часто входят в отношения с другими процессами, и эти отношения имеет смысл описывать в программе заранее. Природа этих отношений заключалась в доступности характеристик для подпроцессов, то есть, несколько подпроцессов могло читать значения атрибутов родительского процесса.

Эти изменения привели к тому, что язык эволюционировал в новую версию, более общего назначения, чем просто язык для индустриальных симуляций. Дополнительно в язык был добавлен сборщик мусора, заимствованный из языка Lisp. Это дало возможность назначать стартовые значения для атрибутов процесса при его создании и очищать память, занятую процессом при его удалении.

Механизм параметризации операций не удовлетворял разработчиков компилятора в полной мере, поэтому было принято решение использовать отношения между процессами и подпроцессами для определения типов параметров. Все это в совокупности привело к возникновению понятий "класс" и "подкласс" в языке.

        class Point; real x, y;
        begin
        boolean procedure equals(p); ref(Point) p;
                if p =/= none then 
                equals := abs(x - p.x) + abs(y - p.y) < 0.00001;
        real procedure distance(p); ref(Point) p;
                if p == none then error
                else distance := sqrt((x - p.x)**2 + (y - p.y)**2);
        end

Подклассы процессов представляли собой описания со своими собственными операциями и локальными данными (аналогично объектам-функциям в Lisp).

      class Page;
      begin
         class Print_Block(Width,Length);integer Width, Length;
         begin
            ref(Print_Block)Next;
            text array Contents(1:Length);
            integer Count;
            for Count:=1 step 1 until Length do Contents(Count):-Blanks(Width)
         end--of--Print_Block;

         Print_Block class Title_Block(Title);text Title;
         begin
            Contents(Length//2):=Title
         end--of--Title_Block;

         Print_Block class Text_Block;
         begin
            for Count:=1 step 1 until Length do
            begin
               InImage;
               Contents(Count):=Intext(Width)
            end
         end--of--Text_Block;
      end..of..Page;
      new Page;

Общие свойства классов можно было группировать так, чтобы они применялись позднее, т.о. можно было описывать программы, в которых определение свойств не было известно заранее. Для поддержания этой системы был реализован механизм "виртуального класса". Этот механизм был необходим для предоставления доступа к операциям объекта: параметр (операция) объявлялся на уровне самого верхнего класса; определение параметра включалось в объект подкласса. Такой подход позволял получать обобщенные объекты, поведение которых было частично не определено в ходе работы программы, и которое можно было динамически заменить. Так, в зависимости от используемого подкласса поведение объекта из семейства подклассов могло отличаться. 

Для иллюстрации этой идеи можно использовать знакомый механизм в языке С:

        struct Point {
                double x, y;
                bool (*equals)(struct Point *this, struct Point *p);
                double (*distance)(struct Point *this, struct Point *p);
        };

        bool procedure_equals(struct Point *this, struct Point *p) {
                if (p != NULL) {
                        return (fabs(this->x - p->x) + fabs(this->y - p->y)) < 0.00001;
                }
                return false;
        }

        double procedure_distance(struct Point *this, struct Point *p) {
                assert(p != NULL);
                return sqrt(pow(this->x - p->x, 2) + pow(this->y - p->y, 2));
        }

        int main(void) {
                Point p    = {.x=1, .y=1};
                p.equals   = procedure_equals;
                p.distance = procedure_distance;
        }

Минусом такого подхода было то, что правила замены невозможно было проверить во время компиляции программы.
