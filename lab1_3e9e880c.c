/*
Лабораторная работа 1 - Абстрактные типы данных

Для своего варианта (варианты смотрите в приложении 1) с помощью структуры необходимо реализовать абстрактный тип данных, который будет скрывать указатель на базовую коллекцию данных (массив, список, дерево и т.д.), избавляя пользователя от необходимости работать с указателями напрямую для получения данных из коллекции.

Функция make_empty не имеет параметров, возвращает объект заданной структуры с внутренними полями, установленными в правильные значения по умолчанию.

Функция make_of_size имеет один параметр – целое беззнаковое число, которое указывает на желаемый размер коллекции, которую необходимо создать. Функция возвращает объект заданной структуры с внутренними полями установленными в правильные значения для того, чтобы сохранить созданный в функции контейнер.

Функция make_from_array имеет два параметра: указатель – адрес массива целых чисел, целое беззнаковое число – размер этого массива. Функция должна создать контейнер такого же размера, содержащий те же значения, что и массив-аргумент функции. Функция возвращает объект заданной структуры с внутренними полями установленными в правильные значения для того, чтобы сохранить созданный в функции контейнер.

Функция make_copy имеет один параметр – объект заданной структуры. Функция создает идентичную копию (deep copy – изменение копии объекта не должно изменять первоначальный объект) заданной структуры и возвращает объект заданной структуры с внутренними полями установленными в правильные значения.

Функция clear имеет один параметр – ссылку на объект заданной структуры, функция ничего не возвращает. По ссылке необходимо освободить память, занимаемую контейнером и установить поля объекта в правильные значения. Все существующие на момент вызова указатели становятся недействительными. Асимптотичность функции линейная – O(n).

Функция is_equal имеет два параметра – два объекта заданной структуры, которые необходимо сравнить.

Функция возвращает “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их контейнеры. Контейнеры равны, если они содержат равное количество элементов, а также – если значение каждого элемента одного контейнера равно элементу другого контейнера на том же месте.

Функция at имеет два параметра: объект заданной структуры и целое число (которое может принимать отрицательные значения). Функция возвращает элемент массива из переданной структуры, находящийся по индексу, заданному вторым аргументом. Если второй аргумент отрицательный, необходимо предварительно преобразовать его в соответствующее положительное число, в зависимости от размера массива. Если значение второго аргумента не входит в диапазон возможных индексов массива, необходимо вернуть элемент массива, находящийся на первом или последнем месте, в зависимости от знака индекса. Так для списка {1, 3, 5, 7, 9} аргумент со значением 1 вернет второй элемент (3), аргумент со значением -1 вернет последний элемент (9), аргумент со значением 10 также вернет последний элемент, а аргумент со значением -10 вернет первый элемент (1).
*/

#include <assert.h>
// остальные необходимые библиотеки здесь

typedef enum
{
    false,
    true
} bool;

typedef struct
{
    // необходимые поля с данными здесь
} abstract_data_t;

// рекомендуемые прототипы функций:
abstract_data_t make_copy(const abstract_data_t *);
abstract_data_t make_from_array(const int[], size_t);
abstract_data_t make_of_size(size_t);
abstract_data_t make_empty();
void clear(abstract_data_t *);
int at(const abstract_data_t *, int);
bool is_equal(const abstract_data_t *, const abstract_data_t *);

// код для проверки правильности выполнения задания:
int main(int argc, char const *argv[])
{
    int array[] = {1, 4, 7, 9};

    abstract_data_t a = make_from_array(array, 4);

    assert(9 == at(&a, 3));
    assert(9 == at(&a, -1));
    assert(9 == at(&a, 13));
    assert(1 == at(&a, -13));

    abstract_data_t b = make_copy(&a);

    assert(is_equal(&a, &b));

    clear(&a);
    clear(&b);
}
