# Введение
Сложно сказать когда именно фраза “объектно-ориентированный” была впервые применена в контексте компьютерной программы, но доподлинно известно, кем и почему это было сказано.  Математик Алан Кёртис Кей, который работал в исследовательской лаборатории PARC корпорации Xerox, занимался проектированием и реализацией экспериментальных компьютерных систем, в связи с чем ему приходилось работать с новыми компьютерными разработками и новыми языками программирования. В 1967 году, под впечатлением от компьютерной системы Sketchpad, языка программирования Simula и нескольких маленьких экспериментальных проектов Кей начал работу над собственной системой FLEX, которая включала в себя высокоуровневый язык программирования на базе компилятора, реализованного на микросхеме. Основной целью проекта было создание такой системы, которая была бы легче в освоении, чем существовавшие на тот момент компьютеры и операционные системы, поддерживавшие языки программирования Fortran и Algol. Ядро системы составлял “процессо-ориентированный” подход к написанию программ.

По задумке Кея на любом компьютере процессы должны выполняться параллельно, так как разные задачи напрямую друг от друга не зависят, а следовательно и не должны друг друга блокировать. Например, ввод или вывод данных никак не связан с обработкой не зависимой от этих данных информации. Отсюда возникла необходимость дать программисту самому возможность создавать параллельные процессы в своих программах. То есть, создание параллельных процессов  должно быть составной -- основной -- частью самого языка программирования. Это позволяет писать программы разной степени сложности, используя рекурсию, “события” и процессы для описания таких программ.

Алан Кей часто приводил в качестве примера такой системы сеть "Интернет", в которой отдельные компьютеры могут взаимодействовать друг с другом только посредством отправки сообщений другим компьютерам, оставаясь независимыми вычислительными объектами, данные которых скрыты от остальных компьютеров в одной с ними сети. В этом заключалась сущность “объектов” в контексте системы, проектируемой Кеем. Объект изначально – это описание вычислительного процесса или семейства процессов, которое скрывает свои данные от внешней среды и может работать независимо от других объектов, взаимодействуя с ними с помощью сообщений, отправленных согласно какому-то протоколу. Концепцию “объектно-ориентированного подхода” в программировании примерно тогда же первым начал использовать в своей работе именно Алан Кей. Как он говорил намного позже, 

 > “Одним из идеалов в 1960-х для вычислительных систем было не просто использовать их в сфере образования, а создать новое мышление, которое стало необходимым после индустриальной революции с появлением проблемы масштабирования в контексте человеческого бытия. Эйнштейн заметил, что мышление, которое создает для нас проблемы, не поможет нам решить эти проблемы. Нужно другое мышление. Это глубокая мысль!”

Данная цитата может служить лейтмотивом этого курса. Похожую мысль высказал другой известный компьютерный инженер, лауреат премии имени Алана Тьюринга Джон Бакус.

>  “Широко распространенные сегодня языки программирования становятся все больше, но при этом не становятся мощнее. Врожденные дефекты в самом основании делают их опухшими и слабыми: примитивный стиль программирования, унаследованный от своего общего предка – компьютера Фон Неймана, сильная привязка семантики к изменениям состояний в памяти, разделение всего программирования на мир выражений и мир утверждений, невозможность эффективно использовать мощные инструменты для комбинации существующих программ в новые, отсутствие в них полезных математических свойств – для того, чтобы делать правильные умозаключения о компьютерных программах.”

Обе цитаты особо подчеркивают необходимость нового способа мышления для написания хороших компьютерных программ. Объектно-ориентированное программирование было попыткой сделать такое мышление более естественным и оттого – более распространенным. Одной из основных целей данного курса как раз и является обоснование необходимости и важности такого подхода к программированию программного обеспечения. 

1. За последние 50 лет в рамках объектно-ориентированной парадигмы было написано огромное количество кода.
2. Многие современные языки программирования были спроектированы вокруг идеи “объектно-ориентированности”.
3. Многие популярные идиомы (приемы), используемые в дизайне языков программирования или в конечных программах, пришли из объектно-ориентированного дизайна.
4. Многие компании, производящие программное обеспечение, зациклены на объектно-ориентированном дизайне и требуют его знания и применения от своих разработчиков.
5. Объектно-ориентированный дизайн требует особого подхода к архитектуре приложений.

То есть, объектно-ориентированный подход требует от пользователя нового образа мышления, который позволяет смотреть на решение каждой задачи не как на список инструкций для компьютера, а как на описание семейства объектов, взаимодействующих друг с другом согласно установленным правилам. Из их взаимодействия уже рождается нужное решение. 
## Модели исчисления
Такое мышление должно начинаться с модели исчисления, которая будет применяться для решения конкретной задачи. Моделями исчисления могут быть как чисто абстрактные модели (математические), так и хард-модули (физические), а также языки программирования. Сам Бакус выделял четыре критерия оценки любой модели исчисления:
1. Наличие математического обоснования (формального описания).
2. Наличие системы хранения состояния (истории).
3. Семантический тип (поведение).
4. Ясность и полезность.

Если первые три критерия относятся к эффективности программ при решении задач, то последний подчеркивает важность человеческого аспекта программирования: выражают ли программы процесс исчисления ясно; воплощают ли программы концепции, которые помогают формулировать процессы.

Согласно этим четырем критериям Бакус категоризовал модели исчисления следующим образом.
1. Простые модели.
2. Аппликативные модели.
3. Фон-Неймановские модели.
4. Все остальные модели.

Первая категория содержит “машины Тьюринга” – простые конечные автоматы, позволяющие описывать вычислительные процессы с помощью дискретных состояний и переходов между ними. Вторая категория представлена лямбда-исчислением (далее, “λ-исчисление”), автором которого были математик Алонзо Чёрч и его студенты. Третья категория включает современные компьютеры, а также языки программирования, которые их симулируют: вычисления происходят на основе комбинации центрального вычислительного устройства, хранилища данных и соединяющего их провода – “шины”, пропускная способность которой выражена “машинным словом”. В рамках данного курса будут рассматриваться языки, относящиеся к одной из этих трех категорий.

В качестве решения Бакус предлагал новую парадигму программирования, которую он называл “функциональной”. По ходу данного курса станет очевидно, что “объектно-ориентированная” и “функциональная” парадигмы похожи друг на друга не только тем, что они преследовали одну и ту же цель, но и методами, которыми данная цель достигалась.

## Альтернативный стиль программирования
В качестве конкретного примера серьезной проблемы, которая преследовала императивные языки (к таким языкам относятся, в первую очередь, “ассемблерные” языки и те модели, которые их близко повторяют) стоит рассмотреть синдром “воронки Фон Неймана”. Конечное предназначение любой компьютерной программы – изменить данные в хранилище данных. Данные каждый раз передаются на центральное вычислительное устройство по проводу, при этом большая часть передаваемой информации – это адреса, по которым хранятся данные – метаданные. Так создается ситуация, в которой программист оказывается заложником “мышления по одному слову за раз”: каждая переменная изменяется отдельно, каждая инструкция выполняется отдельно, сама операция присваивания вынуждает изменять данные по отдельности. Как отмечал Бакус, “ присваивание делит программирование на два мира: мир выражений справа от присваивания и мир объявлений слева. Все полезные действия происходят в мире выражений”.

Более сложный пример, который приводит Бакус, состоит в решении задачи скалярного произведения двух векторов. Сама задача проста: получить скалярную величину, которая является суммой произведений значений из двух произвольных векторов (списков значений).
```Fortran
    c := 0
    for i := 1 step 1 until n do
        c := c + a[i] * b[i]
```
Каждая строка представляет собой какое-то утверждение. Каждое утверждение манипулирует состоянием данных в памяти, что никак не выражено в самом тексте программы, за исключением инициализации переменных c и i. Утверждения не структурированы в иерархию (то есть, нет прямого обозначения зависимостей между отдельными утверждениями, которое Бакус называет “синтезом”). Вместо этого используется повторное присваивание, что скрывает первоначальный замысел. Часть данных вводится в программу в качестве служебной информации с неочевидным намерением. Так, переменная n в заголовке цикла никак не привязана к другим значениям синтаксически, при этом она накладывает ограничение на размер обоих векторов, что лишает программу обобщенности (программа будет работать только для векторов такой длины).

Для контраста Бакус предлагает другое решение, заимствованное из мира абстрактной алгебры.
```Haskell
    (Insert +) ∘ (ApplyToAll *) ∘ Transpose
```
Для того, чтобы убедиться в эквивалентности этих двух решений, следует взять конкретные значения. Для двух списков: (1, 2, 3) и (6, 5, 4) – первое решение аккумулирует в переменной c сумму произведений пар значений. То есть, сумма пар (1 * 6), (2 * 5) и (3 * 4) равна 6 + 10 + 12 = 28.

Для тех же двух списков второе решение вычисляет результат немного иначе. Транспонирование матрицы, состоящей из этих двух списков даст три новых списка: (1, 6), (2, 5) и (3, 4). Затем, перемножение элементов каждого списка даст три скалярных значения: 6, 10 и 12. Наконец, сумма этих трех значений равна 6 + 10 + 12 = 28.

Оба решения дают один и тот же результат. При этом второе решение не использует невидимые состояния (нет переменных), выстраивает строгую иерархию (функциональная композиция, отмеченная оператором ∘ явно указывает на зависимость одних выражений от других), оперирует цельными концепциями (векторами произвольной длины, а не областями памяти), полностью обобщена (нет привязки к конкретным спискам или к конкретной длине списков).

Подытожить пример можно следующим образом. Функциональный стиль предлагает альтернативу тому, как можно представлять себе решения задач вычислимости. Такой стиль предлагает программисту вырваться из тесных рамок, которые ему навязывает архитектура компьютеров. Программирование можно и нужно рассматривать как продолжение алгебры, что дает полную свободу в выборе инструментов для решения задач. Забегая вперед, следует отметить, что Алан Кей предлагал свое решение, исходя из таких же предпосылок.

## λ-исчисление
Перед тем, как перейти к рассмотрению свойств объектно-ориентированного подхода, следует подробней ознакомиться с аппликативным методом вычисления, который стал предпосылкой к появлению как функционального, так и объектно-ориентированного программирования.

Для начала – основные инструменты вычисления, на которых основывается данная модель: функциональная абстракция, аппликация, редукция.

### Абстракция
Следующий простой пример содержит элементарное выражение, которое в совокупности представляет собой абстракцию какого-то вычисления.
```Lisp
    λx.x
``` 
или
```Lisp
    λ: x -> x
```
Переменная х слева от точки является функциональным параметром. Переменная x справа от точки является выражением, описывающим результат вычисления. Первоначальное выражение можно представить в виде функции одного переменного, где значением функции является ее аргумент.

### Аппликация
Само вычисление происходит посредством аппликации выражения к какому-то значению.
```Lisp
    (λx.x) (42)
```
или
```Lisp 
    λ: x -> x => λ(42) -> 42
```
Аппликация подразумевает подстановку значения в выражения в качестве аргумента. В примере выше для ясности первая пара скобок содержит само выражение, а вторая - значение. Аппликация выражения к значению “42” приводит к подстановке этого значения в параметр x и имеет своим результатом значение “42”.

### Редукция
Выражения можно комбинировать в любой последовательности.
```Lisp
    (λx.(λy.x)) (1) (2)
```
В данном примере результатом выражения будет другое выражение. Поэтому список значений справа потребляется по одному значению. Число “1” будет первым аргументом, следовательно результирующее выражение выглядит так: λy.1 – очевидно, что аппликация данного выражения к любому значению сводится к числу “1”, что и будет окончательным ответом. Процесс последовательного решения составных выражений называется редукцией.

Следующие три выражения являются насколько часто применяемыми, что у них есть общепринятые имена. 

| “тождество” | “истинность” | “ложность” |
| :-: | :-: | :-: |
| λx.x | λx.(λy.x) | λx.(λy.y) |

Интересны же они по другой причине, это стоит рассмотреть на отдельном примере.
```Lisp
((λx.x) (λx.(λy.x)) (λx.(λy.y)))
```
или
```Lisp
((тождество) (ложность) (истинность))
```
Три выражения описывают три концепции, которые часто используют для математических доказательств. Интересно же здесь то, как их можно комбинировать для вычислений. Имея комбинацию выражений в виде выражения: ((тождество) (ложность) (истинность)) – какой результат будет, если применить его к конкретному значению? Например, если значением будет другое выражение:
```Lisp
    ((тождество) (ложность) (истинность)) (истинность)
```
С помощью подстановки можно “раскрыть скобки” в выражении слева. Тождеством истинности является сама истинность, поэтому можно произвести следующую замену.
```Lisp
    (истинность) (ложность) (истинность)
```
или
```Lisp
    (λx.(λy.x)) (ложность) (истинность)
```
Внизу раскрыта абстракция истинности, чтобы можно было явно записать результат следующей подстановки. Процесс аппликации требует подставить ложность в выражение слева: λложность.(λy.ложность) -> ложность. Таким образом, последний этап редукции выглядит так.
```Lisp
    (ложность) (истинность)
```
или
```Lisp
    (λx.(λy.y)) (истинность)
```
Раскрыв выражение слева и подставив последний оставшийся аргумент: λистинность.(λy.y) -> y – полученное значение будет чем угодно, только не истинностью, а значит ложностью. Так, с помощью простейших выражений можно закодировать понятие логического отрицания.

В контексте объектно-ориентированного программирования λ-выражения интересны по нескольким причинам. В первую очередь, тем, что они являются основой для анонимных функций в языках программирования. Самые внимательные читатели должны были заметить, что и в языке С выражения производят значения по схожим правилам, так как компилятор следует определенному порядку (иерархии) для разрешения выражений. Наконец, λ-выражения иллюстрируют силу такого механизма, как функциональная абстракция, с помощью которого декларативно можно описать вычисление любой сложности. В подавляющем большинстве языков программирования семантика функций реализуется по той же схеме.

## Роль абстракций
Примеры выше должны показать, насколько важной концепцией является абстракция на всех уровнях. Если переменные являются абстракцией конкретных значений, обобщая значение, то функции являются уже абстракциями вычислений, обобщая процесс вычисления. 

Объектно-ориентированный подход, как будет показано далее в рамках этого курса, основан на идее абстракции уже функций и типов данных (аналогично функциональному подходу). Перефразируя Андрея Александреску, можно в качестве промежуточного итога сказать, что если в процедурном программировании появляется возможность определять функции и вызывать их, то в объектно-ориентированном программировании можно вызывать функции, которые еще не были определены, а в обобщенном программировании можно писать программы для типов данных, которые еще не были определены.

При этом обыденное (и очень широко распространенное) понимание термина “объектно-ориентированный” значительно отличается от первоначальной идеи Алана Кея. Язык С++ является одним из самых популярных “объектно-ориентированных” языков программирования, считается таковым большинством программистов, которых совсем не беспокоит мнение Алана Кея по этому вопросу. Таким образом образовывается очевидное противоречие в понимании данного термина, когда существует две условно равноценные трактовки.

Это противоречие снимается достаточно просто. Термин был стихийно адаптирован продолжателями идей, заложенных в язык Simula, с которым Алан Кей тоже работал. Важно то, что эти идеи в слегка измененном виде были приняты как основополагающие в процессе разработки многих языков программирования, в том числе и С++. Взрыв популярности С++ повлек за собой разработку языков-подражателей, которые должны были переманить разработчиков в новые “экосистемы”, и для усиления эффекта термин “объектно-ориентированный” использовался в качестве маркетингового приема. Путь объектно-ориентированного подхода разделился на две тропы, по одной шли приверженцы оригинальной идеи (которая была выражена в языке Smalltalk), по другой – стихийные последователи новой волны, стремительно набирающей популярность (язык С++).

Отсюда же возникли идеи ставить объектно-ориентированный подход в первую очередь при обучении программированию, выраженные, например, Дэвидом Грисом, "теперь, после того, как все эти ужасные языки (как С и С++) исчезли, мы можем учить правильно программировать. Используя язык Java мы учим людей наследованию, делегации и приведению типов перед тем, как учим их писать циклы." Такое мнение может показаться слишком категоричным, но оно во многом повторяет действительность разработки программного обеспечения. 

В качестве примера можно обратиться к анекдоту, рассказанному известным преподавателем из MIT Джеральдом Сассманом. В 1980 году он с коллегами разработал курс по программированию, а в 2000 году курс упразднили. Причиной, по его словам, стало то, что за последние 10 лет курс перестал соответствовать реалиям индустрии.
> Первоначально все делалось с помощью набора из процессора, инструкции к нему, 20 ножек на нем и одной странички текста, их описывающего, и этого идеально хватало. К концу 90-х появились процессоры с сотнями ножек, с инструкциями огромной толщины, авторы которой не знали содержимое чипа. Дизайнеры чипа не знали что будет включено в инструкцию, из-за чего пропала последовательность, к чему добавлялась проблема высокой секретности \[внутри компаний-производителей\]. В программировании происходило то же самое. К концу 90-х появились гигантские библиотеки для разных вещей, например, для графики -- с тысячами функций, которые сопровождались гигантскими руководствами с инструкциями. В середине 90-х я вдруг обнаружил, что мои студенты проводили большую часть времени, читая инструкции. Я понял, что инженеры будущего уже не будут создавать большие вещи из мелких вещей, комбинируя их и разбираясь, как каждая из них устроена (то есть, путем анализа и синтеза). Произошел сдвиг в сторону более научного подхода: берется какая-то библиотека и исследуется методом тыка. Пишутся программы, которые проверяют библиотеку, чтобы посмотреть на ее поведение, приговаривая, "могу ли я подкрутить ее, чтобы получить нужный результат?"  

Это стало причиной, по которой программирование на его факультете с того момента стали преподавать на языке Python.

Из этого примера видно, как новые абстракции в программировании играли все более важную роль с каждым десятилетием, и не совсем очевидно, было ли это вынужденной мерой в ответ на меняющиеся внешние условия или наоборот -- вызвано стихийным внедрением абстракций на всех уровнях программного обеспечения. Конечно же, объектно-ориентированное программирование во многом этому способствовало. Тем важнее разобраться в том, откуда этот подход пришел, и к чему он привел или еще может привести.