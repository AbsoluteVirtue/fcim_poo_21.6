# Полиморфные типы данных
## Определение "объектно-ориентированного подхода"
В 2020 году на одной из крупных конференций, посвященных языку С++, Джон Калб, программист из Microsoft/Amazon, сделал следующее заявление.

> Фраза "ООП" звучит как определение в себе, "это программирование, построенное вокруг объектов". Но если обратиться к соответствующей литературе или к академическому сообществу, там дадут совсем другое определение. ОО-программы почти всегда подразумевают использование каких-то отношений и иерархии наследования. Поэтому мое определение ООП в контексте С++, и это не обсуждается -- парадигма программирования в С++ с использованием полиморфизма, основанного на динамической функциональной диспетчеризации посредством виртуальных функций. 

Нетрудно себе представить, как такое определение может сформироваться под влиянием заявлений Бьярне Строуструпа, Роберта Мартина и др. Как правило, они на первое место ставят динамический полиморфизм и наследование. Удивляет то, с каким постоянством люди готовы игнорировать то, что об ООП говорил и говорит Алан Кей.

К чести Бьярне Строуструпа стоит отметить, что он с годами к термину "ООП" немного охладел.

> Я в думал и думаю до сих пор, что нет единого "правильного" способа писать все программы, и дизайнеру языка нечего заставлять программистов использовать определенный стиль. У дизайнера языка есть обязательство вдохновлять на и поддерживать разнообразие стилей и техник, которые показали себя как эффективные, и предоставлять возможности и инструменты, помогающие программистам избегать известных ловушек и проблем.

В этом создатели языка С++ преуспели.

    int c = 0;
    for (std::size_t i = 0; i < 3; ++i) c += a[i] * b[i];
    // или
    int c = std::inner_product(a.begin(), a.end(), b.begin(), 0);
    // или
    int c = std::ranges::fold_left_first(
        std::views::zip(a, b) | std::views::transform(
            [](auto t) { return std::get<0>(t) * std::get<1>(t); }), 
        std::plus<>());

Фрагменты выше представляют собой один и тот же алгоритм, написанный в трех разных стилях: структурном, "ОО", функциональном -- все три поддерживаются в С++. Стоит помнить, что современное программирование эволюционировало из трех высокоуровневых языков: Lisp, Algol и Smalltalk. Из первого выросла функциональная парадигма, из второго -- структурная парадигма, а из третьего -- объектно-ориентированная. Вдобавок, Lisp и Algol были первыми высокоуровневыми языками общего назначения. Их влияние на все современные языки огромно. Неудивительно, что в С++ за почти 50 лет с момента его создания постепенно перекочевали техники и инструменты из других влиятельных языков. 

Может создаться впечатление, что Строуструп прав, и стиль не имеет значения до тех пор, пока написанный код выполняет то, что задумано программистом. Но есть и другая сторона медали. Как сказал Алан Лавджой,

> Все языки программирования эквивалентны согласно принципу Чёрча-Тюринга. Какая тогда разница какой язык программирования использовать? Разница есть, потому что Тюринг описывал то, что можно вычислить, но не как быстро, и не как легко такое вычисление выразить в коде, реализовать, протестировать и выпустить в производство. Если вы не считаете, что нотация имеет значение, тогда подумайте о том, чем отличается арифметика римских цифр от арифметики арабских. Никогда не пробовали поделить в столбик, используя римские цифры? 

Эти два противоположных взгляда имеют прямое отношение к ООП. Как отмечал Джон Калб, ООП, в первую очередь, ассоциируется с динамическим полиморфизмом, которое достигается в С++ с помощью наследования и виртуальных функций. Но что он не стал говорить -- это наличие в языке других способов получить динамический полиморфизм, без использования наследования. В предыдущих частях обсуждалось об альтернативе наследованию -- шаблонах функций и типов, но они позволяют получить статический полиморфизм. Для динамического полиморфизма применяются дискриминированные типы.
## Карта объектно-ориентированного программирования
Чтобы попробовать понять, по какой причине ООП стал ассоциироваться с наследованием, а не с более общей (абстрактной) идеей динамического полиморфизма на уровне классов, стоит посмотреть на развитие парадигмы с "высоты птичьего полета". Основные источники, из которых Алан Кей черпал вдохновение -- это проекты, разрабатываемые в MIT, связанные с исследованиями искусственного интеллекта. В первую очередь это были идеи, непосредственно повлиявшие на создание языков Lisp и Algol, но параллельно с ними разрабатывались и другие технологии, самыми интересными из которых в контекте развития ООП были язык Logo и система Plex.

Алан Кей столкнулся с Logo и Plex еще до того, как стал работать над языком Smalltalk. Plex была идеей Дага Росса, который имел непосредственное отношение к развитию языка Algol: классы были внедрены в язык как непосредственная реализация идей Росса. С другой стороны, Сазерленд, работавший тогда над смежными проектами, заимствовал идею Plex для реализации Sketchpad. Параллельно Маккарти развивал теорию языка Lisp, которым Алан Кей позже активно пользовался. Как он сам говорил, наибольшее влияние на появление ООП как концепции имели: система Planner Карла Хьюита (на основе Logo), Sketchpad Сазерленда и Simula, которая была ответвлением Algol.

(тут диаграмма)

Т.о., абстрактные типы данных, оформившиеся как идея в ходе разработки языка Algol, приняли форму классов в ветке Simula, откуда были заимствованы в Smalltalk и С++ независимо друг от друга. При этом Smalltalk впитал в себя идею наследования поведения из Sketchpad и абстракции поведения из Lisp, когда С++ зациклился на идее наследования из Simula.

Т.е., объекты в Smalltalk и объекты в C++ первоначально были очень схожи, они описывали похожие концепции (инкапсуляция и абстракция поведения) и выполняли похожие задачи (реализация и композиция). Но если в Smalltalk фокус был на взаимозаменяемости объектов, в С++ упор делался на строгость системы типов. В обоих языках изначально классы были некими описаниями "замыканий" с возможностью предварительного определения всех блоков кода для них в виде списка методов, а объекты -- именованными замыканиями.
## Опять про динамический полиморфизм
Дискриминированные объединения (также называемые мечеными объединениями, дизъюнктными объединениями или типами-суммами) широко используются в языках программирования, в частности, в функциональных языках -- для достижения динамического полиморфизма. О возможности использования таких типов данных в дизайне языков говорил еще в 1966 году "Тони" Хоар.

> В какой-то момент программисту, как правило, понадобится выяснить к какому подклассу принадлежит запись, на которую ссылается переменная. Этого можно добиться с помощью конструкции, известной как дискриминатор класса записи.

Это было сказано по отношению к реализации системы типов в языке Algol. Как видно из цитаты, полиморфизм подтипов уже тогда реализовывался без наследования -- с использованием дискриминированных объединений. 

    record class expression (
        subclasses
            constant (real value);
            variable (string printname);
            pair ...
    );

    consider e when constant then ...
               when variable then ...
               when pair     then ...
Выше показан пример того, как эта идея реализовывалась тогда. Из интересного можно отметить использование слова *class*, а также встроенную в язык конструкцию для определения конкретного "подтипа". В одной из предыдущих частей иллюстрировался следующий пример. 

    enum tag { Circle, Line, ... };

    union types {
        Circle circle;
        Line line;
        ...
    };

    struct GeoObj {
        tag tag_;
        types type_;
    };

    void draw(const GeoObj& var) {
        switch(var.tag_) {
        case Circle:
            var.type_.circle.draw();
            break;
        case Line:
            var.type_.line.draw();
            break;
        case ...:
        ...
        }
    }
Заметно, что семантически идея здесь повторяет Algol практически полностью, но синтаксически значительно отличается, потому что С++ не предоставляет встроенный механизм разрешения задачи выбора правильного варианта типа данных. Это одна из причин, по которым подтипы было принято реализовывать через наследование абстрактного базового класса.

    struct GeoObj {
        virtual void draw() const = 0;
    };

    class Circle : public GeoObj {
    public:
        virtual void draw() const override;
    };

    class Line : public GeoObj {
    public:
        virtual void draw() const override;
    };

    void draw(const GeoObj& var) {
        var.draw();
    }
Синтаксически разница, на первый взгляд, значительна. Благодаря использованию виртуальных функций компилятор берет на себя принятие решения по вызову правильной реализации метода, исходя из типа данных объекта. То есть, вместо таблицы, написанной в месте вызова, пишется иерархия классов, которая отражается в виртуальной таблице, синтезированной компилятором. В результате, связь пользовательского кода с деталями реализации типа данных ослаблена, выбор происходит посредством интерфейса. Функция *draw* теперь обобщена.

Тем не менее, польза от этого минимальна, так как кроме обобщенной функции *draw* ничего не изменилось. С другой стороны, то, что правила выбора одного из вариантов скрыты, замысел разработчика перестает быть понятным конечному пользователю. Другими словами, общее количество написанного кода не изменилось, ответственность за выбор поведения была перенесена со стороны пользователя, который знает какого именно эффекта он хочет добиться, на сторону разработчика интерфейса, который не может знать, как именно его код будет использоваться, и вынужден предугадывать возможные сценарии. Пользователь же полностью зависит от доступных в интерфейсе методов. Т.е. он вынужден либо принимать всё, либо не использовать ничего.

Напрашивается вывод, что в Simula наследование не было изначально введено для достижения динамического полиморфизма, а стало так использоваться позднее уже в С++ с легкой руки программистов, которым нужен был "простой" способ добиться нужного эффекта каким-то путем, не связанным с мечеными объединениями, которые тогда широко применялись в других языках (включая Simula).

По этим причинам (удар по производительности и сложность семантики наследования) в С++ обобщенное программирование регулярно реализуется с помощью шаблонов.

    template <class GeoObj>
    void draw(const GeoObj& var) {
        var.draw();
    }
Как можно увидеть из нового примера, шаблоны позволяют избавиться от необходимости предварительно реализовывать все возможные варианты. Не нужна иерархия наследования, но исчезает динамический полиморфизм. Для большинства пользователей это не так важно, статический полиморфизм чаще предпочтителен, так как позволяет использовать систему типов языка для проверки правильности алгоритмов. 

Динамический полиморфизм все же является основополагающим принципом ООП, так как возможность свободно заменять любые объекты на любые другие с "экстремально поздним" связыванием типа аргумента намного легче достижима в динамическом контексте. Для таких случаев в С++ добавили специальный шаблон. 
## std::variant
Класс std::variant в С++ инкапсулирует обобщенное объединение, т.е. ему можно задать типы данных для всех возможных вариантов хранимых данных (откуда и название).

    std::variant<int, long, std::string> var;
    var.index();                // 0
    std::get<0>(var);           // 0
    std::get<int>(var);         // 0
    var = “hello”;             
    var.index();                // 2
    std::get<2>(var);           // “hello”
    std::get<std::string>(var); // “hello”
    var = 42;                   // var.index() == 0
    var = 77L;                  // var.index() == 1

В отличие от обычных объединений, std::variant обладает информацией о том, какой тип данных сейчас активен. И если задаются типы во время компиляции, то определяется текущий активный тип в ходе работы -- динамически. На примере выше показано, как это выглядит. Метод index указывает на тип активного объекта, метод std::get позволяет либо по индексу, либо по типу получить хранящееся значение.

    auto create_picture() {
        std::vector<std::variant<int, long, double, char>> p;
        p.push_back(42);   // p[0].index() == 0
        p.push_back('R');  // p[1].index() == 3
        p.push_back(.069); // p[2].index() == 2
        return p;
    }

Пример выше иллюстрирует гетерогенную коллекцию (вектор вариантов), каждый элемент которой может быть отдельным, не повторяющимся нигде в коллекции типом данных. Это пример динамического полиморфизма. Причем, нет необходимости использовать ссылки, умные указатели, базовый абстрактный класс и т.д. Работа с вариантом позволяет использовать значения напрямую.

Для сравнения с примером наследования, ниже представлен тот же самый интерфейс, но теперь уже реализованный с помощью std::variant. 
 
    using GeoObj = std::variant<Circle, Line, …>;
    void draw(const GeoObj& var) {
        switch(var.index()) {
        case 0:
            std::get<0>(var).draw();
            break;
        case 1:
            std::get<1>(var).draw();
            break;
        case ...:
        ...
        }
    }
Код организован как попытка воссоздать виртуальную таблицу вручную, и под таким углом преимущество *std::variant* над виртуальными функциями не так очевидно.
### "Visitor" pattern
Существует распространенный прием, который принято называть "посетителем", с помощью которого можно упростить пользовательский код, который зависит от *std::variant*.

    struct Visitor {
        void operator()(const Circle& c) const { c.draw(); }
        void operator()(const Line& l) const { l.draw(); }
    };

    void draw(const GeoObj& var) {
        std::visit(Visitor(), var);
    }
В новом примере роль виртуальной таблицы играет структура *Visitor*, которая реализует перегруженный оператор вызова "()" для всех типов данных, которые включаются в соответствующий *std::variant*. Стандартная функция *std::visit* принимает объект-посетитель в качестве первого аргумента и объект-вариант в качестве второго аргумента, организую динамическую диспетчеризацию автоматически, без необходимости описывать логику выбора нужной реализации на стороне пользователя (в данном случае -- в функции *draw*). 

Такая версия динамического полиморфизма и синтаксически, и семантически совпадает с версией, реализованной с помощью наследования от абстрактного базового класса. Преимущество такого метода в том, что он не использует наследование, соответственно -- не "тащит" за собой дополнительные правила, которые ассоциируются с наследованием. При этом нет необходимости создавать чисто виртуальные методы заранее, что позволяет определеять интерфейсы с большей гибкостью. Наконец, структуру посетитель писать не обязательно в тех случаях, когда реализации разных вариантов имеют общее поведение.

    void draw(const GeoObj& var) {
        std::visit([](const auto& x){ x.draw(); };, var);
    }
В новом примере стратегия посещения одинакова для всех вариантов и может быть выражена анонимным объектом-выражением, то есть функция *draw* остается обобщенной, объект *var* реализовывать метод *draw*, который не принимает аргументов, что соответствует аналогичному случаю с использованием шаблонов, описанному выше.
## Какой способ выбрать
Проводя промежуточный итог, были обозначены способы для создания обобщенных полиморфных функций.
### Виртуальные функции в иерархии наследования
Этот способ позволяет добиться позднего связывания засчет того, что компилятор сформирует таблицу всех возможных реализаций для конкретного интерфейса. Плюсом позднего связывания является то, что интерфейс представляет собой любой тип данных на момент вызова функции, а это значит, например, что коллекция ссылок на объекты, реализующие этот интерфейс, может состоят из разных объектов (гетерогенность). Минусом этого подхода является удар по производительности и неэффективное использование памяти, потому что необходимо хранить в программе сгенерированную виртуальную таблицу и обращаться к реализациям через ссылки, а не по значению, что мешает кэшированнию данных при обработке.

С точки зрения легкости в реализации это самый трудозатратный способ, так как разработчику необходимо предоставлять реализацию всего интерфейса, даже если в пользовательском коде нужно только подмножество методов. Другим минусом является то, что при изменении интерфейса придется менять все варианты реализации. Таким образом, особое внимание стоит уделять предварительному дизайну интерфейса, чтобы сократить необходимые манипуляции в будущем. При этом нужды будущего пользователя предугадать очень сложно.
### Шаблоны
Этот способ позволяет добиться статически проверяемого полиморфизма, что технически не является поздним связыванием, так как генерация кода для всех вариантов происходит на стадии компиляции. Несмотря на это, шаблоны практически не отличаются в том, как их используют, от абстрактных классов, потому что абстрактные классы не предполагают связывания значения аргументов с реализацией, которой не существует в интерфейсе, поэтому по-настоящему "поздним" предыдущий способ тоже не является.

Позднее связывание в том смысле, который вкладывал в него Алан Кей, подразумевает возможность получить какой-то результат даже в случаях, когда в интерфейсе нет подходящей реализации. В такие моменты runtime перехватывает управление вызовом и возвращает управление обобщенной функции после того, как убедится, что программа может продолжить работу (например, с помощью обработанного исключения). В языке С++ ни виртуальные функции, ни шаблоны не позволяют этого сделать. 

Минусом шаблонов является то, что они не позволяют создавать по-настоящему гетерогенные коллекции. Типы данных всех элементов коллекции должны совпадать, что не позволяет сделать код достаточно гибким. С другой стороны, шаблоны позволяют передавать в качестве реализации любой тип данных, который удовлетворяет всем ограничениям, которые определяются предусловиями, что является плюсом. Т.о. разработчику не нужно реализовывать какой-то абстрактный интерфейс полностью, чтобы его класс можно было использовать в качестве шаблонного аргумента. Достаточно того, чтобы класс реализовывал конкретные методы, нужные в отдельно взятом сценарии.

Другим существенным минусом шаблонов является то, что они вынуждают компилятор генерировать перегрузки функций для каждого сценария, который встречается в программе, что может значительно повлиять на время компиляции. Но многие разработчики предпочтут пожертвовать временем компиляции в пользу времени исполнения.
### Меченные объекдинения
Третий способ, который рассматривался в этой части, позволяет создавать семейства типов как интерфейсы без необходимости генерировать виртуальную таблицу и использовать ссылки. Это положительно влияет на производительность, так как весь код, описывающий интерфейс и его реализации, определяется статически. При этом, в отличие от шаблонов, здесь сохраняется динамическое связывание, т.к. реализация подбирается в момент вызова из списка реализаций. Более того, можно включить способ реакции на несуществующую реализацию по умолчанию, что делает этот способ самым близким к оригинальной идее Алана Кея.

Минусами этого подхода являются: 
- необходимость определять все реализации интерфейса заранее (в отличие от наследования интерфейс, определенный как *std::variant*, нельзя расширять позднее, не затрагивая само определение);
- неэффективность при использовании памяти (т.к. интерфейс определяется с помощью объединения, размер каждого объекта этого интерфейса всегда будет равен размеру максимальной реализации);
- неэффективность при передаче по значению в качестве аргумента (вытекает из предыдущего пункта).

С другой стороны, преимуществ у данного способа предостаточно:
- не нужно использовать наследование;
- не нужно использовать виртуальные функции;
- не нужно использовать ссылки или указатели без прямой необходимости;
- не нужно использовать динамическое выделение памяти, так как экземпляры интерфейса хранятся на стеке;
- лучше для кэширования (вытекает из предыдущего пункта).

В конечном счете, выбор способа зависит от требований, так как все три позволяют определять обобщенные функции. Если нужно позднее связывание (необходимо определять поведение в момент вызова обобщенной функции, а не в момент компиляции), *std::variant* (или его более продвинутый аналог, см. std::polymorphic) является первым кандидатом. Если же динамический полиморфизм не нужен, шаблоны дают все остальные возможности, но с проверкой всех отношений в системе типов языка, что в некоторых сценариях критично.

Из примеров выше также можно сделать вывод, что ни один из этих способов не приближается к механизму динамического связывания, которая была в Algol ("pattern matching").

    consider e when constant then ...
               when variable then ...
               when pair     then ...
Этому есть объяснение.
> The Simula67 INSPECT statement was deliberately not introduced into C++. The reason for that is to encourage modularity through the use of virtual functions.

Т.е., несмотря на то, что в те годы такой подход считался если не обязательным, то общепринятым, авторы языка С++ от него намеренно отказались, так как он требует явно указывать все типы, участвующие в подстановке при диспетчеризации, что прямо влияет на семантическую связанность компонентов (нельзя добавить новый тип, не изменив интерйфейс и не прописав для него реализацию). Хотя *std::variant* в комбинации с *std::visit* максимально близко к этому подошел, в языке нет встроенного механизма, который можно внедрить в свой код без необходимости подробно описывать все определения.

Есть альтернативный способ получить полиморфное поведение, который называется type erasure, но его реализация в языке С++ выходит за рамки данного курса (стандартный шаблон *std::function* использует этот подход для своей реализации).
## Что такое ООП
На данном этапе курса можно попробовать ответить на вопрос, "что такое ООП?"

Для начала можно вспомнить, что говорил Алан Кей, когда ему задавали этот вопрос.
> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.

Т.о., по его мнению, важнейшие свойства любой системы, которая называется "объектно-ориентированной":
- описание программы как истории коммуникации объектов друг с другом, программа -- это процесс обмена сообщениями между равнозначными компонентами;
- инкапсуляция -- локальность, защита от изменений извне, сокрытие -- состояния объекта;
- позднее связывание (т.е. определение поведения в момент ответа на сообщение, полученное от другого объекта).

В такой системе каждый объект должен быть полноценным интерпретатором, т.к. заранее неизвестно от каких объектов и какие сообщения будут к нему поступать. Единственным языком, существовавшим на тот момент, который удовлетворял этому требованию, был Lisp, и Алан Кей говорил, что одной из первых целей, которую он перед собой ставил в начале работы над собственным языком, была реализация идеи "мета-языка", реализованной в Lisp. Единственное, что ему мешало -- сложность в понимании того, как именно это реализовывалось в Lisp. Smalltalk стал результатом этих изысканий, когда Алан Кей изолировал то, что он считал основополагающей идеей в дизайне Lisp, и развил ее в масштабе целой системы. Про такие системы Алан Кей говорил, что -- это "просто абстрактные представления сложных систем". ООП -- это обобщенное определение желаемой системы. Другими словами, ООП -- это идея Lisp, доведенная знающими людьми до абсолюта, позже подобранная посторонними людьми и доведенная до абсурда.
### Еще раз про инкапсуляцию
В определении выше инкапсуляция занимает одно из главных мест. Что не заявляется в определении, а только подразумевается -- где должны пролегать границы инкапсуляции. Принятая сегодня модель проводит эти границы вокруг данных. И в цитате выше Алан Кей особое значение придает тому, как организуются данные. Но что он здесь не уточняет -- это какова конечная цель инкапсуляции в ООП системах. 

Инкапсуляция диктуется соображениями относительно того, где нужно усложнить доступ к сущности и где -- упростить. Алан Кей, в первую очередь, агитировал за "исчезновение данных" в рамках системы. Под "исчезновением" он подразумевал такой стиль программирования, при котором разработчику не нужно думать о промежуточных данных в программе. Это достигается засчет написания программы таким образом, чтобы вся программа описывала последовательность шагов, которые нужно пройти, чтобы из начального состояние прийти в конечное. Тогда и переменные могут стать ненужными, потому что промежуточное состояние необязательно рассматривать в каждый конкретный момент.

Именно это и было первоначальной причиной, по которой Алан Кей отказался от структур данных и "абстрактных типов данных" в пользу объектов: его цель заключалась не в разделении программ на модули, которые содержат и данные, и поведение, а в создании сущностей, которым данные не нужны в принципе. Это возможно в Lisp благодаря функциональной композиции, которая возволяет определять функции со своими замыканиями, только используя существующие функции. Smalltalk взял эту особенность языка Lisp и пошел с ней дальше. 
> Bob Balzer wrote a pretty nifty paper called “Dataless Programming”, and shortly thereafter John Reynolds wrote an equally nifty paper “Gedanken” in which he showed that using the lambda expressions the right way would allow data to be abstracted by procedures.

Вызов функций или методов удаленно (как это делается в С++ с помощью виртуальных функций) -- это не ООП, а результат неправильно расставленных акцентов в том, как разграничивать доступ к элементам в программе. Отсюда пошла тенденция группировать данные и методы, работающие с ними, внутри класса, но это не то, как инкапсуляция применялась в ООП изначально. Отсюда же пошла тенденция разрабатывать классы относительно того, какая область применения у конкретной программы (как говорил Марк Лебланк, "ООП зациклилось на построении скомпилированных иерархий, отражающих область применения"). ООП не предполагает, что область применения точно отражена в коде (включая иерархию наследования), ООП предполагает, что с точки зрения пользователя область применения точно отражена в результате.

В конечном итоге, система, соответствующая ООП парадигме:
- поддерживает функциональную композицию для того, чтобы скрывать промежуточное состояние программы от пользователя (инкапсуляция);
- поддерживает аргументы любых типов данных для того, чтобы объекты в цепочке сообщений можно было свободно заменять или переставлять местами (полиморфизм);
- позволяет написать программу любой сложности с использованием любых объектов; т.е., объекты должны одинаково правильно обрабатывать сообщения разных "типов", при этом правильный результат зависит только от контекста (позднее связывание).

Эти свойства были взяты из Lisp и заложены в основу Smalltalk, который стал следующим шагом на пути к легко компонуемым системам, которые стали называть "объектно-ориентированными". С++ пошел по другому пути, но это не значит, что на нем нельзя писать ОО-программы. Язык С++ позволяет писать ОО-код, потому что он поддерживает три свойства, описанных выше, но синтаксис и идиомы С++ не мотивируют разработчика писать программы согласно "настоящему" ООП.
> The people who liked objects as non-data [...] were involved in one way or another with the design of ARPAnet->Internet in which the basic unit of computation was a whole computer.