# Функциональное программирование
> What I loved so much about OOP [...]is that it’s composable. If there’s one thing you should remember [is that] composability is the most important thing in programming.

Решение любой сложной задачи можно свести к серии простых задач. Тем не менее, это подразумевает, что простые решения легко компонуются в одно сложное решение. ООП как парадигма должно было стать инструментом декомпозиции и рекомпозиции программ как раз с той целью, чтобы одного набора простых решений хватало на создание новых решений любой сложности.

При этом, существует категория задач, которую решить таким образом с помощью ООП сложно. Объекты плохо подходят для многопоточного (конкурентного) программирования, так как они скрывают все детали реализации, в том числе и те, которые нужны для правильной синхронизации потоков. Например, ссылочные значения внутри объектов не должны принадлежать нескольким объектам одновременно, что в контексте многопоточного процесса может вызвать условие для "гонки за данными". Это можно решить с помощью "взаимного исключения" -- запирания данных в момент любого доступа, но это делает объект трудным для использования в совокупности с другими проектами.

Функциональное программирование как парадигма решает те же самые задачи. Но делается это не засчет создания объектов, а с помощью обогащения функций некоторыми свойствами, которые делают сами функции полноценными объектами без необходимости хранить данные, что сразу снимает проблемы, присущие "классическим" объектам.

Это подразумевает, что функция может участвовать во всех выражениях и как конкретное значение, и как интерфейс, и как единица вычисления. Благодаря такому подходу функции можно бесконечно компоновать друг с другом, так как любая функция элементарно адаптируется под любой интерфейс -- т.е. становится возможным решение и тех задач, которые решаются с помощью ООП, и тех задач, которые ООП решить не в состоянии.
## Функции и их свойства
Математический смысл функции можно условно свести к тому, что это некое соответствие между двумя значениями из какого-то множества или множеств. Например, запись *2->4* означает, что есть какое-то правило, по которому число 2 может измениться на число 4, тогда функцией будет стрелка между ними, указывающая на направление изменения. Стрелкам удобно давать различные имена. Тогда запись можно сделать более знакомой: *f(2) = 4*, здесь функция обозначается через символ f, его применение к аргументу "2" производит значение "4".

В программировании принято использовать похожую форму записи. Но не во всех языках функции обладают теми же свойствами, что и математические функции.

    int prod (int a[], int b[]) {
        int c = 0;
        for (unsigned long i = 0; i < n; ++i) c += a[i] * b[i];
        return c;
    }
Выше показан уже знакомый пример произведения двух векторов a и b. Это не является функцией в привычном понимании, так как код перечисляет последовательность выражений, каждое из которых было бы функцией. Это, скорее, процедура, которая имитирует функцию все по тем же причинам -- чтобы ее можно было легко компоновать с другими такими же процедурами.

    auto prod (const auto& a, const auto& b) {
        return std::inner_product(a.begin(), a.end(), b.begin(), 0);
    }
Такой вариант уже больше похож на настоящую функцию. Символ *prod* всего лишь "оборачивает" правило *inner_product*, которое является выражением, производящим значение функции. Но, конечно, *inner_product* является процедурой.

    fun prod (a, b) =
        if a = [] orelse b = []
        then 0
        else hd a * hd b + prod(tl a, tl b)
Наконец, такая версия является максимально приближенной к тому, чем функции являются в математическом смысле. Это пример, написанный на языке Scheme, синтаксис которого позволяет описывать λ-выражения. Данное выражение представляет собой описание таблицы соответствий примерно такого вида:

|a|b|prod
|-|-|-
|0|.|0
|.|0|0
|.|.|a<sub>1</sub> * b<sub>1</sub> + prod(остаток(а), остаток(b))

Т.е. для случаев, когда оба аргумента - не пустые множества, значением функции является произведение пары первых объектов обоих аргументов в сумме со значением функции для оставшихся объектов. Такая запись позволяет сразу увидеть значение функции в виде одного выражения, а не последовательности выражений.

Функциональное программирование позволяет описывать функции (и объекты) таким образом, чтобы запись включала в себя все правило для получения значения в одном выражении -- декларативно, что часто приводит к необходимости использовать рекурсивную форму. У такого подхода есть и преимущества (нет необходимости изменять состояние объектов, а значит нет препосылок для "гонки за данными"), и недостатки (аналогично выражениям в λ-исчислении большие функции очень тяжело читать и проверять на наличие логических ошибок).
## Функции как объекты
Язык С++ позволяет определять функции двумя способами. Первый способ -- в виде процедур -- заимствован из языка С. Второй способ -- в виде объектов -- появился в С++ позднее. Ниже можно увидеть пример обоих подходов.

    bool func_less_abs(double x, double y) {
        return std::abs(x) < std::abs(y);
    }

    struct less_abs {
        bool operator()(double x, double y) const {
            return std::abs(x) < std::abs(y);
        }
    };
Разница двух определений может быть не очевидна, но она достаточно существенна. В первом случае *func_less_abs* является обычной процедурой, которая возвращает значение выражения в место, из которого она вызывается. Во второй случае *less_abs* является стуктурой, которая может вернуть только копию себя посредством своего конструктора. Структура содержит в себе перегруженный оператор вызова, который позволяет использовать объекты стуктуры в качестве процедур.

    std::sort( a.begin(), a.end(), func_less_abs   );
    std::sort( a.begin(), a.end(), less_abs() );
### Класс std::function
Структура, которая автоматически определяет перегруженный оператор вызова "()", уже встроена в язык С++. Она определена в шаблоне класса *std::function*. Экземпляры этого класса могут хранить, копировать или вызывать любую цель, которая обладает свойствами *CopyConstructible* и *Callable*, что включает в себя как указатели на процедуры, так и структуры с перегруженным оператором вызова, так и λ-выражения.

    std::function<bool(double,double)> f = func_less_abs;
    // или
    std::function<bool(double,double)> f = less_abs();
    // или
    std::function<bool(double,double)> f = 
        [](double x, double y){ return std::abs(x) < std::abs(y); };
Пример выше показывает все три способа. Переменную *f* можно инициализировать с помощью указателя *func_less_abs*, с помощью объекта типа *less_abs*, с помощью соответствующего λ-выражения -- во всех трех случаях переменная будет хранить ссылку на вызываемую цель.

Например, уже имея знакомый вызов стандартной функции сортировки:
    std::sort(
        a.begin(),
        a.end(),
        [](double x, double y)
            { return std::abs(x) < std::abs(y); } );
его можно было бы заменить на эквивалентный:

    std::sort( a.begin(), a.end(), f );
Сама функция *sort* принимает любую цель, до тех пор, пока цель копируема и вызываема. Ниже приводится сокращенный вариант реализации стандартной функции *sort*.

    template <class RandomAccessIterator, class Compare>
    void sort(RandomAccessIterator first, RandomAccessIterator last, 
              Compare comp)
    {
        if (first == last) return;
        for (RandomAccessIterator i = first + 1; i != last; ++i) {
            if (comp(i, first)) {
                auto val = MOVE(*i);
                MOVE_BACKWARD(first, i, i + 1);
                *first = MOVE(val);
            }
            else unguarded_linear_insert(i, val_comp_iter(comp));
        }
    }
Здесь особенно интересен параметр *comp*. Из тела функции видно, что он используется в качестве двоичного предиката, который определяет если нужно менять местами два элемента рассматриваемой последовательности. Тип этого параметра определен как концепция (шаблонный параметр *Compare*), которую компилятор проверит при инстанциировании шаблона *sort*. Из условия *if* понятно, что данный тип должен быть вызываемой целью, которая принимает два аргумента и возвращает значение типа *bool*. Все три способа вызова *sort* , показанные выше, предоставляют объект, который удовлетворяет этим требованиям.

На примере использования всех версий вызываемых целей можно понять их принципиальное отличие. Если *func_less_abs* передается в виде указателя на процедуру стратегии сортировки, то *less_abs()* является локальным объектом, который конструируется во время инициализации аргумента-стратегии. 

Из этого есть другое важное следствие. Имя такой функции является типом данных, который подвластен всем правилам системы типов. А это значит, что он может участвовать в выражениях аналогично другим типам данных.

Еще одним интересным следствием является возможность возвращать такие объекты как результаты функций.
### Замыкание
Следует рассмотреть более сложный пример.

    auto f(auto x) {
        auto g = [=](auto y) {
            return x + y;
        };
        return g;
    }
Функция *f* возвращает копию объекта g, который определен там же. Тип такого объекта зависит от типа как параметра *x*, так и параметра *y*. Предполагая, что тип *x* и *y* -- int, объект g будет какой-то структурой с перегруженным оператором вызова, который принимает один аргумент типа int. Возникает закономерный вопрос: каким образом структура получает доступ к значению *x* каждый раз, когда необходимо инстанциировать объект такой структуры?

    auto a = f(1); // partial application
В этом фрагменте объект *a* представляет собой экземпляр структуры, описанной выше. Прием создания функций посредством других функций для откладывания последующего вызова называется "частичной аппликацией". Из определения структуры известно, что объект *a* можно вызвать, передав один аргумент произвольного типа:

    auto i = a(2); // full application
В данном случае можно ожидать, что значением переменной *i* будет результат выражения "1 + 2". Область памяти, которая хранит такую функцию вместе со всеми значениями, с которыми она была инстанциирована, называется замыканием. Из этого следует два важных свойства:
- функции, определенные таким образом, могут хранить конкретные значения в момент инстанциирования;
- выполнение таких функций можно откладывать, потому что конструирование соответствующего объекта только инициализирует нужные переменные, но не вызывает оператор "()". То есть, в отличие от процедур, функции-объекты в С++ используются в два этапа, что дает новые возможности при написании алгоритмов.
## Композиция функций
> Fractal composition: you build big things out of small things. That’s the fundamental principle of functional programming.

Функциональная композиция является важным свойством, которое позволяет определять новые функции, используя исключительно существующие функции. Формально это можно записать следующим образом:

    z = g ( y ) = g ( f ( x ) ) = g ∘ f ( x )
Здесь подразумевается то, что конечный результат при определении функции *z* выводится из последовательного приложения (аппликации) функции *f* к аргументу *x* и затем функции *g* к значению функции *f*.

Два важных свойства следует из данного определения:
- запись выражает некую последовательность ("императивный" характер вычисления), оставаясь при этом декларативной по форме;
- промежуточный результат (значение функции *у = f(x)*) исчезает из записи.

Таким образом, функции отвечают сразу двум требованиям: они легко компонуемы и они позволяют использовать инкапсуляцию. Другими словами, они также, как и ООП, позволяют писать программы, в которых детали реализации скрыты, а объекты (функции) взаимодействуют друг с другом только посредством передачи сообщений (аргументов).

Простой пример это иллюстрирует. Предположив, что есть набор легко компонуемых функций, эти функции можно комбинировать, чтобы получить более абстрактный интерфейс. Функции *to_lower* и *split* компонуются в любом порядке. Текст "The quick brown fox jumps over the lazy dog" можно либо сначала разбить на подстроки с последующей заменой всех заглавных букв на прописные, а можно сначала заменить все заглавные буквы на прописные, затем разбив текст на подстроки. Т.е. запись:

    split ( to_lower ("The quick brown fox jumps over the lazy dog") )
    // или
    split ∘ to_lower "The quick brown fox jumps over the lazy dog"
аналогична записи:

    for_each ( split ("The quick brown fox jumps over the lazy dog"), to_lower )
    // или
    to_lower ∘ for_each ∘ split "The quick brown fox jumps over the lazy dog"
Соответственно, оба варианта можно использовать в дальнейшем в качестве сервиса, который принимает строку и возвращает список преобразованных "токенов".

    service :: concatenate ∘ to_lower ∘ for_each ∘ split
    // или
    service :: concatenate ∘ split ∘ to_lower

    transform ( "The quick brown fox jumps over the lazy dog", service )
Сервисы точно так же можно "склеивать" вместе, получая "сценарий". Например,

    use-case :: sort ∘ transform
    // или
    use-case :: validate ∘ transform

    use-case ( "The quick brown fox jumps over the lazy dog" )
Склеивая сценарии можно получить полноценное приложение.

    app :: output ∘ process ∘ input
    process :: count ∘ sort ∘ transform ∘ validate

    app ( "The quick brown fox jumps over the lazy dog" )
Такой подход к написанию систем вынуждает программиста выстраивать сложные под-системы из более простых модулей.
## Композиция типов
Т.к. в функциональном программировании функции являются объектами первого порядка и реализуют интерфейсы, инкапсуляцию и т.п., для создания пользовательских типов данных классы использовать нет необходимости. Типы данных рассматриваются как конечные или бесконечные множества объектов. Например, тип *byte* может быть множеством, объектами которого являются все целые числа от -128 до 127. Тип *boolean* может быть множеством, содержащим всего два объекта: *true* и *false*. Остюда следует, что новые типы данных создаются тоже в виде множеств, включающих в себя другие существующие множества.

Между типами могут существовать отношения. Например, тип *void* представляет собой пустое множество, так как он не содержит никаких объектов. Это значит, что невозможно получить значение такого типа, не существует функции, которая возвращает значение типа *void*. При этом существуют функции, которые не принимают аргументов, но производят значения (например, конструкторы). Так, между пустым множеством и всеми остальными типами есть отношение, *void -> T*.

Напротив, если представить себе множество, которое состоит из единственного объекта (*unit*), существует группа отношений вида *T -> unit*, которая означает, что любая функция возвращающая единственное возможное значение может игнорировать тип аргумента (например, функция, возвращающая константу). Аналогично, есть группа отношений вида *unit -> T*.

Так, создание нового типа данных заключается в определении всех отношений этого типа данных с другими типами. Это значит, что новое множество определяется всеми возможными комбинациями отношений между всеми объектами соответствующего множества. Например, имея два множества: *{0, 1, 2}* и *{true, false}*, кобинация всех возможных элементов между ними выглядит так: *{ {0, true}, {1, true}, {2, true}, {0, false}, {1, false}, {2, false} }* -- декартовое произведение элементов двух множеств. Поэтому такие типы называются "типами-произведениями":
    
    // pair :: A * B
    template <typename A, typename B>
    struct pair {
        A a; B b;
    };
В С++ такой тип можно выразить в виде структуры. Для нового типа, состоящего из пар объектов двух других множеств *A* и *B* отношениями будут: два конструктора приведения (по одному из двух первоначальных множеств), конструктор по умолчанию, конструктор копирования, а также две функции, которые принимают пару и производят или значение типа *A*, или значение типа *B*.

Аналогично можно получить вид множества с помощью комбинации двух произвольных множеств (*A* и *B*) с помощью суммы: имея два множества: *{0, 1, 2}* и *{true, false}*, сумма всех возможных элементов между ними выглядит так: *{ 0, 1, 2, true, false }*. Т.о. "тип-сумма" может производить значения любого из множеств, с помощью которых он конструируется. В С++ такой тип можно выразить через объединение (например, шаблон *std::variant*).

    // variant :: A | B
    template <typename A, typename B>
    struct variant {
        union { A a; B b; };
        tag t;
    };
Стоит обратить внимание, что такое объединение должно быть совмещено с отношением, которое определяет тип текущего значения (либо всегда *А*, либо всегда *B*). 

Структуры типов, которые позволяют комбинировать существующие типы согласно этим двум правилам и всем сопутствующим свойствам, называются "алгебраическими". Можно было заметить, что произведение типов похоже на логическую коньюнкцию, а сумма типов -- на дизьюнкцию. По этой причине в некоторых источниках можно встретить другие названия: AND-тип и OR-тип. И действительно, если тип данных определен как *(int * bool)*, в объекте такого типа есть и значение типа int, и значение типа bool. Наоборот, если тип данных определен как *(int | bool)*, в объекте такого типа будет или значение типа *int*, или значение типа *bool*, но не оба сразу.
## Функциональная полнота
Ниже приводится пример простой функции, которая принимает целое число и возвращает целое число.

    int divide_twelve(int divisor) {
        switch (divisor) {
            case 3: return 4;
            case 2: return 6;
            case 1: return 12;
            case 0: return ???; // что возвращать в этом случае?
        }
    }
Функция *divide_twelve* должна возвращать результат деления числа "12" на какое-то другое целое число. Не все делители являются корректными, и выше показан пример одного такого делителя, "0". Для целых чисел результат деления на 0 не определен. Тем не менее, функция гарантирует, что во всех случаях возврата она производит значение типа *int*. Остается вопрос, что возвращать в случае, когда делитель равен нулю.

Первые несколько вариаций, которые можно себе представить, придется отбросить:
- кидать исключение;
- вернуть код ошибки;
- вернуть отрицательное число;
- вернуть "0".

Кидать исключение для таких функций не следует, т.к. исключение не является одним из элементов множества *int* (хотя, в С++ всегда можно кинуть целое число как исключение, но это так или иначе нарушит естественный ход программы). Код ошибки возвращать не следует, потому что он входит во множество *int* и никак не отличим от реального результата деления. Отрицательное число можно вернуть, так как для положительного делителя оно явно не может быть правильным результатом, но для отрицательного делителя оно перестает нести в себе дополнительный смысл.

Более простым решением будет ограничение множества всех входящих данных. Например, множество натуральных чисел не содержит отрицательных или "0":

    int divide_twelve(natural divisor);
В таком случае случаи с некорректным делителем не придется обрабатывать отдельно. Чуть более интересным решением будет расширение множества всех возвращаемых данных.

    std::optional<int> divide_twelve(int divisor) {
        switch (divisor) {
            case 3: return 4;
            case 2: return 6;
            case 1: return 12;
            case 0: return std::nullopt;
        }
    }
Здесь используется специальный тип, который может быть или целым числом, или пустым множеством. Пустое множество явно проверяемо и не несет никаких дополнительных смыслов кроме отсутствия правильного результата. В обоих случаях достигается важное свойство функций. В двух последних примерах функция становится "полной", в том смысле, что для всех входящих значений она обязательно производит корректное возвращаемое значение.
## Параметризация
В качестве очередного примера ниже приводится функция, которая выводит в терминал числа от 1 до 10. 

    void print() {
        for (const auto&& i : std::views::iota(1, 10))
            std::printf(“%i”, i);
    }
Недостатки такой функции уже должны бросаться в глаза. Она ничего не возвращает, при этом изменяет значение локальной переменной в цикле и не может выводить другие последовательности. Все эти недостатки можно исправить с помощью соответствующих параметров.

    void print(const auto& iterable) {
        for (const auto&& i : iterable)
            std::printf(“%i”, i);
    }
Теперь функция выводит любой подходящий диапазон (итерируемый объект) значений, при условии, что все значения будут целыми числами. Это ограничение тоже можно снять, сделав поведение параметром аналогично диапазону значений.

    void for_each(auto callable, const auto& iterable) {
        for (const auto&& i : iterable)
            callable(i);
    }
Функция *callable* теперь отвечает за правильность обработки элементов диапазона *iterable*, т.о. ответственность за совместимость двух параметров теперь лежит на вызывающей стороне. Осталось изменить тип возвращаемого значения. Сперва трудно представить себе, что следует возвращать в такой функции, но если предположить, что она должна быть легко компонуема с другими похожими функциями, нужно подумать о сценариях, в которых она чаще всего будет использоваться.

    const auto& for_each(auto callable, const auto& iterable) {
        for (const auto&& i : iterable)
            callable(i);
        return iterable;
    }
Польза параметризации объектов, которые требуются функции для работы, лежит не только в том, что они легче компонуются с другими функциями, но и в том, что функции становятся обобщенными, подходящими под разные случаи. Вот другой пример:

    int prod(int n) {
        int product = 1;
        for (int i = 1; i <= n; i++) product *= i;
        return product;
    }

    int add(int n) {
        int sum = 0;
        for (int i = 1; i <= n; i++) sum += i;
        return sum;
    }
В этих двух функциях большая часть кода совпадает. Если это заметить, можно прийти к их обобщенной версии. Например, отличается стартовое значение переменных-аккумуляторов, что легко поддается параметризации. Другое отличие -- арифметическая операция (в первом случае - сумма, во втором - произведение). Как и в других примерах, это поведение можно параметризовать, так как в обоих случаях -- это бинарная операция.

    auto fold(auto action, const auto& init, const auto& iterable) {
        auto total = init;
        for (const auto&& item : iterable) total = action(total, item);
        return total;
    }
Новая функция подходит теперь для обоих случаев, разница в поведении определяется передаваемыми параметрами.

    auto i = fold( std::multiplies<int>{}, 1, std::views::iota(1, 10) );
    auto i = fold( std::plus<int>{}      , 0, std::views::iota(1, 10) );
Библиотека *numeric* в языке С++ содержит набор похожих функций, которые подходят для большинства сценариев, например:
    
    std::ranges::fold_left_first( v.begin(), v.end(), std::plus{} );
Функция *fold_left_first* проходит по указанному диапазону слева направо, аккумулируя возвращаемое значение в переменной с помощью заданного оператора.
## Функции как интерфейсы
Интерфейсы, как правило, ассоциируются с классами и, реже, с наследованием. Особенно сильно это выражено в языке С++, где до введения в язык шаблонов интерфейсы было принято определять как абстрактные базовые классы в иерархии наследования. Из-за этого нелегко себе представить функции в роли интерфейсов. Ниже приводится простой пример для иллюстрации.

    struct abstract_less_abs {
        virtual bool less_abs(double x, double y) const = 0;
    };

    bool func_less_abs(double x, double y);
В данном случае есть абстрактный класс-интерфейс *abstract_less_abs* и функция *func_less_abs*. Так как интерфейс требует, чтобы реализация принимала два числа и возвращала результат типа *bool*, любая реализация из дочернего класса обязана иметь определение, которое с этим согласуется.

Ценность таких интерфейсов может показаться сомнительной, ведь он состоит всего из одной функции. Можно вспомнить некоторые из принципов SOLID, которые дают рекомендации по написанию интерфейсов. Например, принцип единственной ответственности утверждает, что у отдельно взятого модуля должна быть только "одна причина для изменения". То есть, произвольный интерфейс не должен содержать методы или функции, которые не служат одной и той же группе задач. С другой стороны, принцип разделения интерфейсов рекомендует создавать разные интерфейсы под разные нужды клиентов, чтобы изменение требований одного клиента не затрагивало параллельно созданные интерфейсы.

Из этого можно сделать неожиданный вывод: если оба этих принципа рассматривать в пограничных ситуациях, выходит, что лучшие интерфейсы -- это такие, которые содержат только по одной функции, как в примере выше. Сами функции являются интерфейсами: функции, его реализующие, требуют, чтобы аргументы соответствовали каким-то правилам; сами функции гарантируют, что вернут значение какого-то типа -- такими интерфейсами, которые содержат только одну функцию.

### Шаблон "Стратегия"
    class strategy {
        strategy(abstract_strat_t& st);
        int calculate(int x, int y) { return mst.less_abs(x, y) ? x : y; }
    };
Пример выше определяет класс, который использует интерфейс *abstract_strat_t*. Как в этой ситуации заменить класс на простую функцию, которая будет выполнять роль интерфейса? Реализовывать интерфейс не нужно, потому что любые две функции, которые имеют такой же заголовок, взаимозаменяемы.

    int   add(int x, int y) { return x += y; }
    int  mult(int x, int y) { return x *= y; }
    std::function<int(int, int)> interface_t;
В новом примере две функции принимают в качестве аргумента и возвращают один тип данных. Следовательно, в любой ситуации, которая требует такую функцию, любая из этих двух будет считаться правильной. Другими словами, объект *interface_t* можно инициализировать любой из этих функций.

Функцию из реализации в предыдущем примере можно вынести за пределы класса, сделав стратегию поведения одним из параметров. 

    int calculate(auto strategy, int x, int y) { return strategy(x, y); }
    calculate(add, 1, 2);
    calculate(mult, 1, 2);
При таком подходе не нужно определять интерфейс заранее, так как язык программирования проверит, что функция, которая используется в качестве стратегии поведения, соответствует требованиям к аргументу (принимаемые типы, возвращаемый тип).
### Шаблон "Декоратор"
Чуть более сложный пример представлен ниже.

    bool is_even(int);
    bool logger(auto f, int in) { 
        auto out = f(in); std::frpintf(log_file, "%d %d", in, out); return out; 
    }
    auto is_even_logged = [](int x) { return logger(is_even, x); };
Здесь используется тот же прием со стратегией, но теперь уже для добавления новой логики в существующий алгоритм. Первоначальная функция *is_even* выполняет какое-то вычисление. Появляется необходимость сохранять параметры и результаты вычисления каждый раз, когда вызывается эта функция.

Первый способ показан выше. Новая функция *logger* имеет параметр *f*, который будет стратегией, до и после вызова которой данные записываются в файл. Тогда новая реализация *is_even_logged* реализует тот же интерфейс, что и первоначальная функция *is_even*, но с дополнительными промежуточными операциями записи в файл.

Проблема такого способа в том, что он не очень хорошо компонуется. Желаемый результат должен выглядеть иначе.

    is_even_logged :: log ∘ is_even ∘ log
Второй способ заключается в том, чтобы "декорировать" любую функцию нужным поведением с нужной стороны, пользуясь функциональной композицией. В С++ нет аналогичного оператора (некоторые стандартные типы данных для композиции перегружают оператор "|"), но похожего эффекта можно добиться с помощью частичной апликации. 

    bool is_even(int); 
    auto is_even_logged = [](int x) { 
        return [](bool out){ std::frpintf(log_file, "%d", out); return out; }(
            is_even([](int in){ std::frpintf(log_file, "%d", in); return in; }(x))
        );
    };
    auto b = is_even_logged(5);
    // что аналогично
    int  log(int in)   { std::frpintf(log_file, "%d", in); return in; }
    bool log(bool out) { std::frpintf(log_file, "%d", out); return out; }
    auto b = log(is_even(log(5)));
Очевидно, что синтаксис языка С++ не располагает к написанию цепочек скомпонованных функций. Есть техники, позволяющие обобщить композицию функций с помощью шаблонов, но описание этих техник выходит за рамки данного курса, поэтому читателю предлагается познакомиться с ними самостоятельно.
## Currying
В примерах с композицией функций, которые появлялись до этого момента, была одна общая особенность, которую можно было заметить: композиция работает только для функций с одним параметром. Это существенный недостаток, который сводил бы на "нет" все преимущества композиции. К счастью, в функциональных языках все функции можно представить как функции одного переменного, поэтому в них композиция является универсальной операцией. Ниже будет показано обоснование этого правила.

Для начала нужно вспомнить, что в λ-исчислении все выражения имеют один параметр. Выражения, которые пишутся с двумя переменными на самом деле являются комбинацией двух выражений.

    λx.λy.x = λxy.x
Здесь первое выражение *λx.a* определено другим выражением *λy.b*, которое, в свою очередь, определено свободной переменной *x*. Это свойство можно использовать и в большинстве языков программирования. Такие примеры уже были выше, где рассматривалась частичная аппликация. Ниже будет еще один простой пример.

    auto add (auto x, auto y) { return x + y; }
    auto add (auto x)         { return [=](auto y) { return x + y }; }
    auto add ()               { return [](auto x, auto y) { return x + y }; }
Все три определения функции *add* позволяют получить один и тот же результат для одинаковых аргументов. В первом случае вызов функции будет производиться как обычно. Во втором и третьем случаях вызов функции вернет другую функцию, которую тоже нужно вызвать. Здесь особенно стоит выделить вторую версию функции.

    auto three    = add(1, 2);
    // но:
    auto plus_one = add(1);      // частичная аппликация
    auto three    = plus_one(2); // полная аппликация
    // или
    auto three    = add(1)(2);
Все три способа получения окончательного результата эквивалентны. Но если в первом случае функция принимала два параметра, то с помощью частичной аппликации благодаря λ-выражению можно ее заменить на две функции, с одним параметром каждая. Т.е. любая сложная функция может быть сведена к нескольким простым функциям, что позволяет создавать цепочки с помощью композиции функций.
## Dependency injection
"Инъекция зависимости" -- это стандартизированный прием обобщения функций или классов, которые зависят от сторонней реализации, с помощью параметризации такой зависимости. В качестве "элементарного" примера можно привести функцию qsort из стандартной библиотеки языка С. В этой функции самое важное -- это последний аргумент.

    void qsort( void* ptr, size_t count, size_t size, 
                int (*comp)(const void*, const void*) );
Параметр *comp* в качестве аргумента ожидает указатель на функцию с прототипом *int(const void *, const void *)*. Причина, по которой функция бесполезна без этого параметра, заключается в типе данных первого параметра *ptr* -- указателе на *void*. Этот указатель может быть использован для передачи адреса любого типа в качестве аргумента. Функция работает со значениями неизвестного типа, зная только размер значений в байтах (этот прием называется "type erasure").

Из этого следует, что стандартная операция сравнения "<" не подходит для сортировки, потому что семантика операции сравнения подразумевает адреса на целое число на месте аргументов. Таким образом, алгоритм сортировки зависит от внешней реализации операции сравнения для того типа, который хранится по переданному в первый параметр адресу. Так как функция *qsort* не знает где искать операцию сравнения для каждого типа данных, интерфейс ожидает, что вызывающая сторона предоставит нужный способ сравнения в виде ссылки на реализацию, соттветствующую интерфейсу *int(const void *, const void *)*, для последнего параметра.  

Чуть более сложный пример сценария, где инъекция зависимостей может помочь сделать код более обобщенным, описан ниже.

    typedef unsigned        customer_id;
    typedef struct Customer customer;
Предполагая, что некая система позволяет пользователю обращаться к данным своего профиля, в этой системе данные пользователя соответствуют какому-то уникальному идентификатору. Этот идентификатор можно использовать для того, чтобы получить данные ассоциируемого с ним пользователя.

    std::function<customer(customer_id)> get_customer; // persistence ignorant
Для получения данных пользователя в виде объекта типа *customer* нужно передать системе значение типа *customer_id*. Предположительно, данные всех пользователей хранятся в какой-то базе данных, и каждый раз, когда пользователь предоставляет идентификатор, система делает запрос в базу данных. 

    customer get_from_db(auto connection, customer_id cid) {
        auto result = /*  
            from connection 
            select customer
            where customerId = cid
        */
        return result;
    }
Пример выше иллюстрирует гипотетическую реализацию функции, которая делает запрос в базу данных, используя параметризованное подключение с сервером, и возвращает данные пользователя, если они были найдены. Несмотря на то, что само подключение параметризовано, это не делает функцию *get_from_db* по-настоящему обобщенной, потому что использовать в качестве подключения можно только объекты с поведением и интерфейсом как для конкретной базы данных.

Например, нельзя заменить такой объект на "закэшированный" список пользователей в случае отказа подключения к серверу по сети. Т.е. чтобы обобщить эту функцию, нужно было бы переписать ее реализацию с использованием только тех операций, которые одинаково подходят и для подключений к базе данных, и для списков пользователей в памяти. Это не такая простая задача, поэтому альтернативным способом решения может стать инъекция зависимости (в данном случае -- абстракции доступа к записям о пользователях). 

Суть такого решения в том, что конкретную функцию get_from_db нужно привести к виду, который подразумевает "идеальный" интерфейс *std::function<customer(customer_id)> get_customer*. Т.е. функция не должна знать какой именно способ получения данных она использует, он должен быть инкапсулирован. Уже должно быть понятно, что эта задача пересекается с функциональной композицией, и частичная аппликация может с этим помочь.

    auto get_from_db = [](auto connection) {
        return [&](customer_id cid) {
            auto result = /*  
                from connection 
                select customer
                where customerId = cid
            */
            return result;
        }
    };
Используя прием "currying" можно переписать функцию *get_from_db* как показано в примере выше. Это позволяет получить следующий эффект: 

    auto get_customer = get_from_db(mysql_connection);
Частичная аппликация новой версии функции *get_from_db* к объекту-подключению создает новую функцию *get_customer*, которая полностью совпадает с "идеальным" интерфейсом: она принимает значение типа *customer_id* и возвращает значение типа *customer*. При этом, аргумент *mysql_connection* скрывается, т.о. подключение к базе данных инкапсулируется. 

Если в системе существует отдельный способ получения данных пользователя из кэша (например, из таблицы, в которой для каждого идентификатора хранится ассоциируемый с ним "пользователь"), функцию обращения к кэшу также можно переписать. 

    typedef std::unordered_map<customer_id, customer> cache;

    auto get_from_cache = [](cache dict) {
        return [&](customer_id cid) { return dict[cid]; }
    };
Функция *get_from_cache* может быть инстанциирована объектом-таблицей, при этом не возвращая данные конкретного пользователя, как и в случае с функцией *get_from_db*.

    auto get_customer = get_from_cache(customer_cache);
Из этого следует, что "идеальная" функция *get_customer* может быть получена с помощью либо *get_from_db*, либо *get_from_cache*. Это никак не повлияет на пользователя функции get_customer, для которого важно только то, что она принимает значения типа *customer_id* и возвращает значение типа *customer*.

Подводя итоги, функциональное программирование позволяет использовать те же приемы, что и ООП (что естественным образом следует из их общего происхождения), но те приемы, которые в таких языках как С++ использовать трудно (в силу громоздких записей), в функциональных языках либо уже встроены в язык и имеют собственный синтаксис, либо поддерживаются на уровне стандартных операторов.

Самое главное в ФП то, как этот подход позволяет не допускать ошибок, которых в ООП очень тяжело избежать. В первую очередь, это ошибки, связанные с возможным состоянием объектов. Программисты часто не могут себе представить все возможные состояния для тех объектов, которые они разрабатывают или используют, особенно когда это происходит в комбинации с другими объектами. Функциональный стиль часто отражает состояние программы явно.

> No matter what way you work in, programming in a functional style provides benefits. You should do it whenever it is convenient, and you should think hard about the decision when it is not convenient.