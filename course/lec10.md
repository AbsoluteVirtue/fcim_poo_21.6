# Принципы SOLID
Слово SOLID в программировании имеет особое значение. Само слово ничего не значит, являясь аббревиатурой из первых букв нескольких сокращенных фраз (SRP, OCP, LSP, ISP, DIP), значение которых будет раскрыто ниже. Это пять "принципов" проектирования программного обеспечения, которые выделил и сгруппировал в 2000 году известный под псевдонимом "дядюшка Боб" автор Роберт Мартин. Принципами их назвали в шутку, намекая на их важность для программирования в той же мере, в какой известные физические открытия (принцип исключения Паули, принцип неопределенности Гейзенберга и т.п.) стали важными для науки в 19-м веке. Прежде, чем разобрать каждый принцип в отдельности, стоит рассмотреть то, насколько их значимость для программирования на самом деле высока.

В 2020 году Роберт Мартин получил письмо, в котором ему задавали вопрос: нужны ли принципы SOLID в современном программировании? В письме говорилось, 
> много лет SOLID был стандартной частью нашего процесса найма на работу, но с недавних пор один из менеджеров стал сомневаться в мудрости такого подхода.

Это письмо перекликается с сомнениями, которые уже достаточно давно высказываются в среде профессиональных разработчиков. Например, один из принципов, который подразумевает декомпозицию систем для высшей степени модульности, сейчас не так важен, потому что современные системы (например, "микросервисы") заранее проектируются как маленькие независимые коспоненты, а не как части "монолита". Другой пример -- наследование, которое является центральным аспектом другого популярного принципа, при этом в разработке наследование используется редко, т.к. современные языки его не поощряют.

Мартин на это отвечает, что программное обеспечение не так сильно изменилось, как может показаться: программы все еще пишут, используя аналоги *if*, *while* и присваивания -- последовательно, итеративно, с возможностью выбора. Противники его идей отмечают, что решением проблем, с которыми принципы SOLID призваны бороться, является упрощение кода приложения. Тем не менее, 
> простота не так просто достижима, для этого нужна дисциплина, поддерживаемая хорошими базовыми принципами. Другими словами, простота вырастает из принципов. Дисциплина  держит программистов в рамках, благодаря которым они пишут простой код. Лучший способ получить сложную чушь -- это сказать всем "быть проще" и больше никак их не направить.

В этом анекдоте утверждаются две вещи, которые неоспоримы:
- принципы SOLID действительно считаются если не законами, то рекомендациями, с которыми должен быть знаком каждый начинающий программист, и их знание часто проверяется во время интервью;
- есть большое количество людей, которые считают их если не вредными, то как минимум бесполезными.

Мнение Мартина по этому воводу понятно, ведь он сформулировал эти принципы как некий свод правил "хорошего тона". Но важно также прислушаться к мнению его противников. Например, есть обоснованные претензии к терминам "простой код" или "чистый код". Какой код считается чистым? Принципы SOLID не дают критериев оценки.
> Вместо этого предлагаются последовательности действий, которые сделают код чистым. Другими словами, не существует программы, которую можно запустить, чтобы она сказала "код чистый" или "код не чистый". У нас есть только действия, которые надо совершить, после чего код чист. Если посмотреть на принципы SOLID, ни один из них не является процессом, который происходит на компьютере. Эти принципы происходят только в ваших головах. Они являются критериями того, какой код программист разрешает себе писать. Это фильтр вымышленных метрик, которые не соответствуют измеримому эффекту на процессор.

Как будто в подтверждение этих слов некоторые крупные специалисты говорят, что начинающих программистов в первую очередь нужно учить тому, как использовать наследование, делегацию вызовов, приведение типов, а не тому, как писать циклы -- это "правильное" программирование. Тем не менее, Мартин всегда мудро говорит, что принципы солид не являются строгими правилами.
> Это не законы. Это не прописные истины. Это заявления вида, "если есть по яблоку в день, будешь здоров." Это хороший принцип, хороший совет, но не истинная правда и не правило.
## Мотивация
Первоначальная идея, стоявшая за необходимостью сформулировать эти принципы, заключалась в том, что Мартину нужно было описать общепринятые на тот момент решения часто возникающих проблем, которые он называл шаблонами проектирования. Цель проектирования программного обеспечения лежит в определении "формы" и структуры того или иного разрабатываемого приложения, чтобы эту форму постепенно можно было заполнить деталями реализации -- это высокоуровневая архитектура приложения. Заполнение структуры происходит согласно установленной цели программного продукта. Цель определяется модулями и их каналами коммуникации, из которых состоит проект: классами, библиотеками, функциями и т.п. Принципы SOLID призваны установить некие пути, по которым легче следовать при выборе и реализации отдельных модулей.
### Симптомы плохого проекта
Мартин выделяет четыре свойства архитектуры систем, которые указывают на плохой дизайн приложений.
1. Косность -- стойкость к изменениям.
2. Хрупкость -- неустойчивость при малейших изменениях.
3. Неподвижность -- непереносимость кода из проекта в проект.
4. Вязкость -- сложность в применении хороших практик при работе с кодом проекта.

> Rigidity – every change causes a cascade of subsequent changes in dependent modules; managers fear to allow engineers to fix non-critical problems, they don’t know when the engineers will be finished.

Первый симптом – косность – описывает тенденцию кода программ к усложнению работы с ним по мере накапливания кода. В особенности это проявляется при попытках внести в код даже самые незначительные изменения. Любое изменение неизбежно вызывает необходимость делать изменения во всех смежных модулях или файлах, которые зависят от изменяемого кода, вызывая эффект “снежного кома”. В условиях активного процесса разработки люди, отвечающие за успешность всего проекта, опасаются давать свое разрешение на внесение таких изменений даже в тех случаях, когда изменения нужны для исправления незначительных ошибок. Эти опасения вызваны предыдущим горьким опытом, который показывает, что попытки исправить что-то в программе могут привести к необходимости переписывать множество модулей. Из этого следует, что невозможно даже приблизительно установить, сколько времени понадобится инженерам для решения той или иной проблемы. Если такие случаи повторяются систематически, игнорирование мелких ошибок рискует превратиться в официальную политику менеджмента.
> Fragility – the breakage occurs in areas that have no conceptual relationship with the area that was changed; software is impossible to maintain, the probability of breakage increases with time; developers seem like they have lost control of their software.

Второй симптом – хрупкость – тесно связан с первым. Если программа теряет работоспособность каждый раз, когда в код вносятся изменения, из-за того, что эти изменения неизбежно вызывают конфликты в коде зависимых модулей, менеджмент теряет доверие к своим инженерам. Создается впечатление, что исправление одних проблем порождает еще больше новых проблем в программе. Особенно трудными последствиями опасны ситуации, когда “ломается” код, никак концептуально не связанный с измененным кодом. В такой ситуации менеджмент и пользователи теряют доверие к разработчикам, так как создается впечатление, что разработчики потеряли контроль над ситуацией.

> Immobility – one engineer discovers that he needs a module that is similar to another engineer’s; the module has too much baggage that it depends upon; the work and risk required to separate the desirable parts are too great to tolerate.

Третий симптом - еподвижность - описывает ситуации, в которых код, написанный в рамках одного проекта, невозможно использовать для других проектов. Такие ситуации могут возникнуть, если какой-то модуль реализует поведение, которое нужно повторить в другой программе. Неизбежно возникает соблазн перенести весь модуль целиком, чтобы сэкономить время. К сожалению, может случиться так, что модуль имеет большое количество зависимостей, и перенос модуля вместе с интеграцией в новый проект займет больше времени, чем написание всех алгоритмов с нуля.

> Viscosity – of the design and of the environment; faced with a change, engineers find more than one way to make the change, and some ways preserve the design while others don’t (they are hacks); if the design preserving methods are harder to employ than hacks, the viscosity of the design is high; if the development environment is slow and inefficient (long compile times, hard source control process etc.)

Четвертый симптом - вязкость - можно разделить на два вида: возникающий в дизайне или - в среде разработки. Если внесение изменений в код проекта, следуя всем договоренностям и стандартам, установленным для проекта, сопряжено с трудностями, появляется соблазн сэкономить время за счет игнорирования стандартов и ограничений. Появляется тенденция к тому, что неправильный код писать легко, а правильный – трудно. В этом выражается вязкость дизайна. 

Вязкость среды разработки выражается в том, что инструменты разработки трудно использовать эффективно. Например, если компиляция занимает много времени, инженеры перестают вносить мелкие изменения в код даже в тех случаях, когда это необходимо. Либо изменения делаются не так, как этого требует дизайн программы, а так, чтобы сократить время компиляции как можно сильнее.

Симптомы, перечисленные выше, часто рассматриваются как признаки плохой архитектуры программного обеспечения. Эти признаки часто называют неофициальным термином “гнилой код” (code rot). Первоочередная причина, как правило, в том, что требования к программе меняются в ходе разработки, при этом новые требования не поддерживаются первоначальным дизайном. Часто изменяющиеся требования к дизайну порождают сложные цепочки зависимостей и добавление новых зависимостей с каждым изменением. Способ борьбы с деградацией дизайна приложения – управление зависимостями с помощью блокирования путей проникновения зависимостей в дизайн (что Мартин называет "dependency firewall"). Это является главной причиной использования принципов SOLID.
## Open Closed
> A module should be open for extension but closed for modification

Самый важный, по мнению Мартина, принцип был заимствован у Бертрана Мейера. Ключ к достижению такого эффекта – в абстракции. Для начала - пример, который противоречит данному принципу.

    struct Modem {
        enum Type { hayes, courrier, ernie} type;
    };

    struct Hayes { 
        Modem::Type type; 
        // ..
    };

    struct Courrier {
        Modem::Type type; 
        // ..
    };

    struct Ernie {
        Modem::Type type; 
        // ..
    };

    void LogOn( Modem &m, string& pno, string& user, string& pw ) {
        if (m.type == Modem::hayes)    DialHayes((Hayes&)m, pno);
        if (m.type == Modem::courrier) DialCourrier((Courrier&)m, pno);
        if (m.type == Modem::ernie)    DialErnie((Ernie&)m, pno);
        // .. 
    }
В примере выше роль модуля со стороними зависимостями играет функция *LogOn*. Его зависимость -- структура *Modem*, которая является обобщением конкретных моделей модемов. Функция должна выполнять код, связанный с конкретной моделью, но тип модема функции заранее не известен, и поэтому он будет определяться динамически. Сразу возникает проблема с расширением этого модуля. Если в стороннем модуле появятся структуры для новых моделей модемов, функцию *LogOn* придется изменять.

Мартин же говорит, что необходимо изменить поведение модуля, не меняя его исходный код. Этого можно добиться несколькими способами, самым очевидным из них является наследование.

    struct Modem {
        virtual void Dial(const string &pno) = 0;
    };

    struct Hayes : Modem { 
        void Dial(const string &pno) override;
        // ..
    };

    void LogOn(Modem &m, string &pno, string &user, string &pw){
        m.Dial(pno);
        // .. 
    }
Наследуя абстрактный класс *Modem*, структура *Hayes* (и другие похожие структуры, представляющие разные модели модемов) расширяет базовое поведение всех модемов. Функция *LogOn* все так же зависит от структуры *Modem*, но теперь между функцией и структурой существует контракт -- люое расширение базовой структуры *Modem* гарантирует предоставлять свою реализацию метода *Dial* с интерфейсом, который ожидает функция *LogOn*. Это значит, что при появлении новых видом модемов в системе функцию *LogOn* изменять не придется.

    template <typename _Modem>
    void LogOn(_Modem &m, string &pno, string &user, string &pw) {
        m.Dial(pno);
        // .. 
    }
Такого же эффекта в С++ можно добиться с помощью шаблонов, так как пропала необходимость делать выбор реализации метода *Dial* динамически. В любом случае, эффект от такого подхода заключается в возможности написать код один раз, проверить его на правильность и больше никогда не менять.
> If you don’t have to change working code, you aren’t likely to break it.

## Liskov Substitution
> Subclasses should be substitutable for their base classes

Принцип подстановки утверждает, что "клиент" (пользователь) базового класса не должен терять доступ к функциональности, если происходит подстановка объекта, тип которого является произвольным подклассом. Для того, чтобы понять мотивацию, стоящую за этим принципом, нужно точно определить, что такое "подкласс".

В своей известной работе "Абстракции данных и иерархии" Барбара Лисков (в чью честь принцип назван) пишет,
> если для каждого объекта о1 типа S существует объект о2 типа T, т.о. что для всех программ P, которые определены посредством T, поведение P не изменится, когда вместо o1 подставляется o2 -- S является подтипом T.

Например, два (возможно независимых друг от друга) типа данных: список и множество, могут быть использованы в одном и том же контексте, т.к. оба предназначены для хранения упорядоченных наборов данных. Программа, хранящая данные в списке, в зависимости от операций на списке, которые используются в ней, может заменить список на множество (для ускорения поиска), при условии, что методы списка и методы множества имеют одинаковый интерфейс. При этом множество не является подтипом списка (даже если оно реализовано с помощью наследования списка), потому что операции добавления и удаления элементов на множествах отличаются семантически. Если добавить одно и то же значение в список дважды, его размер увеличится на 2, в то время, как такое же добавление в множество увеличит его размер на 1 (в множестве не может быть дубликатов значений).

И наоборот, если программа использует множество, заменить его на список нельзя, так как нарушается асимптотичность операций, потенциально нарушается и поведение (список не гарантирует отсортированный порядок) - нарушается контракт, а следовательно список не будет подтипом множества. Другой пример нарушения этого принципа: очередь и стек, т.к. добавление и удаление происходят по-разному (LIFO против FIFO).  

Т.е. наследования мало для того, чтобы получить подтип, потому что недостаточно предоставлять все операции своего "супертипа" в подтипе, их семантика тоже должна быть полностью сохранена, т.к. правильность программы при замене одного на другой не должна нарушаться. Примерами подтипов могут быть деки по отношению к динамическим массивам (std::deque и std::vector), т.к. повторяют все операции доступа к элементам и изменения состава контейнера. 

Соответственно, подкласс -- это класс, который описывает подтип (традиционно, но не обязательно - с помощью наследования). Тогда любой модуль, который использует конкретный класс, может использовать любой из его подклассов. 

Даже в таких ситуациях могут возникнуть трудности. Например, для геометрических фигур, можно заметить, что все круги -- это частные случаи овала (фокусы которого совпадают в центре).

    class Ellipse {
        Point focusA;
        Point focusB;
        double axis;
    public:
        void SetF(Point, Point);
        void SetA(double);
        double Area();
        // ...
    };

    struct Circle : Ellipse {
        void SetF(Point a, Point b) {
            focusA = a; focusB = a;
        }
        double Area();
        // ...
    };

    void User(Ellipse &e) {
        Point a, b;
        e.SetF(a, b); 
        assert(e.GetFoci() == {a, b});
    }
Исходя из такого предположения, можно создать иерархию классов, как показано в примере выше. Проблема такой реализации может подкрасться незаметно. Принцип подстановки нарушается, если для такой реализации круга в функцию *User* передать объект типа *Circle*. Реализация функции зависит от конкретного поведения объекта: после установки фокусов объекта в координатах *a* и *b*, проверка должна подтвердить эти координаты. Данный контракт будет кругом нарушен, потому что у него нет второго фокуса.

Можно предварительно проверять предусловие.

    void User(Ellipse &e) {
        if(typeid(e) != typeid(Ellipse))
            return;
        Point a, b;
        e.SetF(a, b); 
        assert(e.GetFoci() == {a, b});
    }
Но в таком случае зависимость между пользовательским кодом и реализацией функции становится явной. Как правило, нарушения LSP одновременно указывают на нарушение OCP.

Можно перевернуть иерархию, ведь все овалы технически являются общими случаями круга.

    class Circle {
        Point center;
        double radius;
    public:
        void SetC(Point);
        void SetR(double);
        double Area();
    };

    class Ellipse : Circle {
        Point focusB;
    public:
        void SetF(Point a, Point b) {
            Circle::center = a; focusB = b;
        }
        double Area();
    };
Здесь обнаруживается другой подводный камень: вычисление площади эллипса отличается от вычисления площади круга, поэтому для круга нужно переопределить метод *Area*. Это немедленно нарушит контракт в примере ниже.

    void User(Circle &c) {
        Point a, b; double r;
        c.SetC(a, b);  c.setR(r);
        assert(c.Area() == f(a, b, r));
    }
Функция *User* делает некоторое предположение относительно площади фигуры, которое не будет верным в случае передачи в функцию объекта типа *Ellipse*. Проверка предусловия и в этом примере вызовет ошибку.

Оба примера показывают, что наследование не является гарантией того, что один класс является корректным подклассом другого. Даже если синтаксически подкласс существует, семантически он может нарушать принцип подстановки, а значит в данном случае объекты этих связанных иерархически типов не взаимозаменяемы.

(Очевидное следствие из этих двух примеров: наследование данных является плохим примером использования наследования, во избежание возникновения проблем наследовать нужно поведение).
## Dependency Inversion
> Depend upon abstractions, not upon concretions.

Высокоуровневые модули должны зависеть от низкоуровневых модулей. При этом пользователь высокоуровневых модулей не обяхан знать о конкретике реализации в низкоуровневых модулях, поэтому следует сделать “прокладку” между этими уровнями. Это основной механизм достижения OCP – он постулирует необходимость направлять все зависимости на абстрактные классы или абстрактные функции.

Важной мотивацией следовать этому принципу является желание не зависеть от модулей, которые имеют тенденцию часто меняться (например, если они находятся в активной разработке или часто полностью заменяются на аналоги). Мартин делает предположение, что код, содержащий реализацию, является "волатильным", т.к. всегда есть вероятность, что реализацию придется изменить (дополнить или исправить). Например, зависимость от библиотеки *string.h* до какого-то момента может казаться стабильной, пока не появится необходимость поддержки UTF-8, и всю билиотеку придется заменять. Мартин предлагает выход: использовать абстракцию библиотеки для работы с текстом, чтобы реализацию можно было менять по желанию.

    void User(size_t m) {
        auto output = (char)malloc(m);
        size_t n = strlen(input) + 1;
        strncpy(input, output, n);
    }
    // или
    class text {
    public:
        text(size_t);
        text(const char*);
        text(const wchar_t*);
    };

    void User(size_t m) {
        auto output = text{m};
        output.copy(input);
    }
Фрагмент выше показывает пользовательский код с конкретной и абстрактной зависимостями. В первом случае используется библиотека *string.h*. Во-втором -- абстрактный тип данных *text*, который скрывает детали реализации от пользователя. Он может сам использовать библиотеку *string.h*, но если реализация класса  *text* изменится, на код пользователя это не повлияет.
### Abstract factory
Мартин делает интересное замечание. В примере выше пользовательский код зависит от конкретного класса *text*. Что нарушает данный принцип, так как создание объекта - это прямая зависимость от конструктора класса. Но если сделать класс *text* абстрактным, проблему это не решит, т.к. создавать объекты абстрактных классов (в языке С++) нельзя. Исторически, для решения этой проблемы использовали шаблон проектирования "абстрактная фабрика". Она частично решает проблему зависимости от конструирования, "оборачивая" конструктор в абстракцию, которая предоставляет пользователю метод(ы), создающие нужные объекты. Тип объекта зависит от конкретной реализации, но пользователю не нужно взаимодействовать с реализацией напрямую.

    class text_factory {
    public:
        virtual text make_text(size_t) = 0;
    };

    class text : public text_factory {
    public:
        text(size_t);
        text(const char*);
        text(const wchar_t*);
        text make_text(size_t width = 1) override;
    };

    void User(text_factory& tf, size_t m) {
        auto output = tf.make_text(m);
        output.copy(input);
    }
Т.о. пользователь зависит только от одного интерфейса, который отвечает за производство всех видов текста.
## Interface Segregation
> Many client-specific interfaces are better than one general purpose interface.

Данный принцип нужен для того, чтобы исключить ситуации, когда нужды разных пользователей какого-то интерфейса приводят к тому, что пользователи косвенно зависят друг от друга. Например, чем больше пользователей у интерфейса, тем больше единиц компиляции будет когда интерфейс изменяется. Принцип предполагает создание специализированных интерфейсов для каждого пользователя, когда такой пользователь возникает. Дизайн каждого интерфейса отталкивается, в первую очередь, от нужд своего пользователя, вся логика классифицируется по этому признаку, после чего реализацию можно держать в одном месте, так как между ней и пользователями существует “прокладка” в виде специализированных интерфейсов.

Если, например, двум пользователям нужны алгоритмы из одной и той же реализации, согласно этому принципу лучше продублировать доступ к реализации в двух разных интерфейсах.

``` C++
class IA {
public:
	virtual void sort(collection) = 0;
};

class IB {
public:
	virtual void sort(collection) = 0;
};

class algorithms : public IA, public IB {
public:
	void sort(collection) override;
};

void UserA(IA& algo) {
	auto iterable = collection();
	algo.sort(iterable);
}

void UserB(IB& algo) {
	auto iterable = collection();
	algo.sort(iterable);
}
```
В этом случае пользователь может и не знать, что реализация используется еще где-то, его интерфейс может быть расширен в дальнейшем, реализация может быть заменена на другую, остальные пользователи этого не почувствуют.

Как показано выше, множественное наследование позволяет пользователям зависеть от нескольких интерфейсов, которые реализуются в одном модуле/классе. Пользователь обращается не к модулю или классу, который предоставляет весь интерфейс, а к абстрактной сущности, которая описывает только ту логику, которая им используется. Все такие сущности наследуются одним классом , который будет предоставлять реализацию для них всех (например, в рамках одной библиотеки или модуля). Делается это для того, чтобы изменения в одном из интерфейсов не вынуждали обновляться всех пользователей.

Если же интерфейс требует изменений, рекомендуется создавать новый интерфейс, оставляя старый на месте, чтобы пользователи могли выбрать момент перехода на новый интерфейс. Например, как показано ниже.
``` C++
class UIB; // обновленный интерфейс

void UserB(IB& algo) {
	auto new_algo = dynamic_cast<UIB&>(algo);
	auto iterable = collection();
	new_algo.sort(iterable);
}
```
## Single Responsibility
> Each module should have only one reason to change.

Причем, многие разработчики немного не так трактуют этот принцип, фокусируясь на идее ответственности самого модуля. Отсюда происходит рекомендация делать интерфейсы, методы и функции как можно меньше. На самом деле Мартин позаимствовал этот принцип из статьи Дэвида Парнаса, в которой последний заметил,
> Декомпозиция системы должна начинаться не со связей между модулями, а с дизайнерских решений, которые имеют большую вероятность измениться в будущем. Тогда дизайн отдельного модуля выстраивается вокруг сокрытия такого решения. 

С подачи Эдсгера Дейкстры (EWD447) в программирование было введено понятие "разделения ответственности", и Мартин объединил эти две идеи в свой принцип. Ответственность направлена от человека, принимающего решение по назначению модуля к человеку, реализующему модуль. Так, за функциональность модуля, считающего зарплату каждый месяц, отвечает главный бухгалтер (так как он, а не инженер, реализующий этот модуль, отвечает за правильную последовательность операций). То есть, при разработке модуля решение о внесении изменений в модуль может принимать только тот, кто отвечает за модуль (stakeholder). По словам Мартина, разработчик должен стремиться “собирать в кучу сущности, которые меняются по одной и той же причине; отделять друг от друга сущности, которые меняются по разным причинам”.

Другими словами, архитектура системы определяется не тем, как разработчики видят свои задачи в отдельности, а тем, какие ответственные лица принимают участие в разработке. Позже будет сказано несколько слов о другом принципе ("законе Конвея"), который напрямую противоречит идее Мартина. Т.о. данный принцип указывает на необходимость отталкиваться от взаимодействий между людьми, которые должны диктовать необходимые взаимодействия между модулями разрабатываемой системы.

Следствием этого принципа является подход к написанию модулей (или классов) с узкой специализацией, где специализированность определяется пресловутой “причиной изменяться”. По этой причине, например, генерацией HTML занимается не тот модуль, который генерирует результаты для веб-страницы. За правильный подсчет отвечает специалист по данным, а за правильное отображение - специалист по визуальному дизайну, их сферы ответственности не пересекаются, и функциональности соответствующих модулей также не должны пересекаться.

# Принципы когерентности и спаренности
Несмотря на то, что в большинстве примеров выше минимальной единицей инкапсуляции был класс, это не главный способ организации кода в традиционных ОО-приложениях. Соответственно, главный вопрос, стоящий перед дизайнером заключается в том, какие классы отнести к какому файлу/модулю. Мартин выделяет несколько принципов, посвященных этому уровню организации. 
## Release-Reuse Equivalency
> The granule of reuse is the granule of release.

Любой компонент (модуль, класс и т.п.) -- как часть сложной системы -- требует контроля версий, который позволяет пользователям этого компонента выбирать нужную версию. Никто не хочет выпускать новую версию своего приложения каждый раз, когда выходит новая версия одного из сторонних модулей, от которого приложение зависит.

Это означает, что авторы компонента должны длительное время поддерживать предыдущие версии своего программного обеспечения, чтобы компенсировать задержку при адаптировании новых версий пользователями. Из этого предположения Мартин делает вывод, что группировать классы в модули/библиотеки нужно согласно тому, как они будут часто они будут использоваться вместе.
## Common Closure
> Classes that change together, belong together.

Этот принцип дополняет предыдущий -- он рекомендует минимизировать количество компонентов, обновляемое в следующей версии, которую выпустят для пользователей. Отсюда есть закономерный вывод: группировать классы в рамках модуля по принципу запланированного изменения. Если несколько классов по какой-то причине вместе готовится к новому обновлению, их заранее нужно определить в общий модуль, чтобы обновление затронуло как можно меньшее количество пользователей.

Здесь есть важный нюанс: разработчики (а скорее, ответственные за принятие решений) должны "заглянуть в будущее", чтобы распознать компоненты, которые будут разрабатываться или обновляться вместе, что не всегда просто.

Здесь есть очевидная параллель с принципом единственной ответственности (SRP). Но нужно также заметить, что предположение Мартина относительно частоты обновлений в код-базе достаточно смелое, потому что итеративная разработка приложения с параллельным взаимодействием пользователей с обновленным функционалом -- способ, более характерный для веб-приложений или "живых" сервисов, которыми диапазон всех возможных видов программного обеспечения не ограничивается. 
## Common Reuse
> Classes that aren’t reused together should not be grouped together.

Важно сделать одно замечание по предыдущему принципу. Если классы уже сгруппированы в каком-то модуле, переносить их в другой (обновленный) модуль каждый раз когда, один класс нужно изменить, а другие - нет, не рационально. Соответственно, существует некоторое противоречие между двумя принципами, описанными выше. 

Мартин обращает внимание на то, что это происходит из-за того, что пользователи и разработчики находятся в конфликте друг с другом. Пользователю удобно обновляться как можно реже. Разработчику удобно часто выпускать маленькие обновления.

Пользователям удобно, чтобы обновления функционала, который им напрямую не нужен, никак не влияли на их копию приложения. Например, если обновляется сетевой протокол для обмена голосовыми сообщениями операционной системы, пользователю, устройство которого не используется для голосовой связи, не хочет лишний раз обновлять ПО ради функционала, которым он не пользовался до сих пор и не планирует. С другой стороны, разработчику удобней выпускать все нововведения и исправления одним обновлением, а значит обновления должны быть как можно меньше. 

Эти рекомендации Мартина очень сильно зависят от ситуации и не применимы во всех случаях, и он сам это осознает, поэтому советует использовать эти принципы по ситуации: в начале разработки CCP подойдет лучше, так как комфорт и скорость при активной разработке имеют приоритет. В конце цикла активной разработки или при переходе в режим поддержки компонент должен быть ориентирован на нужды пользователей, поэтому CRP более уместен.
## Acyclic Dependencies
> The dependencies betwen packages must not form cycles.

