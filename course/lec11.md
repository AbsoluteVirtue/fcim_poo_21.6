# Conway's Law
В ходе одной из лекций, отвечая на вопрос о тенденции в математике к отдалению от физики, оригинальный автор библиотеки STL для языка С++ Александр Александрович Степанов сделал замечание (@https://youtu.be/zwucsB2EfXc?t=1029).
> Произошло разделение алгоритмики, математики, и это плохо для обоих\[sic\]. Мы верим в какую-то астрологию: объектно-ориентированное программирование, мета-шаблонное программирование – нет, учите алгебру, потому что в этом вся мудрость. Вы скажете: как это, алгебра не применима к моим задачам. Применима, вы просто этого не видите.

Здесь сразу становится очевидным противоречие: автор одной из основополагающих систем “объектно-ориентированного” языка программирования называет объектно-ориентированное программирование “астрологией”. Но в одной из предыдущих частей уже приводилась другая его цитата (@Notes on Programming).
> Несмотря на то, что типы объектов можно определять любым способом, существуют естественные законы, которые управляют поведением большинства типов; эти законы определяют значение фундаментальных операций на объектах: конструирование, уничтожение, присваивание, обмен, равенство и линейная упорядоченность.

Степанов рассматривает ООП, скорее, как инструмент для написания полностью обобщенных программ. Для него намного важнее следовать правилам построения алгебраических типов данных. Для таких типов можно использовать алгебраические законы и теоремы, чтобы описывать программы, правильность которых достоверно проверяема.

Можно вспомнить, что и Алан Кей (Smalltalk), и Джо Армстронг (Erlang) говорили очень похожие вещи: ООП изначально выросло из попытки создать семейство алгебр, которые потом можно было использовать для решения разных задач. В этом они Степанову не противоречат.

Отсюда возникает вопрос законов ООП: каких-то незыблемых правил, которых стоит придерживаться всегда, и которые можно использовать для доказательства наличия каких-то свойств в своих программах. Предыдущая часть приводила в пример принципы SOLID, но сам Роберт Мартин мудро законами их не называет. Шаблоны проектирования "банды четырех" тоже законами считать нельзя, так как в разных сценариях одни и те же шаблоны то применимы, то нет.

Конечно, есть некие законы, которые руководят процессом написания программ просто потому, что они руководят процессом человеческого мышления -- законы логики. Закон -- это категория, согласно которой формируется правильная мысль, или которая подтверждает правильный вывод (inference), или к которой можно свести все правильные дедукции. Из курса логики можно вспомнить как минимум четыре таких закона: закон тождества, закон противоречия, закон двойного отрицания, закон исключения третьего (@https://www.mdpi.com/2075-1680/3/1/46). Разработчики программного обеспечения регулярно прибегают к этим законам в своей работе, часто даже не догадываясь.

Но в информатике есть и другая категория, которую называют "законами", которая при этом, строго говоря, таковой не является (@https://youtu.be/5IUj1EZwpJY).
## Законы программного обеспечения
### Принцип Парето
80% времени занято 20% модулей (@http://www.improvement.ru/zametki/pareto/)

Предсказание, основанное на эмпирических наблюдениях.
### Закон Мура
Каждые два года количество транзисторов на схеме удваивается

Эмпирическое наблюдение.
### Закон Постела
Be conservative in what you do, be liberal in what you accept from others*

Протокол TCP. (@https://github.com/solarrust/hacker-laws)
### Закон Амдаля
Это правило можно сформулировать следующим образом.
> Производительность системы относительно количества исполняющих модулей всегда ограничена кодом, который невозможно распараллеливать.

Другими словами, время исполнения программы или части программы, используя n параллельных обработчиков (потоков, ядер, процессоров), будет равно времени исполнения непараллельной части b в совокупности с параллельным выполнением остальных частей программы.

T(n) = b + (T(1) - b) / n

Т.е. любая задача выполняется примерно столько, сколько выполняется самая долгая непараллелизуемая часть задачи. Если, например, число вычислительных единиц стремится к бесконечности, уравнение выше теряет вторую часть (она становится бесконечно малой).

T(inf) = b + ~~(T(1) - b) / inf~~

Из этого можно сделать промежуточный вывод: в будущем программы, написанные с длинными непараллельными частями, нельзя будет ускорить, добавив в систему вычеслительные мощности (см. закон Мура выше); для значительного ускорения программ в современных системах они должны быть написаны, исходя из того, как быстро исполняется самая долгая непараллелизуемая часть -- т.о. будущее программирования в рамках архитектуры фон Неймана, вероятно, заключено в параллельном программировании.

(@https://www.researchgate.net/publication/228569958_Calculation_of_the_acceleration_of_parallel_programs_as_a_function_of_the_number_of_threads)
### Закон Брукса
Adding manpower to a late software project makes it later

Эмпирическое наблюдение, сделанное относительно понятия "человекочас": в корне неверное утверждение, что существует линейная зависимость между временем выполнения задачи и количеством людей, ее выполняющих.

Брукс постулирует, что сложные задачи, которые требуют обмена информацией между группами людей, ответственных за решение, естественным образом замедляются с добавлением новых людей на задачу, потому что это дополнительно нагружает каналы коммуникации. В этом его наблюдение пересекается с законом Амдаля: в структуре исполнения есть "бутылочное горлышко", которое не позволяет распределить части задачи равномерно -- канал коммуникации является непараллелизуемой частью решения. 

Конечно, есть ситуации, где добавление людей положительно влияет на процесс: например, конвеерная сборка не подразумевает коммуникацию между работниками, поэтому весь процесс ограничен скоростью конвеерной ленты. С другой стороны есть задачи, которые принципиально нельзя разбить на подзадачи ("нельзя выносить ребенка усилиями 9 женщин за 1 месяц"). 

Наконец, есть задачи, где добавление людей в процесс его замедлит, так как цена налаживания коммуникации между новыми работниками и старыми будет выше, чем цена решения задачи с текущим количеством работников ("комбинаторный взрыв"). 
## Разработка комитетом
Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure
(@https://www.melconway.com/Home/pdf/committees.pdf)

Статья Конвея описывает процесс проектирования программного обеспечения как коллективную деятельность, откуда он пытается вывести фундаментальные закономерности, влияющие на формирование окончательной архитектуры приложений. В первую очередь, автор рассматривает границы, которые накладываются и на разработчиков системы, и на саму систему. Во вторую очередь, он переносит организационную структуру системы на структуру отдельных команд разработки.

Как только определены команды, это сразу порождает задачу по координации этих команд. Несмотря на то, что межкомандная коммуникация слегка замедляет процесс разработки, это необходимая мера достижения единого системного дизайна. Здесь Конвей делает важное допущение: как только структура организации (количество и ответственности отдельных команд) полностью определена, и отдельные подзадачи делегируются соответствующим командам, это неизбежно сужает масштаб работ каждой команды, а это, в свою очередь, неизбежно исключает альтернативные дизайны системы.

Другими словами, сам акт разделения задачи на подзадачи -- разделения организации на команды диктует будущий дизайн системы, потому что такая конфигурация организации может создать только узкий спектр дизайнов системы. Из этого есть еще одно следствие: те альтернативы, которые потенциально существовали до создания отдельных команд разработки, становятся не доступны, потому что между командами не существует соответствующих каналов коммуникации.
> There is no such thing as a design group which is both organized and unbiased.

В качестве простого примера можно рассмотреть дизайн спортивного автомобиля. Очевидно, что команда, разрабатывающая шины, не имеет ничего общего с командой, разрабатывающей двигатель. При этом, если между этими командами нет нужных каналов коммуникации, окончательный дизайн шин может не учитывать особенности дизайна двигателя, и готовый прототип автомобиля будет показывать результаты ниже ожидаемых.

Далее делается еще более смелый вывод. Если рассматривать первоначальный проект системы как семейство дизайнов, которые удовлетворяют требованиям к системе, выбор структуры организации, ответственной за дизайн данной системы, неизбежно влияет на выбор системного дизайна из семейства всех опций -- организация будет выбирать тот дизайн, который проще получить со своей текущей структурой. Таким образом, Конвей приходит к своему самому известному утверждению: насколько позволяют налаженные внутри организации каналы коммуникации, настолько организация отразит свою собственную структуру в структуре разрабатываемой системы. Причем, чем больше организация, тем меньше гибкости в выборе, тем очевидней проявится данный феномен.  
### Windows Media
В качестве примера того, как этот феномен проявляется в дизайне крупных проектов, можно рассмотреть ОС Windows, и то, как в ней выглядит система воспроизведения медиа-файлов.
(@https://www.youtube.com/watch?v=5IUj1EZwpJY)

> My guess is that object-oriented programming will be in the 1980s what structured programming was in the 1970s. Everyone will be in favor of it. Every manufacturer will promote his products as supporting it. Every manager will pay lip service to it. Every programmer will practice it (differently). And no one will know just what it is.