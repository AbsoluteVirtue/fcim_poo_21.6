# Что значит "объектно-ориентированный"?
Если поискать информацию о термине "объектно-ориентированный" в произвольных открытых источниках, в большинстве случаев приводится пример "трех китов ООП":
* инкапсуляция;
* наследованиеж;
* полиморфизм.

Эпиграфом может служить цитата известного дизайнера Грэди Буча, взятая из книги "Object-Oriented Analysis, Design and Implementation".

> "Язык считается объектным, если он напрямую поддерживает абстракцию данных и классы. Объектный язык является объектно-ориентированным, если он поддерживает наследование и полиморфизм."

Возможно, именно отсюда и пошла традиция привязывать три этих явления к ООП. Данный курс попытается доказать, что ни один из этих элементов не является критической частью ООП в отдельности. Первом официально "объектно-ориентированным" языком был язык Smalltalk, поэтому логично начать рассмотрение особенностей ООП с того, как все эти свойства в нем применялись. 

Инкапсуляция в Smalltalk реализована через сокрытие данных для исключения оператора присваивания из языка -- это результат выводов, сделанных Аланом Кеем под влиянием дизайна проекта Sketchpad (где инкапсуляции не было) и более раннего языка программирования Simula (где она носила схематичный характер, о чем речь пойдет ниже). Целью инкапсуляции было введение дополнительного уровня абстракции во все операции с переменными в языке.

Наследование никогда не было составной частью ООП, и даже в языке С++ от наследования какой-то общей структуры ушли к наследованию общего поведения через интерфейсы, а в итоге от него отказались в пользу статического полиморфизма. Тем не менее, наследование заслуживает более подробного рассмотрения, так как первоначально широко применялось в Smalltalk, в последствии оказавшись ненужным. Наследованию будет посвящена отдельная глава.

Полиморфизм -- это свойство системы типов, которое само собой не подталкивает использовать объекты, скорее, являясь инструментом к достижению высокой степени обобщенности в коде. Полиморфизму также будет посвящена отдельная глава. 

Начать стоит с изучения двух базовых элементов, о которых говорит Буч в своей книге: абстрактных данных и классов. И не только потому, что эти понятия сейчас тесно связаны с ООП. Алан Кей пользовался этими механизмами во время работы над языком Smalltalk, что требует их более внимательного рассмотрения.
## Базовые элементы объектно-ориентированного дизайна
Когда Алан Кей пришел в подразделение PARC корпорации Xerox, одной из его первых задач было ознакомиться с двумя на тот момент новыми примерами инновационного использования компьютерных технологий. Одной технологией была система компьютерного дизайна Sketchpad Айвана Сазерленда, которая стала одной из самых значимых работ в сфере компьютерных технологий. Другой был язык программирования Simula, использующий новую концепцию "классов как процессов" в качестве основного инструмента организации кода.

Зная о том, что в группе по разработке языка Algol высказывались идеи об использовании "абстрактных типов данных" (которые условно были названы "plex" Дагласом Россом, о ком подробней будет сказано далее), Кей попытался объединить идею "плексов" из Algol, классов из Simula и обощенных структур данных из Sketchpad.

Общая идея системы, над которой он работал, заключалась в создании сети компьютерных процессов, которая не позволяет процессам напрямую изменять состояния друг-друга. Вместо этого процессы должны были отправлять друг другу запросы в виде правильно сформированных сообщений. Так, для изменения какого-то значения один процесс посылал сообщение с новым значением другому процессу, который отвечал за данную область памяти. Процесс-получатель читал сообщение и принимал окончательное решение о том, нужно ли изменять значение в памяти или нет. Это позволяло программисту, работающему в такой системе, вместо простых инструкций с присваиванием значений отдельным переменным писать более абстрактные инструкции, описывающие желаемый окончательный результат. Процессы же сами должны были выбирать правильные инструкции для достижения результата. Алан Кей позже говорил,
> “Smalltalk – это рекурсия идеи компьютера. Вместо того, чтобы разделять компьютер на отдельные составляющие, каждая из которых менее полезна, чем весь компьютер целиком – как, например, структуры данных, процедуры, функции – каждый объект в Smalltalk рекурсивно отражает все возможности компьютера”.

Каждый объект является интерпретатором сообщений, которые обрабатываются на основе конкретного синтаксиса, поглощая сообщения и отвечая только на те, которые написаны в понятной объекту форме. Окончательной целью является рекурсивный дизайн программ, в которых каждая отдельная часть обладает всеми возможностями своего целого.
### Объекты
Эта концепция появилась не на пустом месте. Кей был биологом по первому образованию и часто обращался к билогии за вдохновением. Для своей системы он выбрал поведение биологических клеток, которые защищены от внешнего мира мембраной, но могут обмениваться информацией с другими клетками с помощью специальных белков и соответствующих рецепторов. Кею эта модель нравилась тем, что систему, построенную по такому принципу, можно расширять до бесконечности, получая результат любой сложности (по аналогии с тем, как из одних и тех же клеток с помощью ДНК получаются разные организмы).

Кей предполагал, что и в компьютерных системах возможно создание программы любой сложности из обобщенных процессов, которые работают каждый по своим правилам, отвечают каждый за свою зону ответственности и взаимодействуют друг с другом согласно определенным протоколам. Прототипом такой системы стал Интернет. Компьютеры инкапсулируют и данные в памяти, и вычислительный процесс, а объединение таких процессов в общую сеть позволяет приумножать их вычислительные возможности.
> \[Интернет\] включает в себя миллиарды полностью инкапсулированных объектов (сами компьютеры) и использует "чистую" систему сообщений, состоящую из запросов, а не инструкций.

Это привело Алана Кея к простой модели, согласно которой могла быть написана любая компьютерная программа:
* базовой исполняющей сущностью является вычислительный процесс;
* процесс создает и поддерживает операции над сегментами данных в памяти;
* операции поддерживают параллельное исполнение;
* процессы должны отвечать на события (где событие - event - понимается как действие, распознаваемое в системе, происходящее асинхронно основному выполнению программы, которое может быть как-то программой обработано в ответ на соответствующий сигнал от системы);
* и т.д.

### Sketchpad – a man-machine graphical communication system
Чтобы в полной мере оценить важность Sketchpad для ООП, надо отметить, что Алан Кей называл эту работу "наверное, самой значимой дипломной работой в истории". Стоит только добавить, что Кей также называл Sketchpad первой "объектно-ориентированной" системой. Несколько свойств Sketchpad были напрямую переняты в Smalltalk, для того, чтобы он мог быть по-настоящему объектно-ориентированным языком.

#### Master - instance
В Sketchpad дизайнер оперировал световым пером для того, чтобы создавать на экране компьютера чертежи. Чертежи организовывались в иерархию, в которой была главный чертеж (master drawing), изменения которого отражались на всеъ копиях главного чертежа. Копии или "экземпляры" (instances) создавались на основе главного чертежа, повторяя все его свойства, причем изменения одной копии никак не отражались на остальных элементах чертежа. Экземпляры можно было использовать для создания новых "рекурсивных" иерархий любой степени вложенности. Этот принцип позже лег в основу иерархий наследования, которые создавались в Smalltalk.

#### Constraints
Между фигурами на чертежах устанавливались определенные отношения. Например, можно было обозначить две линии отдельной фигуры параллельными, чтобы независимо от последующих манипуляций (повороты, уменьшение, увеличение экземпляров) это свойство гарантированно сохранялось. За сохранение таких отношений - атомарных ограничений - отвечал отдельный процесс.

За управление объектами, своевременное и правильное применение процедур к ним и т.п. отвечал процесс "разрешения ограничений", который решал динамическую задачу, когда задача по манипуляции фигурой ставилась действиями пользователя. То есть, пользователю нет необходимости явно задавать все шаги, нужные для правильного поворота экземпляра, достаточно просто обозначить свое намерение посредством интерфейса программы, и "решатель" запускал все нужные процедуры в правильной последовательности. Такая "непроцедурная" система описания программ стала одним из самых ранних примеров декларативного программирования.

## SIMULA - Monte Carlo simulation language
> "SIMULA должен быть задачно-ориентированным языком, не компьютеро-ориентированным, даже если это подразумевает заметное увеличение работы, которую компьютер должен будет выполнять."

Это слова одного из разработчиков языка SIMULA, который разрабатывался в Норвегии начиная с 1962 года. Первоначально предназначенный для симуляции событий в сложных индустриальных системах (конкретней, в "сетях дискретных событий"), язык со временем превратился в систему, позволявшую создавать иерархии сущностей в рамках какой-то классификации. Язык был надстройкой для языка Algol 60, что в некоторой мере ограничивало возможности разработчиков компилятора для SIMULA (например, работа с памятью в Algol вынуждала выбирать не самые лучшие решения для реализации компилятора). Как говорил другой разработчик в том же 1962 году:
> "Уже сейчас понятно как описывать системы с очередями для событий в нашем Монте Карло компиляторе, и были разработаны концепции, позволяющие легко описывать большие **классы** ситуаций."

Слово "классы" стоит отдельно выделить, так как оно будет иметь большое значение для ООП в дальнейшем.

В первых версиях языка основным элементом дизайна был "процесс". Этот модуль был простейшим элементом в программе, и программа состояла из комбинаций процессов, взаимодействующих друг с другом. Процессы могли быть двух видов: станции (активные компоненты) или клиенты (пассивные компоненты).
```BNF
system <identifier> := <station list>
station <identifier>;<statement>
customer <customer list>
```
Клиенты можно было организовать в список:
```BNF
<identifier>(<list of characteristics>)[<upper limit of customers>] 
```  
Станция состояла из очереди и сервиса (операций, которые описывали правила обращения и реализовались на языке Algol). Очередь -- это упорядоченное "множество" процессов, где идея множества повторяла похожую концепцию из языка Algol (condition variables), которые манипулировались двумя специальными операциями wait и signal. Сервисы представляли собой абстракцию "работы", а вся программа -- сеть (граф) сервисов.

Клиент состоял из переменных, которые выполняли роль его "характеристик". Все клиенты имели общую переменную "время" и общую процедуру "позиция", которые использовались для симуляций. Клиент создавался сервисом какой-то станции, после чего он передавался в очередь либо этой же, либо другой станции. Из очереди клиент попадает в сервис соответствующей станции. Если сервис не помещал клиент в одну из очередей, клиент удалялся.

Со временем множества были изменены таким образом, чтобы в них можно было хранить процессы любых видов. Это делалось с помощью указателей на процессы. Такое "абстрактное множество" было реализовано в виде связного циклического списка и стало основой обобщенных списков в языке. Дополнительным эффектом такого подхода была возможность хранить один и тот же процесс в разных списках одновременно, используя ссылки ("элементарные объекты") на него.

Эти изменения потребовали отказаться от коцепции "сети сервисов", что сделало необходимым инкапсулировать все данные в соотвествующем процессе.
```Algol
inspect <process reference>
        when passenger do ...
        when staff do ...
        otherwise ...
```
Система стала коллекцией процессов вместо графа событий и переходов между ними. Каждый процесс был отдельным объектом в памяти. Процессы хранились на стеке, а стек в Algol был не очень удобен для работы таких программ. Программы описывали параллельные процессы, которые на стеке не могли выполняться параллельно. Для решения этой проблемы была написана новая система выделения памяти, где вместо одномерного стека память выделялась в двумерном массиве-таблице. Это позволило создавать процессы не просто как структуры данных, а как полноценные подпрограммы, которые были легко параллелизуемы.
```Algol
system Airport := arrivals, counter, fee collector, control, lobby;
customer passenger (fee paid) [500];
        Boolean fee paid;
        station counter;
begin accept (passenger) select:
        (first) if none: exit;
        hold (normal (2, 0.2));
        route (passenger) to:
                (if fee paid then control else fee collector)
end;
```
Основным итогом этих переработок стало то, что операции и данные хранились вместе, инкапсулированные в единый процесс.
> "Данные и операции над ними должны быть вместе, и самые полезные модули в программах содержат и то, и другое."

Так как процессы обращались друг к другу напрямую, необходимо было переделать механизмы доступа к атрибутам процесса. Была заимствована идея "классов-записей" "Тони" Хора, которую разрабатывали для Algol. Компилятор проверял доступность характеристик процесса через наличие правильной ссылки, Во время работы программы к ссылкам на процесс имели доступ его подпроцессы ("подклассы").

Это навело разработчиков на мысль, что те или иные процессы часто входят в отношения с другими процессами, и эти отношения имеет смысл описывать в программе заранее. Природа этих отношений заключалась в доступности характеристик для подпроцессов, то есть, несколько подпроцессов могло читать значения атрибутов родительского процесса.

Эти изменения привели к тому, что язык эволюционировал в новую версию, более общего назначения, чем просто язык для индустриальных симуляций. Дополнительно в язык был добавлен сборщик мусора, заимствованный из языка Lisp. Это дало возможность назначать стартовые значения для атрибутов процесса при его создании и очищать память, занятую процессом при его удалении.

Механизм параметризации операций не удовлетворял разработчиков компилятора в полной мере, поэтому было принято решение использовать отношения между процессами и подпроцессами для определения типов параметров. Все это в совокупности привело к возникновению понятий "класс" и "подкласс" в языке.
```Algol
class Point; real x, y;
begin
boolean procedure equals(p); ref(Point) p;
        if p =/= none then 
        equals := abs(x - p.x) + abs(y - p.y) < 0.00001;
real procedure distance(p); ref(Point) p;
        if p == none then error
        else distance := sqrt((x - p.x)**2 + (y - p.y)**2);
end
```
Подклассы процессов представляли собой описания со своими собственными операциями и локальными данными (аналогично объектам-функциям в Lisp). Для иллюстрации этой идеи можно использовать знакомый механизм в языке С:
```C
struct Point {
        double x, y;
        bool (*equals)(struct Point *this, struct Point *p);
        double (*distance)(struct Point *this, struct Point *p);
};

bool procedure_equals(struct Point *this, struct Point *p) {
        if (p != NULL) {
                return (fabs(this->x - p->x) + fabs(this->y - p->y)) < 0.00001;
        }
        return false;
}

double procedure_distance(struct Point *this, struct Point *p) {
        assert(p != NULL);
        return sqrt(pow(this->x - p->x, 2) + pow(this->y - p->y, 2));
}

int main(void) {
        Point p    = {.x=1, .y=1};
        p.equals   = procedure_equals;
        p.distance = procedure_distance;
}
```
(Минусом такого подхода было то, что правила замены невозможно проверить во время компиляции программы).

Для сравнения ниже приводится похожая конфигурация классов в языке Smalltalk.
```Smalltalk
class Page;
begin
        class Print_Block(Width,Length);integer Width, Length;
        begin
            ref(Print_Block)Next;
            text array Contents(1:Length);
            integer Count;
            for Count:=1 step 1 until Length do Contents(Count):-Blanks(Width)
        end--of--Print_Block;

        Print_Block class Title_Block(Title);text Title;
        begin
            Contents(Length//2):=Title
        end--of--Title_Block;

        Print_Block class Text_Block;
        begin
            for Count:=1 step 1 until Length do
            begin
               InImage;
               Contents(Count):=Intext(Width)
            end
        end--of--Text_Block;
end..of..Page;
new Page;
```
Общие свойства классов можно группировать так, чтобы они применялись позднее, т.о. можно было описывать программы, в которых определение свойств не известно заранее. Для поддержания этой системы был реализован механизм "виртуального класса". Этот механизм был необходим для предоставления доступа к операциям объекта: параметр (операция) объявлялся на уровне самого верхнего класса; определение параметра включалось в объект подкласса. 

### Абстрактный тип данных
Такой подход позволял получать обобщенные объекты, поведение которых было частично не определено в ходе работы программы, и которое можно было динамически заменить. Так, в зависимости от используемого подкласса поведение объекта из семейства подклассов могло отличаться. 

В системе Sketchpad была определена иерархия - "вселенная" - возможных объектов: скаляров, точек в системе координат, строк текста и т.д. Возможные ограничения тоже формировали одну ветку данной иерархии. Все элементы данной иерархии описывались структурами данных в памяти программы. Все они имели общие свойства, но также каждый тип объекта имел уникальные свойства, которые отличали его от других типов объектов. Так, все структуры содержали поле "тип", для динамического определения типа текущего экземпляра; поле "имя" позволяло называть экземпляры; поле "вид" обозначало характер отображения; поле "дисплей" хранило процедуру ("подпрограмму") для отображения экземпляра; поле "движение" определяло процедуру для трансформаций на экране и т.д. Таким образом, в одной записи в памяти инкапсулировались и данные, и возможные операции над этими данными. 

Алан Кей понимал, что такой подход является хорошей моделью для его системы независимых объектов, которые можно комбинировать в любой конфигурации. На его вопрос Сазерленду: как тому удалось сделать первую интерактивную графическую программу, первый декларативный язык программирования и первую объектно-ориентированную систему - Сазерленд отвечал, что он просто тогда не знал, что это сложно. Несмотря на это, у Sketchpad было одно свойство, которое Алан Кей не стал переносить в свою систему. Как он позже объяснял:
> "Еще одной важной системой, созданной в этот период, была Thinglab Алана Борнинга - первая серьезная попытка пойти дальше, чем Sketchpad. Алан придумал красивый подход к решению задач с ограничениями, в котором разрешающий процесс не обязан был быть всезнающим (т.е. не требовал знать состояние всей системы в каждый момент времени)."

Это важное замечание, которое дает представление о том, что Алан Кей считал критичным для дизайна объектно-ориентированных систем. Сокрытие данных было одним таким критичным свойством. Оно позволяло полностью отказаться от операций присваивания в языке и, как следствие, мотивировать программиста мыслить о программах в новой парадигме. Кей называл свои процессы "объектами", откуда и пошел термин "объектно-ориентированное программирование". Поэтому данный курс будет использовать следующее определение объекта в дальнейшем.

Объект - это описание вычислительного процесса или семейства процессов, которое скрывает свои данные от внешней среды и может работать независимо от других объектов, взаимодействуя с ними с помощью сообщений, отправленных согласно какому-то протоколу. В рамках данного курса рассматриваются три главных элемента, которые использовал в своей работе Алан Кей: абстрактные типы данных, классы и обобщенные структуры данных.

Одним из главных направлений в дизайне языка был отказ от использования абстрактных типов данных в их привычном понимании. Дизайн Smalltalk требовал абсолютной защиты состояния объекта от внешнего воздействия (например, полный отказ от “сеттеров” и “геттеров”). Результатом такого подхода является стратегия позднего связывания (тип объекта определяется в момент обращения к нему на основании формы сообщения, что в других языках достигается засчет динамического полиморфизма. Алану Кею хотелось добиться обобщенного поведения объектов, которое зависит от символов в сообщении, а не от типа данных самого объекта. 

Ниже представлен пример реализации простого класса в Smalltalk-72.
```Smalltalk
to True | truthValue |
(
    @ifTrue => (trueBlock (ifFalse (falseBlock (^trueBlock value))))!
    @ifFalse => (falseBlock (ifTrue (trueBlock (^trueBlock value))))!
    @ifTrue => (trueBlock (^trueBlock value))!
    @ifFalse => (falseBlock (^nil))!
    @not => (^false)!
    @& :aBoolean => (^aBoolean)!
    @| :aBoolean => (^true)!
    @eqv :aBoolean => (^aBoolean)!
    @xor :aBoolean => (^aBoolean not)!
    @and :aBlock => (^aBlock value)!
    @or :aBlock => (^true)!
    @printOn :aStream => (aStream nextPutAll :'true')!
)! 
```
Класс True объявляется как экземпляр класса Boolean, он имеет внутреннее состояние truthValue и список поддерживаемых методов. Каждый метод ассоциируется с определенным сообщением (сообщение отмечается символом @ – "посмотреть"): например, в случае (=>) получения сообщения, начинающегося с термина or, необходимо посмотреть (@) в классе соответствующую строку ("or"), трактовать остаток сообщения как некий обобщенный блок aBlock и вызвать метод (^true), где символ ^ означает "вернуть". То есть, тело класса представляет собой "словарь" всех сообщений, которые класс может обработать, и методов обработки соответствующих сообщений.

Таким образом, объект сам решает: отвечать или не отвечать на сообщения -– в зависимости от того, как они сформулированы. Также объект сам решает, как именно ответить на каждое сообщение: если часть сообщения состоит из других объектов, выполнение метода приостанавливается, и остаток сообщения передается следующему в цепочке объекту, где оно также обрабатывается по аналогичной схеме. (Это очень похоже на принцип вычисления, предложенный Бакусом в своей статье) Результатом такого подхода к созданию сложной системы является ее гибкость и резистентность. 

Если один или несколько компьютеров в сети внезапно перестанут существовать, сама сеть от этого не пострадает в такой мере, какая могла бы вызвать сбой всей системы. С момента ввода сети Интернет в работу ее ни разу не приходилось полностью выключать "на профилактику", при этом все составные компоненты системы были заменены не один раз. Так и с объектами: при возникновении ошибки в одном объекте, она не распространяется по всей системе, бругие объекты могут изолировать место, где возникла ошибка, и программу не понадобится останавливать.

Это и является основной целью объектно-ориентированной парадигмы в ее первоначальном представлении: предоставить инструменты для создания систем, состоящих из бесконечного количества самостоятельных сущностей, которые не могут быть изменены извне. Вместо привычных операций присваивания и статического связывания (инициализация переменных в языке С, например), используется отправка сообщений в классы через их экземпляры.

Тем интересней наблюдать за развитием такого языка, как С++, потому что он долгое время считался и считается одним из самых популярных объектно-ориентированных языков. Он также заимствовал идеи из Simula, но пошел по пути, отличному от того, по которому эволюционировал дизайн Smalltalk. 

Например, в Smalltalk изначально не было концепции наследования, потому что 
> в Simula \[наследование\] часто являлось источником кошмаров (слишком много возможностей из одного механизма, различных семантически). 

В С++ наследование появилось практически сразу. Так становится очевидным фундаментальное расхождение во мнениях двух дизайнеров о том, что именно является объектно-ориентированным программированием.