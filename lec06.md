# Полиморфизм
## Отношение полиморфизма к ООП
В 2011 году Роберт Мартин -- известный под прозвищем "дядюшка Боб" публицист в сфере программного обеспечения и пропонент ООП -- сделал следующую ремарку.

> ООП -- это, на самом деле, полиморфизм, в основном. Все остальное можно было сделать в С. Полиморфизм тоже можно было сделать в С, но для этого надо было повозиться с указателями на функции. Собственно говоря, большой пользой от использования С++ было то, что указатели на функции получались без возни с указателями на функции -- синтаксис языка скрывал их в виртуальной таблице, скрывая и виртуальную таблицу тоже. Программисту нужно было только написать виртуальную функцию и использовать наследование. Т.е. ООП -- это дисциплина, навязанная непрямой передаче управления программой. Взамен мы получили возможность структурировать модули в программе таким образом, что зависимости в них направлены в сторону, обратную потоку управления. В хорошей ОО-программе, а это и есть признак хорошей программы, ключевые зависимости перевернуты, чтобы идти против потока управления. Это достигается засчет полиморфизма. Т.о. ООП -- это полиморфизм.

Эти слова во многом пересекаются с тем, что говорил и Александреску ("ООП -- это программирование с помощью еще не написанных функций"), и Строуструп ("ООП -- это программирование через наследование, используя абстрактные классы"). Но Мартин намеренно подчеркивает, чему служат абстрактные классы -- получению полиморфных функций, вызов которых происходит без прямого участия пользователя, то есть -- это программирование с помощью функций, которые могли был не определены в модуле, а только объявлены. Поэтому он на первый план выводит именно полиморфизм, а не наследование. Для него наследование -- это всего лишь инструмент для достижения полиморфизма.

Само слово "полиморфизм" популяризовал профессор Кристофер Стрейчи -- глава департамента Информатики Оксфордского университета -- в своей серии лекций "Фундаментальные концеции в языках программирования" (1967).

> В более продвинутых языках программирования тип данных используется для того, чтобы определить вид конкретного объекта (ограничить диапазон возможных видов до одного). Также ожидается, что компилятор проверит программу на глупые ошибки (напр., попытки перемножить две текстовые строки), а также интерпретирует двоякие символы, встречающиеся в программе (напр., +), которые имеют разное значение в зависимости от типов операндов. Мы называем такие двоякие операторы *полиморфными*, так как у них есть несколько форм, в зависимости от аргументов.

Из этой цитаты видно, что полиморфизм, в первую очередь, используется для описания поведения функций, и изначально закрепился как термин именно в функциональном программировании. Тем не менее, его всегда упоминают как важнейший аспект и ООП.

Вот пример, который Алан Кей приводит в связи с этим.

|приемник|сообщение|результат|
|-|-|-|
|a|+ b||
|3|+ 4|7|
|"kitty"|+ "kat"|"kittykat"|
|[[3 4 5][6 7 8]]| + 4|[[7 8 9][10 11 12]]|

В Smalltalk интерпретатор крайнего слева объекта в строке сначала потребляет все остальное сообщение, затем разбивает его на токены и вызывает соответствующие методы. В примере первая строка вызовет метод "+" объекта "а", аргументом для этого метода будет объект b. Вторая строка -- такой же метод объекта "3" (который является целочисленным типом), аргументом будет объект "4" такого же типа, поэтому используется реализация сложения для целых типов. В третьей строке -- строка "kitty" вызовет метод конкатенации для строки-аргумента "kat". В четвертом -- аналогично будет произведено матричное сложение со скалярным значением.

Так как в Smalltalk связывание типов аргументов происходит поздно, все методы являются полиморфными, но Алан Кей старался не употреблять этот термин.
> Для символов поведение определялось общим способом (generic). Это принято называть "полиморфизмом", но [для Smalltalk] термин не совсем точен, так как обычно его ассоциируют с функциями, принимавшими более одного типа аргументов.
## Виды полиморфизма
> Эволюция языков программирования от систем без типов данных к мономорфным и затем полиморфным системам [привела к появлению] механизмов для полиморфизма -- перегрузка, приведение, подтипы и параметризация -- а также единого подхода к созданию полиморфных систем типов данных в терминах λ-исчисления, которое дополняется типами, связыванием типов аргументов через квантификацию и связыванием значений аргументов через абстракцию.

Как видно из цитаты Карделли выше, со времен языков B и CPL, которые создавались во времена и при участии Стрейчи, полиморфизм как концепция оброс своими особенностями. Упомянутые выше виды полиморфизма стоит рассмотреть подробней.
### Приведение типов (type coercion)
Пример с выражением *(a + b)* интересен тем, что имеет несколько простых решений. В зависимости от типа обоих аргументов есть несколько возможных сценариев. Если типы аргументов совпадают, компилятор в состоянии найти соответствующую версию функции. Если же типы не совпадают, и нет точно подходящей версии функции, сначала нужно снять противоречие. Первый способ -- выбрать один из двух типов как более "общий", и привести к этому типу значение другого аргумента. Например, целое число можно привести к числу с плавающей запятой без потери данных, поэтому при попытке сложить числа (2) и (4,5), выражение можно преобразовать в форму *(2.0 + 4.5)*, после чего вызывать соответствующий оператор.

Если необходимо добиться такого эффекта для пользовательского типа данных, в С++ для этих целей позволяется создавать два специальных метода класса.

    struct B {
        // приведение из типа A (конструктор)
        B(const A &x) { ... }
        // приведение из типа А (присваивание)
        B& operator=(const A &x) { ...return *this; }
        // приведение к A
        operator A() { return A(...); }
    };
Для произвольного типа данных *А* можно создать в своем классе *В*:
1. конструктор приведения типа, который принимает тип А в качестве аргумента и конструирует объект своего класса с помощью значения аргумента типа А;
2. оператор присваивания с таким же типом аргумента в пару конструктору;
3. оператор приведения типа, создающий подходящий объект типа А из объектов типа В.
### Перегрузка функций (overloading)
Пример с выражением *(a + b)* позволяет решить задачу с разными типами аргументов другим -- более трудоемким -- способом. Если потеря данных при вызове функции не желательна, можно написать специальную версию функции для конкретных типов, чтобы исключить приведение.
    
    // для произвольных типов А и В:
    A operator+(A a, B b) { ...return A(); }
    B operator+(B a, A b) { ...return B(); }

    int main( ) {
        A() + B();
        B() + A();
    }
Сгенерированный код выглядит так:

    "operator+(A, B)":
        push    rbp
        mov     rbp, rsp
        ...
        pop     rbp
        ret
    "operator+(B, A)":
        push    rbp
        mov     rbp, rsp
        ...
        pop     rbp
        ret
    "main":
        push    rbp
        mov     rbp, rsp
        call    "operator+(A, B)"
        call    "operator+(B, A)"
        ...
Типы аргументов просто становятся частью имени процедуры, поэтому они не конфликтуют. Из такого подхода есть несколько следствий. 

Перегружать любую функцию можно только через добавление в код дополнительного определения функции с соответствующими типами аргументов. Также важно понимать, что возвращаемое значение функции не влияет на перегрузку и может быть любого типа. Это может сильно повлиять на поведение сделанного таким образом "полиморфного" оператора. В примере из Smalltalk в таблице выше при версии оператора "+" для целых чисел результатом будет целое число, для строк -- строка, для матриц -- матрица. Для произвольных аргументов типов *А* и *В* над типом результата нужно глубоко думать. Очевидно, что перегрузка конструкторов класса работает таким же образом и подвержена тем же эффектам.

Но даже с одним типом аргументов функции при перегрузке есть над чем подумать.

    int prod(int (&a)[10], int (&b)[10]) {
        int k = 0;
        for(size_t i = 0; i < 10; i++) {
            k += a[i] * b[i];
        }
        return k;
    }

    std::string prod(std::string (&a)[10], std::string(&b)[10]) {
        std::string k = “”;
        for(size_t i = 0; i < 10; i++) {
            k += a[i] + b[i];
        }
        return k;
    }
Пример со скалярным произведением векторов это иллюстрирует. Если векторы содержат целые числа, оператор/функция выглядит элементарно. Но если векторы содержат, например, строки, логика оператора меняется. Произведение строк придется имитировать через повторную конкатенацию. Возвращать придется не скалярное значение, а результат конкатенации всех строк в обоих векторах. Т.е. даже такая, "правильная" перегрузка нарушает математические свойства оператора. Так, операция сложения обладает, среди всего прочего, следующим свойством:

    3 + 4 = 4 + 3 = 7
что для строк не выполняется, так как они не являются нужной для этого категорией значений:

    "3" + "4" ~= "4" + "3"
         "34" ~= "43"
### Параметризация
Некоторые из недостатков перегрузки можно нивелировать, используя другой вид полиморфизма. В языке С++ присутствует механизм, позволяющий перекладывать ответственность за перегрузку функций на компилятор, используя язык "шаблонов". Перед функцией достаточно написать ключевое слово template и указать в специальном списке количество типов аргументов (или конкретно сами типы, что не обязательно), как показано в примере ниже. 

    template <typename T, size_t n>
    auto prod(const T(&a)[n], const T(&b)[n]) {
        T k = T{};
        for(size_t i = 0; i < n; i++) {
            k.sum(a[i].mul(b[i]));
        }
        return k;
    }

Фрагмент 
    
    template <typename T, size_t n>
объявляет шаблон, который определяет два типа данных: произвольный тип под общим именем T, обозначающий то, что этот символ можно заменить на любой существующий тип данных в последствии; конкретный тип size_t, который определяет константу n, чтобы ее можно было использовать в качестве размера параметра-массива.

О шаблонах подробно речь пойдет в следующих разделах, а в данном примере надо понять только то, что шабло не является непосредственно выполняемой функцией, поэтому не требует конкретизировать данные. При попытке использовать шаблон в программе, препроцессор определит тип переданных аргументов и вычислит как правильно должен выглядеть вызов функции.

    auto x = prod({1, 2, 3}, {4, 5, 6});
Данный вызов производится для двух массивов, состоящих из целых чисел, поэтому код функции должен выглядеть так:

    auto prod(const int(&a)[3], const int(&b)[3]) {
        int k = int{};
        for(size_t i = 0; i < 3; i++) {
            k.sum(a[i].mul(b[i]));
        }
        return k;
    }
Препроцессор вынужден будет сначала синтезировать такую версию шаблонной функции, чтобы проверить ее на правильность. Если после подстановки конкретных аргументов вместо шаблонных T и n будет обнаружено какое-то несоответствие правилам для этих типов и значений, компилятор выдаст ошибку компиляции.

В примере выше можно увидеть, что попытка вызвать методы sum и mul не сможет быть скомпилирована, потому что у типа int, который подставится в шаблон, нет таких методов, следовательно исспользовать int для такого шаблона нельзя. Для любых других типов, у которых такие методы будут, этот шаблон сгенерирует правильный код. Из этого можно сделать важный вывод: так как в шаблоне от типов данных зависят только шаблонные аргументы, код, не подверженный замене при подстановке, должен быть правильным для любых заменяемых типов. Другими словами, функция, использующая шаблоны, должна быть универсальна. В то же время, использование перегрузки для получения такого же эффекта позволяет писать функции с различающимся кодом, специализируя функции под конкретные типы данных.

Таким образом, на этом примере видно, что полиморфизм можно разделить на два условных типа: универсальный и специальный -- по принципу единства или разности в структуре полиморфной функции. Полиморфизм также принято разделять на два вида по другому принципу.
## Статический и динамический полиморфизм
В примерах выше, независимо от того, используется перегрузка или шаблон, тип данных всех аргументов функции известен компилятору заранее. В случае перегрузки это нужно, чтобы компилятор проверил правильную версию функции из набора перегрузок. В случае шаблона это нужно чтобы компилятор проверил сгенерированную на основании шаблона специализацию-кандидата. Все, что делается во время компиляции (до непосредственного запуска скомпилированной программы), называется "статическим" процессом. Другой вид процесса -- динамический, который происходит уже после компиляции -- в ходе работы программы, так как нужная информация для проверки заранее компилятору не была доступна. 
### Виртуальные методы
Язык С++, аналогично другим похожим языкам, позволяет писать функции, типы параметров которых невозможно определить из написанного кода. Такие функции вынуждены оперировать какими-то общими свойствами некоторой группы типов данных, заранее не зная, какой конкретно тип из той или иной группы будет в функцию передан во время вызова, т.е. используют "динамический полиморфизм" или "динамическую диспетчеризацию".

    class abstract_data_t {
    public:
        virtual iterator find(int) = 0;
        …
    };

    class list : public abstract_data_t {
    public:
        iterator find(int) override;
        …
    private:
        struct node { int v{}; struct node *next{nullptr}; }
        node *p{nullptr};
    };

    class vector : public abstract_data_t {
    public:
        iterator find(int) override;
        …
    private:
        int *p{nullptr};
    };
Пример иллюстрирует иерархию наследования, похожую на код из прошлого раздела, посвященного виртуальным функциям. Классы vector и list наследуют абстрактный класс и переопределяют один и тот же метод find (а так же и другие методы интерфейса, если они есть в абстрактном классе). Реализация этих переопределений будет отличаться от класса к классу, так как структуры данных используются разные. Прототипы методов в обоих классах выглядят одинаково, поэтому вызовы любого из них будут совпадать. Фрагмент ниже это иллюстрирует. 

    abstract_data_t *a = new vector{1, 2, 3, 4};
    abstract_data_t *b = new list{5, 4, 3, 2, 1};
    …
    a->find(4);
    b->find(4);
Объекты a и b являются представлениями одного и того же интерфейса, который содержит функцию find, но по факту они ссылаются на экземпляры разных классов. Классы list и vector не являются подтипами друг-друга, но могут быть использованы друг вместо друга, так как они имеют общий родительский тип, который гарантирует одинаковое поведение всех своих подтипов. Интерфейс здесь является объединяющим свойством для группы его подтипов. Соответственно, во время работы программы в качестве объекта, который предоставляет метод find, можно подставить любой из подтипов абстрактного класса abstract_data_t. Функции, использующие abstract_data_t в качестве параметра являются полиморфными, причем -- это динамический полиморфизм, который одновременно универсален, как в случае с шаблонами.
### Меченые объединения
Другим примером динамического полиморфизма является техника, которую широко применяют в языке С.

    enum tag { vector, list, set };

    union types {
        set s;
        vector v;
        list l;
    };

    struct variant {
        tag tag_;
        types type_;
    };
Используя структуру или класс, который содержит объединение из нескольких типов, а также поле, отмечающее текущий "активный" тип, можно получить ситуацию, аналогичную примеру с наследованием абстрактного класса.

    iterator find(const variant &var, int key) {
        auto it = iterator{};
        switch(var.tag_) {
        case vector:
            it = var.find(key);
            break;
        case list:
            it = var.search(key);
            break;
        case set:
            it = var.seek(key);
            break;
        default:
            break;
        }
        return it;
    }
Теперь функция find имеет параметр типа, содержащего объединение, и в теле функции необходимо описать случаи для всех возможных вариантов (в конкретный момент времени объединение может быть либо vector, либо list, либо set). Соответственно, функция теряет полную универсальность, но обретает некоторую гибкость, потому что интерфейсы вариантов не обязательно должны сопадать, достаточно, чтобы каждый из вариантов мог выполнить задачу по-своему.   

Здесь определение конкретного типа тоже происходит в ходе выполнения программы, но вместо виртуальной таблицы выбор правильного метода описан явно. Может показаться, что это снижает степень расширяемости метода find, так как с добавлением новых вариантов в объединение в методе придется писать еще один вариант выбора (case). С другой стороны, при добавления нового класса в иерархию наследования абстрактного базового класса, в новом классе придется переопределять все виртуальные методы. То есть, расширять программу приходится в обоих случаях, разница только в том, что именно подвергнется изменению: класс-параметр функции или тело функции.
## Перегрузка, приведение, подтипы и параметризация
Выше были рассмотрены примеры всех видов полиморфизма, которые выделял Карделли. Подводя итоги, универсальный полиморфизм характеризуется единой структурой, которая не зависит от конкретных типов и общая для всех случаев, в С++ достигается с помощью подтипов и параметризации. Специальный полиморфизм характеризуется разной структурой, которая может изменяться в зависимости от конктетных типов, в С++ достигается с помощью приведения типов и перегрузки функций. Статический полиморфизм проверяется компилятором, поэтому подвержен проверкам системы типов данных языка. Динамический полиморфизм не может быть проверен во время компиляции, что позволяет заменять типы данных уже в ходе работы программы. Более подробно динамический и статический полиморфизм рассматриваются в одной из следующих лекций.