# Полиморфизм
## Отношение полиморфизма к ООП
В 2011 году Роберт Мартин -- известный под прозвищем "дядюшка Боб" публицист в сфере программного обеспечения и пропонент ООП -- сделал следующую ремарку.

> ООП -- это, на самом деле, полиморфизм, в основном. Все остальное можно было сделать в С. Полиморфизм тоже можно было сделать в С, но для этого надо было повозиться с указателями на функции. Собственно говоря, большой пользой от использования С++ было то, что указатели на функции получались без возни с указателями на функции -- синтаксис языка скрывал их в виртуальной таблице, скрывая и виртуальную таблицу тоже. Программисту нужно было только написать виртуальную функцию и использовать наследование. Т.е. ООП -- это дисциплина, навязанная непрямой передаче управления программой. Взамен мы получили возможность структурировать модули в программе таким образом, что зависимости в них направлены в сторону, обратную потоку управления. В хорошей ОО-программе, а это и есть признак хорошей программы, ключевые зависимости перевернуты, чтобы идти против потока управления. Это достигается засчет полиморфизма. Т.о. ООП -- это полиморфизм.

Эти слова во многом пересекаются с тем, что говорил и Александреску ("ООП -- это программирование с помощью еще не написанных функций"), и Строуструп ("ООП -- это программирование через наследование, используя абстрактные классы"). Но Мартин намеренно подчеркивает, чему служат абстрактные классы -- получению полиморфных функций, вызов которых происходит без прямого участия пользователя, то есть -- это программирование с помощью функций, которые могли был не определены в модуле, а только объявлены. Поэтому он на первый план выводит именно полиморфизм, а не наследование. Для него наследование -- это всего лишь инструмент для достижения полиморфизма.

Само слово "полиморфизм" популяризовал профессор Кристофер Стрейчи -- глава департамента Информатики Оксфордского университета -- в своей серии лекций "Фундаментальные концеции в языках программирования" (1967).

> В более продвинутых языках программирования тип данных используется для того, чтобы определить вид конкретного объекта (ограничить диапазон возможных видов до одного). Также ожидается, что компилятор проверит программу на глупые ошибки (напр., попытки перемножить две текстовые строки), а также интерпретирует двоякие символы, встречающиеся в программе (напр., +), которые имеют разное значение в зависимости от типов операндов. Мы называем такие двоякие операторы *полиморфными*, так как у них есть несколько форм, в зависимости от аргументов.

Из этой цитаты видно, что полиморфизм, в первую очередь, используется для описания поведения функций, и изначально закрепился как термин именно в функциональном программировании. Тем не менее, его всегда упоминают как важнейший аспект и ООП.

Вот пример, который Алан Кей приводит в связи с этим.

|приемник|сообщение|результат|
|-|-|-|
|a|+ b||
|3|+ 4|7|
|"kitty"|+ "kat"|"kittykat"|
|[[3 4 5][6 7 8]]| + 4|[[7 8 9][10 11 12]]|

В Smalltalk интерпретатор крайнего слева объекта в строке сначала потребляет все остальное сообщение, затем разбивает его на токены и вызывает соответствующие методы. В примере первая строка вызовет метод "+" объекта "а", аргументом для этого метода будет объект b. Вторая строка -- такой же метод объекта "3" (который является целочисленным типом), аргументом будет объект "4" такого же типа, поэтому используется реализация сложения для целых типов. В третьей строке -- строка "kitty" вызовет метод конкатенации для строки-аргумента "kat". В четвертом -- аналогично будет произведено матричное сложение со скалярным значением.

Так как в Smalltalk связывание типов аргументов происходит поздно, все методы являются полиморфными, но Алан Кей старался не употреблять этот термин.
> Для символов поведение определялось общим способом (generic). Это принято называть "полиморфизмом", но [для Smalltalk] термин не совсем точен, так как обычно его ассоциируют с функциями, принимавшими более одного типа аргументов.
## Виды полиморфизма
> Эволюция языков программирования от систем без типов данных к мономорфным и затем полиморфным системам [привела к появлению] механизмов для полиморфизма -- перегрузка, приведение, подтипы и параметризация -- а также единого подхода к созданию полиморфных систем типов данных в терминах λ-исчисления, которое дополняется типами, связыванием типов аргументов через квантификацию и связыванием значений аргументов через абстракцию.

Как видно из цитаты Карделли выше, со времен языков B и CPL, которые создавались во времена и при участии Стрейчи, полиморфизм как концепция оброс своими особенностями. Упомянутые выше виды полиморфизма стоит рассмотреть подробней.
### Приведение типов (type coercion)
Пример с выражением *(a + b)* интересен тем, что имеет несколько простых решений. В зависимости от типа обоих аргументов есть несколько возможных сценариев. Если типы аргументов совпадают, компилятор в состоянии найти соответствующую версию функции. Если же типы не совпадают, и нет точно подходящей версии функции, сначала нужно снять противоречие. Первый способ -- выбрать один из двух типов как более "общий", и привести к этому типу значение другого аргумента. Например, целое число можно привести к числу с плавающей запятой без потери данных, поэтому при попытке сложить числа 2 и 4,5, выражение можно преобразовать в форму *(2.0 + 4.5)*, после чего вызывать соответствующий оператор.

Если необходимо добиться такого эффекта для пользовательского типа данных, в С++ для этих целей позволяется создавать два специальных метода класса.

    struct B {
        // приведение из типа A (конструктор)
        B(const A &x) { ... }
        // приведение из типа А (присваивание)
        B& operator=(const A &x) { ...return *this; }
        // приведение к A
        operator A() { return A(...); }
    };
Для произвольного типа данных *А* можно создать в своем классе *В*:
1. конструктор приведения типа, который принимает тип А в качестве аргумента и конструирует объект своего класса с помощью значения аргумента типа А;
2. оператор присваивания с таким же типом аргумента в пару конструктору;
3. оператор приведения типа, создающий подходящий объект типа А из объектов типа В.
### Перегрузка функций (overloading)
Пример с выражением *(a + b)* позволяет решить задачу с разными типами аргументов другим -- более трудоемким -- способом. Если потеря данных при вызове функции не желательна, можно написать специальную версию функции для конкретных типов, чтобы исключить приведение.
    
    // для произвольных типов А и В:
    A operator+(A a, B b) { ...return A(); }
    B operator+(B a, A b) { ...return B(); }

    int main( ) {
        A() + B();
        B() + A();
    }
Сгенерированный код выглядит так:

    "operator+(A, B)":
        push    rbp
        mov     rbp, rsp
        ...
        pop     rbp
        ret
    "operator+(B, A)":
        push    rbp
        mov     rbp, rsp
        ...
        pop     rbp
        ret
    "main":
        push    rbp
        mov     rbp, rsp
        call    "operator+(A, B)"
        call    "operator+(B, A)"
        ...
Типы аргументов просто становятся частью имени процедуры, поэтому они не конфликтуют. Из такого подхода есть несколько следствий. 

Перегружать любую функцию можно только через добавление в код дополнительного определения функции с соответствующими типами аргументов. Также важно понимать, что возвращаемое значение функции не влияет на перегрузку и может быть любого типа. Это может сильно повлиять на поведение сделанного таким образом "полиморфного" оператора. В примере из Smalltalk в таблице выше при версии оператора "+" для целых чисел рещультатом будет целое число, для строк -- строка, для матриц -- матрица. Для произвольных аргументов типов *А* и *В* над типом результата нужно глубоко думать. Очевидно, что перегрузка конструкторов класса работает таким же образом и подвержена тем же эффектам.

Но даже с одним типом аргументов функции при перегрузке есть над чем подумать.

    int prod(int (&a)[10], int (&b)[10]) {
        int k = 0;
        for(size_t i = 0; i < 10; i++) {
            k += a[i] * b[i];
        }
        return k;
    }

    std::string prod(std::string (&a)[10], std::string(&b)[10]) {
        std::string k = “”;
        for(size_t i = 0; i < 10; i++) {
            k += a[i] + b[i];
        }
        return k;
    }
Пример со скалярным произведением векторов это иллюстрирует. Если векторы содержат целые числа, оператор/функция выглядит элементарно. Но если векторы содержат, например, строки, логика оператора меняется. Произведение строк придется имитировать через повторную конкатенацию. Возвращать придется не скалярное значение, а результат конкатенации всех строк в обоих векторах. Т.е. даже такая, "правильная" перегрузка нарушает математические свойства оператора. Так, операция сложения обладает, среди всего прочего, следующим свойством:

    3 + 4 = 4 + 3 = 7
что для строк не выполняется, так как они не являются нужной для этого категорией значений:

    "3" + "4" ~= "4" + "3"
         "34" ~= "43"
### Параметризация
Некоторые из недостатков перегрузки можно нивелировать, используя другой вид полиморфизма.

    template <typename T, size_t n>
    auto prod(const T(&a)[n], const T(&b)[n]) {
        T k = T{};
        for(size_t i = 0; i < n; i++) {
            k.sum(a[i].mul(b[i]));
        }
        return k;
    }
