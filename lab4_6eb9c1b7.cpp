/*
Лабораторная работа 4 - Перегрузка операторов

Используя предыдущую лабораторную с помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Для реализации простейших операций над объектами класса необходимо добавить в класс все нужные операторы. Ниже показаны примеры прототипов, из которых складывается интерфейс абстрактного типа данных.

Оператор присваивания operator= принимает один аргумент – ссылку на объект заданного класса. Оператор выполняет замену всех элементов коллекции объекта слева  от оператора на копии элементов коллекции объекта справа от оператора. Данный оператор семантически схож с конструктором копирования, поэтому в некоторых ситуациях они могут быть взаимозаменяемы. Оператор присваивания возвращает ссылку на измененный объект. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.

Оператор сравнения operator== принимает два аргумента: ссылку на объект заданного класса слева от оператора и ссылку на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их коллекции. Коллекции равны, если они содержат равное количество элементов, а также – если значение каждого элемента одной коллекции равно элементу другой коллекции на том же месте. Данный оператор повторяет логику метода is_equal. Аналогично реализуется обратный оператор сравнения operator!=. 

Оператор сравнения operator< принимает два аргумента: ссылку на объект заданного класса слева от оператора и ссылку на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргумент слева от оператора строго меньше аргумента справа от оператора, и “ложь” в противном случае. Сравнение производится лексикографически. Аналогично реализуются операторы operator<=, operator>, operator>=.

Оператор ввода из потока данных operator>> принимает два аргумента: ссылку на поток данных слева от оператора и ссылку на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из потока данных слева в объект справа от оператора. Оператор возвращает ссылку на измененный поток ввода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат. 

Оператор вывода в поток данных operator<< принимает два аргумента: ссылку на поток данных слева от оператора и ссылку на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из объекта справа в поток данных слева от оператора. Оператор возвращает ссылку на измененный поток вывода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.

Оператор доступа по индексу operator[] принимает единственный аргумент – беззнаковое целое число, обозначающее позицию элемента в массиве. возвращает ссылку на элемент коллекции, находящийся по заданному индексу. В отличие от метода at не проверяет индекс на несоответствие размеру коллекции. В случаях, когда pos >= length(), поведение метода не определено. Асимптотичность метода постоянная – O(1).

Метод count принимает один аргумент – целое число – и возвращает количество элементов коллекции, значение которых равно значению аргумента.

Метод contains принимает один аргумент – целое число – и возвращает булевое значение: “истинность”, если значение аргумента равно значению хотя бы одного элемента коллекции, и “ложь” в противном случае.
*/

#include <cassert>
#include <iostream>
#include <sstream>
// остальные необходимые библиотеки здесь

class abstract_data_t {
public:
    // методы из предыдущей лабораторной работы здесь

    // рекомендуемые прототипы функций:
    abstract_data_t &operator=(const abstract_data_t&);
    friend bool operator==(const abstract_data_t&, const abstract_data_t&);
    friend bool operator!=(const abstract_data_t&, const abstract_data_t&);
    friend bool operator<(const abstract_data_t&, const abstract_data_t&);
    friend bool operator>(const abstract_data_t&, const abstract_data_t&);
    friend bool operator<=(const abstract_data_t&, const abstract_data_t&);
    friend bool operator>=(const abstract_data_t&, const abstract_data_t&);
    int &operator[](size_t);
    friend std::ostream &operator<<(std::ostream&, const abstract_data_t&);
    friend std::istream &operator>>(std::istream&, abstract_data_t&);
    bool contains(int);
    size_t count(int);
private:
    // необходимые поля здесь
};

// код для проверки правильности выполнения задания:
int main(int argc, char const *argv[]) {
    std::stringstream ss{"1 3 5 7 9"};
    abstract_data_t a(5);
    ss >> a;
    assert(5 == a.length());
    assert(1 == a[0]);
    assert(9 == a[4]);
    std::cout << a;
    abstract_data_t b{a};
    assert(a == b);
    assert(3 == b[1]);
    assert(7 == b[3]);
    b[4] = 0;
    assert(0 == b[4]);
    assert(!b.contains(9));
    assert(b < a);
    assert(a > b);
    std::cout << b;
    abstract_data_t c;
    assert(0 == c.length());
    c = b;
    assert(b == c);
    c[1] = c[2] = 7;
    assert(7 == c[1]);
    assert(7 == c[2]);
    assert(3 == c.count(7));
    std::cout << c;
}
