# Шаблоны функций и типов
Шаблоны уже встречались в предыдущих частях, но до сих пор не обсуждалась их роль в программах. В первую очередь, шаблоны позволяют определять семейства классов или функций. Дополнительно, с их помощью можно определить альтернативные имена для уже существующих типов (аналогично typedef в языке С), семейства переменных и "концепции" -- особый вид ограничений, позволяющий проверять выполнение определенных условий при вызове функций и т.п.

Суть шаблона сводится к тому, что он позволяет создать "пустой" (обобщенный) класс (или функцию), который можно скомпилировать, не указывая его окончательную структуру. Вместо этого достаточно заменить типы данных или выражения в классе (или функции) на произвольные имена, которые при компиляции будут заменены на конкретные типы или вражения автоматически.

    template<class T, T::type n = 0> class X;
    
    struct S {
        using type = int;
    };
Пример выше показывает объявление шаблонного типа *X* и структуры *S*, которая использует альтернативное имя для типа int. Шаблон *X* в объявлении использует такое же альтернативное имя, то есть, для объявления шаблона можно использовать несуществующие имена, если компилятор может найти определения этих имен в дальнейшем.

    using U = X<S>;
Данная строка является правильной с точки зрения компиляции, так как можно определить конкретные типы всех участвующих в этом определении имен. Имя *U* -- это псевдоним для комбинации символов *X* и *S*, где имя *X* определено через *S*. Причем, *Х* полностью определяется *S*, потому что *Х* зависит от произвольного типа *T*, при этом тип *T* должен содержать имя *type*, которое может быть использовано как тип для константы *n*, при этом *n* должно быть инициализировано значением "0". Тип *S* удовлетворяет этим требованиям, поэтому он может использоваться в определении *X* для подмены символа *T*. Из этого есть интересное следствие. Любой тип или символ, который отвечает этим требованиям, может быть использован для определения *X*, как в примере ниже.

    template<class T, T::type n = 0> class X;

    struct Q {
        using type = long;
    };
    
    using U = X<Q>;
Структура *Q* содержит имя type, которое может быть типом для переменной, инициализированной нулем. 

Из примеров выше можно сделать некоторые выводы. Во-первых, шаблоны образуют формальную грамматику -- набор правил для замены символов или комбинаций символов, определяемых другими правилами, которые, в свою очередь, также определены какими-то правилами. Во-вторых, шаблоны позволяют писать определения, которые не зависят от конкретных типов, а зависят от абстракций. Аналогично типам, которые зависят от абстрактных типов в иерархиях наследования, шаблоны позволяют создавать семейства типов. Эти семейства типов можно использовать для написания полиморфного кода.
## Макросы и шаблоны
Может показаться, что шаблоны работают аналогично "макро"-определениям из языка С.

    #define pair(T, U) struct pair_##T##_##U { 
        T first;
        U second;
    }
Например, такой "макрос" при написании утверждения *pair(int, double)* будет с помощью простой текстовой подстановки заменен на следующий код,

    struct pair_int_double { 
        int first;
        double second;
    }
Аналогичный шаблон, который определяется так.

    template <typename T, typename U> class pair {
        T first;
        U second;
    };
При инстанциировании с помощью утверждения *pair<int, double>{};* создастся экземпляр шаблона,

    template <> class pair<int, double> {
        int first;
        double second;
    };
Разница между двумя этими примерами неочевидна. Главное отличие в том, что макрос не всегда определяет новую функцию или тип, а всего лишь задает порядок замены текста в коде программы перед компиляцией. Это механическая подстановка, которая не проверяется компилятором. Второе отличие в том, что макрос не определяет семейство типов или функций. В качестве более сложного примера можно рассмотреть функцию из прошлой лекции. 

    template <typename T, size_t n> T prod(const T(&a)[n], const T(&b)[n]);
Теперь на него можно взглянуть под другим углом: символ *prod* объявляет семейство функций, носящих это имя, а объединяются все функции данного семейства посредством символа *T* и константы *n*. В программе можно определить одну из функций данного семейства, создав ее экземпляр(ы). Все экземпляры шаблона являются конкретными функциями, которые отличаются друг от друга конкретными типами или выражениями, которые подставляются в экземпляр при его объявлении, как показано на примере ниже.

    auto result = prod({1, 2, 3}, {4, 5, 6});
Этот экземпляр использует массивы целочисленных значений в качестве аргументов. Следовательно, параметры экземпляра с помощью подстановки будут определены как массивы типа *int[3]* (символ *T* заменяется на тип отдельного элемента аргумента, символ *n* заменяется на размер аргумента).

Отсюда следует несколько важных свойств данного шаблона. Из него можно порождать бесконечно много экземпляров подстановкой разных типов. Но интересней другое: на аргументы естественным образом накладывается несколько ограничений. Первое ограничение -- размер массивов, который должен совпадать, т.е. нельзя создать экземпляр функции, передав ей два массива разных размеров. Второе ограничение -- тип данных элементов массива, который также должен совпадать для обоих аргументов. Это, в свою очередь, значит, что определение шаблона может не содержать эти проверки, так как любой экземпляр, не отвечающий данным требованиям, не может быть инстанциирован компилятором. 

Последнее важное следствие из этого, которое нужно упомянуть, состоит в том, что в ходе работы программы все экземпляры уже заведомо созданы, а значит их создание не влияет на производительность программы, но влияет на производительность во время компиляции. Каждый экземпляр функции или класса из конкретного семества должен быть проверен компилятором на правильность, поэтому их все необходимо сгенерировать, что значительно увеличивает количество компилируемого кода.  
## Динамический и статический полиморфизм
Можно отметить, что на стадии компиляции шаблоны технически не отличаются от перегрузки. Независимо от того, используется перегрузка или шаблон, тип данных всех аргументов функции известен компилятору заранее. В случае перегрузки это нужно, чтобы компилятор проверил правильную версию функции из набора перегрузок. В случае шаблона это нужно чтобы компилятор проверил сгенерированную на основании шаблона специализацию-кандидата. Все, что делается во время компиляции (до непосредственного запуска скомпилированной программы), называется "статическим" процессом. Другой вид процесса -- динамический, который происходит уже после компиляции -- в ходе работы программы, так как нужная информация для проверки заранее компилятору не была доступна.

Таким образом можно подвести промежуточные итоги про особенности полиморфизма. Динамический полиморфизм:
* основан на создании иерархий типов данных (либо через наследование, либо через меченые объединения, либо другим аналогичным способом);
* создает абстракции как интерфейсы, которые являются вершиной иерархии;
* влияет на производительность программы (run-time);
* не позволяет компилятору проверять правильность алгоритмов или свойств типов данных.

Статический полиморфизм:
* основан на создании семейств типов данных через определение шаблонов;
* создает абстракции как интерфейсы, которые являются правильно определенными шаблонами;
* влияет на производительность компилятора (compile-time);
* возможно доказать правильность алгоритмов для некоторых семейств типов данных.

При этом и динамический, и статический полиморфизм может быть универсальным или специальным, но два списка выше описывают универсальный полиморфизм, так как он позволяет создавать программы из компонентов более общего характера -- код каждого компонента является единым для всех вариаций используемых типов -- из-за чего он представляет больший интерес в контексте ООП. Из универсальности -- единой структуры конкретных реализаций, создаваемых для абстракций-шаблонов или абстрактных классов -- вырастает особенный подход к написанию программ.
# Обобщенное программирование
Важным следствием из возможности писать полиморфные функции и параметризовать типы данных является потенциал к декомпозиции программ на компоненты, которые можно определять отдельно друг от друга и затем комбинировать в произвольной последовательности, при условии, что отдельные компоненты согласуются с требованиями четко определенного интерфейса. Такой подход исторически принято называть "обобщенным программированием" (generic), а обобщенные компоненты принято называть "обобщенностями" (generics).

Исторически термин "обобщенность" заимствуется из языка программирования Ada, для которого была создана экспериментальная библиотека Ada Generic Library, содержавшая отдельные модули для работы с произвольными последовательностями из произвольных элементов. То есть, представление данных было отделено от абстрактных типов и операций над абстрактными типами. Это позволяло скрыть конкретную реализацию, не обращаясь к ней напрямую. Вместо этого явно вызывался абстрактный интерфейс, который автоматически подменялся на правильную реализацию.  

В качестве примера можно рассмотреть три абстрактных типа данных: динамический массив, односвязный список и двусвязный список. Эти три типа объединяет то, что элементы, хранящиеся в них, упорядочены. Следовательно, обход элементов с точки зрения пользователя не отличается для этих трех типов: все элементы будут пройдены от начала до конца, и ассимптотичность прохода будет линейная. Достаточно предоставить абстрактный алгоритм прохода по упорядоченной последовательности, чтобы удовлетворить ожидания всех пользователей. Такой абстрактный алгоритм должен состоять из трех элементов: "геттера" для конкретного элемента в конкретной позиции; предиката, который определяет выход за пределы последовательности; оператора, который переходит на следующий элемент из произвольного текущего элемента -- конкретные реализации этих трех компонентов могут быть скрыты самими абстрактными типами данных. Достаточно предоставить возможность программе выбирать нужную реализацию при вызове абстрактного алгоритма. Или, если посмотреть на ситуацию с другой стороны, достаточно позволить программе игнорировать те свойства абстрактных типов данных, которые не имеют отношения к абстрактному алгоритму. 

Этот подход позже был перенесен в язык С++ вместе с добавлением в С++ языка шаблонов. Как говорил Строуструп,
> Для многих людей главная проблема в использовании С++ заключается в отсутствии обширной стандартной библиотеки. Большой трудностью в создании такой библиотеки является то, что С++ не предоставляет достаточно общий способ для определения "классов-контейнеров" типа списка, вектора, ассоциативного массива и т.п.

Шаблоны стали таким "общим способом", потому что они позволили создавать абстрактные классы без наследования, пожертвовав динамическим полиморфизмом в пользу проверяемости кода компилятором.
## Библиотеки в контексте обобщенного программирования
Цели обобщенного программирования изначально заключались в декомпозиции программ и гибкой комбинации получившихся модулей. Это было возможно и до введения шаблонов, но в большинстве языков программирования достигалось засчет написания библиотек. Библиотеки, как правило, являются специализированными модулями с конкретным интерфейсом, расчитанным на конкретный род задач. Следовательно, интерфесы библиотек часто требуют совершенно конкретные типы данных или сами предоставляют новые типы данных для корректной работы алгоритмов из них.

Из-за этого программисту не доступны способы работы с интерфейсами библиотек, используя собственные типы данных или типы данных, созданные вне конкретного интерфейса. Обобщенное программирование призвано это изменить. В первую очередь, оно позволяет использовать интерфейсы в разных контекстах, не изменяя их реализации. Применение обобщенных интерфейсов для широкого спектра задача возможно благодаря отделению типов данных от структур данных и алгоритмов. Когда структуры данных принимают любой тип данных, а алгоритмы принимают любую структуру данных, пользователь получает возможность комбинировать их в любых конфигурациях.

Абстрактных интерфейсов для этого не достаточно, нужен еще один слой абстракции -- интерфейсы, которые являются посредниками между разными компонентами: компоненты взаимодействуют не друг с другом, а с общим интерфейсом, благодаря которому компоненты становятся взаимозаменяемыми. В свою очередь, это становится возможным благодаря минимальному набору требований, которым компоненты должны удовлетворять. Если несколько компонентов удовлетворяет одному и тому же набору требований, они могут быть использованы в одном и том же контексте в качестве интерфейсов, немсотря на то, что сами компоненты не являются подтипами друг друга. 

Стандартная библиотека шаблонов С++ использует механизм шаблонов для достижения целей обобщенного программирования -- она создает набор "концепций", которые описывают требования, предъявляемые интерфейсом к передаваемым конкретным объектам, и проверяют соответствие требованиям на стадии компиляции. Концепции, как правило, повторяют семантику встроенных в язык типов данных и операторов, так как программисты интуитивно ожидают от новых компонентов поведения, которое присуще большинству уже существующих готовых решений. 
## Регулярные типы
Обобщенное программирование использует понятие "регулярного типа".
> Регулярные типы -- это типы, определенные пользователем, которые ведут себя как встроенные типы.

Встроенные в С++ типы поддерживают большое и разнообразное количество операторов, поэтому полного формального определения регулярных типов быть не может, но все встроенные типы содержат одно "ядро", общее для всех -- набор операторов, которые составляют основу семантики типов данных в С++. Ниже представлена таблица "фундаментальных" операций. 
### Копирование, присваивание и сравнение 
#|операция|семантика|инварианты
|-|-|-|-|
|1.|конструирование| T a; |
|2.|копирование| T a = b; | assert(a==b);
|3.|присваивание| T a; a = b; |⇔ T a = b;
|4.|равенство| T a = c; T b = c; | assert(b==c && a==b);
|5.|неравенство| T a = c; T b = c; a = d; | assert(b==c && a!=b);
|6.|порядок| T a = c; T b = c; zap(a); | assert(a < b);
### Равенство регулярных типов
Отношение эквивалентности, записанное так:

    x == y ⇔ ∀ predicate P, P(x) == P(y)
обычно используется в логике для определения отношения "равенства" двух объектов. Если объект *x* равен объекту *у*, для любого предиката (булевой функции) *Р* верно, что значение *Р* от *х* равно значению *Р* от *у*. В программировании такое определение тяжело использовать для определения равенства, так как множество всех возможных предикатов слишком большое, в ущерб практичности.

Традиционно, сравнение двух объектов в памяти делается побитово, если объекты достаточно просты. Такой способ может подойти в качестве базового способа сравнения, так как два объекта одного типа будут иметь одинаковые значение, если их биты полностью совпадают.

    struct S { int x; double y; };
    S a, b; a = {.x=1, .y=2}; b = {.y=2, .x=1};
    assert(a == b);
В примере выше побитовое сравнение даст правильный результат, так как и объект a, и объект b содержат простые типы данных в одинаковой последовательности, и значения в соответствующих байтах тоже будут совпадать. Но для других видов объектов побитовое сравнение будет давать неверный результат. Например, в коде ниже:

    
Objects which are naturally variable sized must be constructed in C++ out of multiple simple structs, connected by pointers. In such
cases, we say that the object has remote parts. Our second caveat then is that an equality
operator should ignore inessential components.

> Two objects are equal if their corresponding parts are equal (applied
recursively), including remote parts (but not comparing their addresses), excluding
inessential components, and excluding components which identify related objects.

Most of us would intuitively assume that a visible accessor function, that is a
public function which returns the value of some component of a composite type,
would be a reasonable function which should satisfy the above condition. However,

    r1 == r2 ⇒ r1.p == r2.p
    (1,2) == (2,4) ⇒ 1 == 2
First, we could avoid defining an equality operator (perhaps
defining an equiv function with the mathematical definition instead). Second, we
could avoid making p and q visible parts of our rational number type. Finally, we
could require that any rational number represented by this type is always in reduced
form, i.e. its numerator and denominator have no common divisors.
## Концепции
We call the set of axioms satisfied by a data type and a set of operations on it a concept. Examples of concepts might be an integer data type with an addition operation satisfying the usual axioms; or a list of data objects with a first element, an iterator for traversing the list, and a test for identifying the end of the list. Highly reusable components must be programmed assuming a minimal collection of such concepts, and that the concepts used must match as wide a variety of concrete program structures as possible.

If we are to
succeed in producing widely reusable components, idiosyncratic interfaces are no
longer usable. A component programmer must be able to make some fundamental
assumptions about the interfaces she uses, without ever seeing their implementations
or even imagining their applications. Similarly, her eventual users must provide the
types implementing those interfaces, and if the same types are to interface with a
variety of generic components, the interfaces must be consistent with one another.

    x == y ⇒ ∀ “reasonable” function foo, foo(x)==foo(y)
What is a reasonable function? For optimization purposes, there are several
classes of functions we would like to capture. First are the standard operators on
built-in types that do not have side effects, for example a+b, c-d, or p%q. Second are
the visible member accesses, e.g. s.first or c->imaginary. A third class is the wellknown pure functions, e.g. abs(x), sqrt(y), and cos(z). The ultimate solution,
then, must be to identify the important attributes, and allow programmers to specify
them explicitly. 

For regular types, we therefore require that constructors, destructors, and
assignment operators be linear (average-case) in the area (i.e. the total size of all
parts) of the object involved. Similarly, we require that the equality operator have
linear worst-case complexity. (The average-case complexity of equality is typically
nearly constant, since unequal objects tend to test unequal in an early part.)

