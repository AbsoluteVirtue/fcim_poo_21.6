# Шаблоны функций и типов
Шаблоны уже встречались в предыдущих частях, но до сих пор не обсуждалась их роль в программах. В первую очередь, шаблоны позволяют определять семейства классов или функций. Дополнительно, с их помощью можно определить альтернативные имена для уже существующих типов (аналогично typedef в языке С), семейства переменных и "концепции" -- особый вид ограничений, позволяющий проверять выполнение определенных условий при вызове функций и т.п.

Суть шаблона сводится к тому, что он позволяет создать "пустой" (обобщенный) класс (или функцию), который можно скомпилировать, не указывая его окончательную структуру. Вместо этого достаточно заменить типы данных или выражения в классе (или функции) на произвольные имена, которые при компиляции будут заменены на конкретные типы или вражения автоматически.

    template<class T, T::type n = 0> class X;
    
    struct S {
        using type = int;
    };
Пример выше показывает объявление шаблонного типа *X* и структуры *S*, которая использует альтернативное имя для типа int. Шаблон *X* в объявлении использует такое же альтернативное имя, то есть, для объявления шаблона можно использовать несуществующие имена, если компилятор может найти определения этих имен в дальнейшем.

    using U = X<S>;
Данная строка является правильной с точки зрения компиляции, так как можно определить конкретные типы всех участвующих в этом определении имен. Имя *U* -- это псевдоним для комбинации символов *X* и *S*, где имя *X* определено через *S*. Причем, *Х* полностью определяется *S*, потому что *Х* зависит от произвольного типа *T*, при этом тип *T* должен содержать имя *type*, которое может быть использовано как тип для константы *n*, при этом *n* должно быть инициализировано значением "0". Тип *S* удовлетворяет этим требованиям, поэтому он может использоваться в определении *X* для подмены символа *T*. Из этого есть интересное следствие. Любой тип или символ, который отвечает этим требованиям, может быть использован для определения *X*, как в примере ниже.

    template<class T, T::type n = 0> class X;

    struct Q {
        using type = long;
    };
    
    using U = X<Q>;
Структура *Q* содержит имя type, которое может быть типом для переменной, инициализированной нулем. 

Из примеров выше можно сделать некоторые выводы. Во-первых, шаблоны образуют формальную грамматику -- набор правил для замены символов или комбинаций символов, определяемых другими правилами, которые, в свою очередь, также определены какими-то правилами. Во-вторых, шаблоны позволяют писать определения, которые не зависят от конкретных типов, а зависят от абстракций. Аналогично типам, которые зависят от абстрактных типов в иерархиях наследования, шаблоны позволяют создавать семейства типов. Эти семейства типов можно использовать для написания полиморфного кода.
## Макросы и шаблоны
Может показаться, что шаблоны работают аналогично "макро"-определениям из языка С.

    #define pair(T, U) struct pair_##T##_##U { 
        T first;
        U second;
    }
Например, такой "макрос" при написании утверждения *pair(int, double)* будет с помощью простой текстовой подстановки заменен на следующий код,

    struct pair_int_double { 
        int first;
        double second;
    }
Аналогичный шаблон, который определяется так.

    template <typename T, typename U> class pair {
        T first;
        U second;
    };
При инстанциировании с помощью утверждения *pair<int, double>{};* создастся экземпляр шаблона,

    template <> class pair<int, double> {
        int first;
        double second;
    };
Разница между двумя этими примерами неочевидна. Главное отличие в том, что макрос не всегда определяет новую функцию или тип, а всего лишь задает порядок замены текста в коде программы перед компиляцией. Это механическая подстановка, которая не проверяется компилятором. Второе отличие в том, что макрос не определяет семейство типов или функций. В качестве более сложного примера можно рассмотреть функцию из прошлой лекции. 

    template <typename T, size_t n> T prod(const T(&a)[n], const T(&b)[n]);
Теперь на него можно взглянуть под другим углом: символ *prod* объявляет семейство функций, носящих это имя, а объединяются все функции данного семейства посредством символа *T* и константы *n*. В программе можно определить одну из функций данного семейства, создав ее экземпляр(ы). Все экземпляры шаблона являются конкретными функциями, которые отличаются друг от друга конкретными типами или выражениями, которые подставляются в экземпляр при его объявлении, как показано на примере ниже.

    auto result = prod({1, 2, 3}, {4, 5, 6});
Этот экземпляр использует массивы целочисленных значений в качестве аргументов. Следовательно, параметры экземпляра с помощью подстановки будут определены как массивы типа *int[3]* (символ *T* заменяется на тип отдельного элемента аргумента, символ *n* заменяется на размер аргумента).

Отсюда следует несколько важных свойств данного шаблона. Из него можно порождать бесконечно много экземпляров подстановкой разных типов. Но интересней другое: на аргументы естественным образом накладывается несколько ограничений. Первое ограничение -- размер массивов, который должен совпадать, т.е. нельзя создать экземпляр функции, передав ей два массива разных размеров. Второе ограничение -- тип данных элементов массива, который также должен совпадать для обоих аргументов. Это, в свою очередь, значит, что определение шаблона может не содержать эти проверки, так как любой экземпляр, не отвечающий данным требованиям, не может быть инстанциирован компилятором. 

Последнее важное следствие из этого, которое нужно упомянуть, состоит в том, что в ходе работы программы все экземпляры уже заведомо созданы, а значит их создание не влияет на производительность программы, но влияет на производительность во время компиляции. Каждый экземпляр функции или класса из конкретного семества должен быть проверен компилятором на правильность, поэтому их все необходимо сгенерировать, что значительно увеличивает количество компилируемого кода.  
## Динамический и статический полиморфизм
Можно отметить, что на стадии компиляции шаблоны технически не отличаются от перегрузки. Независимо от того, используется перегрузка или шаблон, тип данных всех аргументов функции известен компилятору заранее. В случае перегрузки это нужно, чтобы компилятор проверил правильную версию функции из набора перегрузок. В случае шаблона это нужно чтобы компилятор проверил сгенерированную на основании шаблона специализацию-кандидата. Все, что делается во время компиляции (до непосредственного запуска скомпилированной программы), называется "статическим" процессом. Другой вид процесса -- динамический, который происходит уже после компиляции -- в ходе работы программы, так как нужная информация для проверки заранее компилятору не была доступна.

Таким образом можно подвести промежуточные итоги про особенности полиморфизма. Динамический полиморфизм:
* основан на создании иерархий типов данных (либо через наследование, либо через меченые объединения, либо другим аналогичным способом);
* создает абстракции как интерфейсы, которые являются вершиной иерархии;
* влияет на производительность программы (run-time);
* не позволяет компилятору проверять правильность алгоритмов или свойств типов данных.

Статический полиморфизм:
* основан на создании семейств типов данных через определение шаблонов;
* создает абстракции как интерфейсы, которые являются правильно определенными шаблонами;
* влияет на производительность компилятора (compile-time);
* возможно доказать правильность алгоритмов для некоторых семейств типов данных.

При этом и динамический, и статический полиморфизм может быть универсальным или специальным, но два списка выше описывают универсальный полиморфизм, так как он позволяет создавать программы из компонентов более общего характера -- код каждого компонента является единым для всех вариаций используемых типов -- из-за чего он представляет больший интерес в контексте ООП. Из универсальности -- единой структуры конкретных реализаций, создаваемых для абстракций-шаблонов или абстрактных классов -- вырастает особенный подход к написанию программ.
# Обобщенное программирование
Важным следствием из возможности писать полиморфные функции и параметризовать типы данных является потенциал к декомпозиции программ на компоненты, которые можно определять отдельно друг от друга и затем комбинировать в произвольной последовательности, при условии, что отдельные компоненты согласуются с требованиями четко определенного интерфейса. Такой подход исторически принято называть "обобщенным программированием" (generic), а обобщенные компоненты принято называть "обобщенностями" (generics).

Исторически термин "обобщенность" заимствуется из языка программирования Ada, для которого была создана экспериментальная библиотека Ada Generic Library, содержавшая отдельные модули для работы с произвольными последовательностями из произвольных элементов. То есть, представление данных было отделено от абстрактных типов и операций над абстрактными типами. Это позволяло скрыть конкретную реализацию, не обращаясь к ней напрямую. Вместо этого явно вызывался абстрактный интерфейс, который автоматически подменялся на правильную реализацию.  

В качестве примера можно рассмотреть три абстрактных типа данных: динамический массив, односвязный список и двусвязный список. Эти три типа объединяет то, что элементы, хранящиеся в них, упорядочены. Следовательно, обход элементов с точки зрения пользователя не отличается для этих трех типов: все элементы будут пройдены от начала до конца, и ассимптотичность прохода будет линейная. Достаточно предоставить абстрактный алгоритм прохода по упорядоченной последовательности, чтобы удовлетворить ожидания всех пользователей. Такой абстрактный алгоритм должен состоять из трех элементов: "геттера" для конкретного элемента в конкретной позиции; предиката, который определяет выход за пределы последовательности; оператора, который переходит на следующий элемент из произвольного текущего элемента -- конкретные реализации этих трех компонентов могут быть скрыты самими абстрактными типами данных. Достаточно предоставить возможность программе выбирать нужную реализацию при вызове абстрактного алгоритма. Или, если посмотреть на ситуацию с другой стороны, достаточно позволить программе игнорировать те свойства абстрактных типов данных, которые не имеют отношения к абстрактному алгоритму. 

Этот подход позже был перенесен в язык С++ вместе с добавлением в С++ языка шаблонов. Как говорил Строуструп,
> Для многих людей главная проблема в использовании С++ заключается в отсутствии обширной стандартной библиотеки. Большой трудностью в создании такой библиотеки является то, что С++ не предоставляет достаточно общий способ для определения "классов-контейнеров" типа списка, вектора, ассоциативного массива и т.п.

Шаблоны стали таким "общим способом", потому что они позволили создавать абстрактные классы без наследования, пожертвовав динамическим полиморфизмом в пользу проверяемости кода компилятором.
## Библиотеки в контексте обобщенного программирования
Цели обобщенного программирования изначально заключались в декомпозиции программ и гибкой комбинации получившихся модулей. Это было возможно и до введения шаблонов, но в большинстве языков программирования достигалось засчет написания библиотек. Библиотеки, как правило, являются специализированными модулями с конкретным интерфейсом, расчитанным на конкретный род задач. Следовательно, интерфесы библиотек часто требуют совершенно конкретные типы данных или сами предоставляют новые типы данных для корректной работы алгоритмов из них.

Из-за этого программисту не доступны способы работы с интерфейсами библиотек, используя собственные типы данных или типы данных, созданные вне конкретного интерфейса. Обобщенное программирование призвано это изменить. В первую очередь, оно позволяет использовать интерфейсы в разных контекстах, не изменяя их реализации. Применение обобщенных интерфейсов для широкого спектра задача возможно благодаря отделению типов данных от структур данных и алгоритмов. Когда структуры данных принимают любой тип данных, а алгоритмы принимают любую структуру данных, пользователь получает возможность комбинировать их в любых конфигурациях.

Абстрактных интерфейсов для этого не достаточно, нужен еще один слой абстракции -- интерфейсы, которые являются посредниками между разными компонентами: компоненты взаимодействуют не друг с другом, а с общим интерфейсом, благодаря которому компоненты становятся взаимозаменяемыми. В свою очередь, это становится возможным благодаря минимальному набору требований, которым компоненты должны удовлетворять. Если несколько компонентов удовлетворяет одному и тому же набору требований, они могут быть использованы в одном и том же контексте в качестве интерфейсов, немсотря на то, что сами компоненты не являются подтипами друг друга. 

Стандартная библиотека шаблонов С++ использует механизм шаблонов для достижения целей обобщенного программирования -- она создает набор "концепций", которые описывают требования, предъявляемые интерфейсом к передаваемым конкретным объектам, и проверяют соответствие требованиям на стадии компиляции. Концепции, как правило, повторяют семантику встроенных в язык типов данных и операторов, так как программисты интуитивно ожидают от новых компонентов поведения, которое присуще большинству уже существующих готовых решений. 
## Регулярные типы
Обобщенное программирование использует понятие "регулярного типа".
> Регулярные типы -- это типы, определенные пользователем, которые ведут себя как встроенные типы.

Встроенные в С++ типы поддерживают большое и разнообразное количество операторов, поэтому полного формального определения регулярных типов быть не может, но все встроенные типы содержат одно "ядро", общее для всех -- набор операторов, которые составляют основу семантики типов данных в С++. Ниже представлена таблица "фундаментальных" операций. 
### Копирование, присваивание и сравнение 
#|операция|семантика|инварианты
|-|-|-|-|
|1.|конструирование| T a; |
|2.|копирование| T a = b; | assert(a==b);
|3.|присваивание| T a; a = b; |⇔ T a = b;
|4.|равенство| T a = c; T b = c; | assert(b==c && a==b);
|5.|неравенство| T a = c; T b = c; a = d; | assert(b==c && a!=b);
|6.|порядок| T a = c; T b = c; zap(a); | assert(a < b);
### Равенство регулярных типов
Отношение эквивалентности, записанное так:

    x == y ⇔ ∀ predicate P, P(x) == P(y)
обычно используется в логике для определения отношения "равенства" двух объектов. Если объект *x* равен объекту *у*, для любого предиката (булевой функции) *Р* верно, что значение *Р* от *х* равно значению *Р* от *у*. В программировании такое определение тяжело использовать для определения равенства, так как множество всех возможных предикатов слишком большое, в ущерб практичности.

Традиционно, сравнение двух объектов в памяти делается побитово, если объекты достаточно просты. Такой способ может подойти в качестве базового способа сравнения, так как два объекта одного типа будут иметь одинаковые значение, если их биты полностью совпадают.

    struct S { int x; double y; };
    S a, b; a = {.x=1, .y=2}; b = {.y=2, .x=1};
    assert(a == b);
В примере выше побитовое сравнение даст правильный результат, так как и объект a, и объект b содержат простые типы данных в одинаковой последовательности, и значения в соответствующих байтах тоже будут совпадать. Но для других видов объектов побитовое сравнение будет давать неверный результат. Например, в коде ниже:

    struct Node { int x; Node *tail; };
    Node a, b; assert(a == b);

два объекта одной структуры при побитовом сравнении могут быть равны, но такое сравнение будет некорректным, так как равенство указателей не должно быть условием равенства списков. Для двух списков, сделанных из таких узлов не имеет значения, по каким адресам расположены сами узлы, важно только то, какие значения содержатся в обоих списках.

Таким образом, если структура содержит несущественные для сравнения части, их нужно игнорировать, а значит побитовое сравнение нужно переопределять.
> Two objects are equal if their corresponding parts are equal (applied
recursively), including remote parts (but not comparing their addresses), excluding
inessential components, and excluding components which identify related objects.

Наконец, есть еще одно условие равенства, которое нужно соблюдать. Например, для двух рациональных чисел, 

    r1 == r2 ⇒ r1.p == r2.p
    (1,2) == (2,4) ⇒ 1 == 2
в примере выше есть очевидное противоречие. Числа 1/2 и 2/4 равны, но если сравнить отдельно их числители и знаменатели, результат будет отрицательным. Соответственно, при переопределении сравнения недостаточно просто сравнивать существенные части, сравнивать нужно их простейшие (reduced) формы (в данном примере, оба числа сначала надо свести к форме, в которой у них нет общего делителя).
## Концепции
Концепция в своей первоначальной трактовке -- это набор аксиом, которые должны удовлетворяться типом данных, и набор операций над значениями этого типа данных. Например, целочисленные типы удовлетворяют этим свойствам, так как сопровождаются всеми встроенными арифметическими операциями и всеми свойствами вроде ассоциативности, транзитивности и т.д. Другим примером такого типа может служить упорядоченный список произвольных значений: у списка есть первый элемент, итератор для нахождения следующего элемента и предикат для определения последнего элемента списка.

Если обобщить эти примеры, можно сделать вывод, что любые компоненты должны предполагать минимальный набор концепций, а эти концепции должны подходить максимально вожможному набору структур в программе -- это делает такие компоненты легко взаимозаменяемыми.

Такие компоненты не могут использоваться специализированными интерфейсами, потому что без обобщения типов данных программист теряет возможность делать предположения о фундаментальных свойствах компонентов интерфейса, не зная детали реализации. То есть, если предполагать, что обобщенным интерфейсом будут пользоваться другие, реализации для интерйеса должны предоставлять сами пользователи посредством конкретных типов данных, а не автор интерфейса. 
> Тогда, самым правильным решением будет определение в интерфейсе самых важных атрибутов произвольного типа, который следует передавать интерфейсу, и предоставление пользователям интерфейса задавать типы, обладающие такими атрибутами, явно.

Для "регулярных" типов данных, такими атрибутами являются конструкторы, деструктор, присваивание, сравнение.
### Концепции в С++
Можно заметить, что шаблоны в С++ уже удовлетворяют определению концепции, данное выше. Переданный в качестве шаблонного аргумента тип данных будет отвергнут на стадии компиляции, если он не соответствует обозначенным в шаблоне свойствам и не реализует нужные операции. То есть, шаблоны описывают обобщенный интерфейс, который подбирает подходящую реализацию при инстанциировании шаблона конкретным типом данных или реализуется самим пользователем предварительно.

Тем не менее, описание требований к типам данных в таких интерфейсах оставляет желать лучшего, поэтому с недавнего времени в С++ появилась отдельная библиотека с концепциями -- *concept*. Текущая реализация концепций определяет их как
> предикаты (функции, возвращающие true или false), которые вычисляются во время компиляции, принимающие типы данных в качестве аргументов.

    template <typename T>
    concept number = std::integral<T> || std::floating_point<T>;

    template <number Number>
    auto concept_function(Number a, Number b) { return a + b; }
Пример выше показывает простой пример определения и использования концепции. Два стандартных предиката integral и floating_point проверяют переданный тип (в данном случае -- шаблонный символ T) на соответствие. Если один из них вернет true, тип, скрывающийся за символом T, можно считать численным. Это правило именнуется number с помощью ключевого слова concept. Функция concept_function использует арифметическую оперцию, которая определена для всех численных типов, соответственно ее можно обобщить с помощью шаблона, объявив шаблонный аргумент Number как ранее созданную концепцию. 

Такая функция теперь не сможет быть инстанциирована, если в нее передать тип данных, который компилятор не считает численным. При попытке вызвать ее для не численного типа компилятор выдаст ошибку. То есть, в отличие от простых шаблонов, концепции позволяют авторам интерфейсов ограничить типы входящих данных, причем явно определять эти ограничения для пользователей.

    concept_function("Number a", "Number b");
    // candidate template ignored: 
    // deduced conflicting types for parameter 'Number' 
    // ('double' vs. 'const char*')
Несмотря на то, что оператор "+" определен и для строковых данных, в данном случае вызвать функцию будет нельзя, потому что компилятор проверит тип данных на соответствие концепции во время инстанциирования шаблона и прервет компиляцию с соответствующей ошибкой.
## Виртуальные функции или концепции для создания интерфейсов
Если вернуться к сравнению динамического и статического полиморфизма в С++, концепции добавляют нюансов, которые нужно иметь ввиду при выборе одного или другого подхода. Ниже показан пример интерфейса, определенного с помощью абстрактного базового класса.
    
    class IPin {
    public:
        virtual void set() = 0;
        virtual void reset() = 0;
    };
Интерфейс IPin моделирует электрический компонент на схеме, состояние которого может быть одним из двух возможных. Методы класса изменяют это состояние. Для реализации интерфейса абстрактный класс необходимо наследовать.

    class CPin : public IPin {
    private:
        std::uint8_t m_pin{0};
    public:
        CPin() = delete;
        CPin(std::uint8_t pin) : m_pin{pin} {}
        void set() override {
            CBitSetResetRegister::set_pin(
                m_pin);
        }
        void reset() override {
            CBitSetResetRegister::reset_pin(
                m_pin);
        }
    };
Класс CPin реализует данный интерфейс (содержит оба чисто виртуальных метода с определениями), поэтому значения типа CPin можно использовать в качестве аргументов в функциях, которые используют интерфейс IPin.

    class CLed {
    private:
        bool  m_state{false};
        IPin* m_pin{nullptr};
    public:
        CLed() = delete;
        CLed(IPin* pin) : m_pin{pin} 
        { m_pin->reset(); }
        // здесь могут быть дополнительные детали реализации
    };
Например, класс CLed использует метод reset интерфейса IPin, следовательно объекты типа CLed могут быть сконструированы, используя значения типа CPin.

Добиться такого же эффекта можно с помощью концепции.

    template <class T> 
    concept IPin = requires (T pin) {
        { pin.set() } ->
            std::same_as<void>;
        { pin.reset() } -> 
            std::same_as<void>;
    };
Шаблон IPin может выполнять роль обобщенного интерфейса, так как аналогично абстрактному классу требует от всех проверяемых типов Т реализации методов с именами set и reset, которые возвращают пустое множество (void).

    template <IPin T> class CLed {
    private:
        bool m_state{false};
        T*   m_pin{nullptr};
    public:
        CLed() = delete;
        CLed(T* pin) : m_pin{pin}
        { m_pin->reset(); }
    };
Клиентский класс CLed теперь можно сделать шаблонным, ограничив шаблонные аргументы концепцией IPin, что заставит любую реализацию интерфейса IPin содержать соответствующие ограничениям концепции IPin методы, иначе код не сможет быть скомпилирован. Класс CPin уже удовлетворяет этим требованиям, поэтому его можно использовать для создания объектов CLed.

    static_assert(IPin<CPin>);
    CLed<CPin> pinned{new CPin{1}};
В итоге, концепции позволяют переложить ответственность за реализацию конкретных компонентов на пользователей той или иной библиотеки. Благодаря этому код библиотеки может быть полностью отделен от реализации, так как между реализацией и конечным пользователем появляется слой абстракции, выраженный в обобщенном интерфейсе. 

Концепции одновременно усиливают контроль за реализацией интерфейсов, определяя конкретные проверяемые ограничения, но ослабевают требования к реализациям по сравнению с абстрактными классами. В случае с абстрактным классом реализация обязана соответствовать ему полностью (не должно быть расхождений в типах данных параметров, минимальном количестве методов и т.д.) независимо от кода пользователя (он может не использовать весь интерфейс, но все равно будет тянуть реализацию даже тех методов, которые в коде не применяются).

    struct Imp { void calculate(int x = 0); };

    template <typename T>
    concept constrained = requires (T a) {
        { a.calculate() } -> std::same_as<void>;
    };

    template <constrained C>
    void client(C arg);

    client(Imp);
Пример выше это иллюстрирует. Функция client использует концепцию для ограничения типа аргумента, который она принимает: тип должен предоставлять метод calculate, который ничего не принимает и возвращает void. Структура Imp содержит вызываемый метод с таким именем, он возвращает void, но принимает один аргумент. Несмотря на это, он подходит концепции constrained, так как аргумент имеет значение по умолчанию, соответственно, метод можно вызвать без аргументов. Добиться такого же эффекта при реализации абстрактного метода класса нельзя.