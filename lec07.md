# Шаблоны функций и типов
Шаблоны уже встречались в предыдущих частях, но до сих пор не обсуждалась их роль в программах. В первую очередь, шаблоны позволяют определять семейства классов или функций. Дополнительно, с их помощью можно определить альтернативные имена для уже существующих типов (аналогично typedef в языке С), семейства переменных и "концепции" -- особый вид ограничений, позволяющий проверять выполнение определенных условий при вызове функций и т.п.

Суть шаблона сводится к тому, что он позволяет создать "пустой" (обобщенный) класс (или функцию), который можно скомпилировать, не указывая его окончательную структуру. Вместо этого достаточно заменить типы данных или выражения в классе (или функции) на произвольные имена, которые при компиляции будут заменены на конкретные типы или вражения автоматически.

    template<class T, T::type n = 0> class X;
    
    struct S {
        using type = int;
    };
Пример выше показывает объявление шаблонного типа *X* и структуры *S*, которая использует альтернативное имя для типа int. Шаблон *X* в объявлении использует такое же альтернативное имя, то есть, для объявления шаблона можно использовать несуществующие имена, если компилятор может найти определения этих имен в дальнейшем.

    using U = X<S>;
Данная строка является правильной с точки зрения компиляции, так как можно определить конкретные типы всех участвующих в этом определении имен. Имя *U* -- это псевдоним для комбинации символов *X* и *S*, где имя *X* определено через *S*. Причем, *Х* полностью определяется *S*, потому что *Х* зависит от произвольного типа *T*, при этом тип *T* должен содержать имя *type*, которое может быть использовано как тип для константы *n*, при этом *n* должно быть инициализировано значением "0". Тип *S* удовлетворяет этим требованиям, поэтому он может использоваться в определении *X* для подмены символа *T*. Из этого есть интересное следствие. Любой тип или символ, который отвечает этим требованиям, может быть использован для определения *X*, как в примере ниже.

    template<class T, T::type n = 0> class X;

    struct SL {
        using type = long;
    };
    
    using U = X<SL>;
Структура *SL* содержит имя type, которое может быть типом для переменной, инициализированной нулем. 
## Динамический и статический полиморфизм
Из примеров выше можно сделать некоторые выводы. Во-первых, шаблоны образуют формальную грамматику -- набор правил для замены символов или комбинаций символов, определяемых другими правилами, которые, в свою очередь, также определены какими-то правилами. Во-вторых, шаблоны позволяют писать определения, которые не зависят от конкретных типов, а зависят от абстракций. Аналогично типам, которые зависят от абстрактных типов в иерархиях наследования, шаблоны позволяют создавать семейства типов. Эти семейства типов можно использовать для написания полиморфного кода. 

# Концепции
