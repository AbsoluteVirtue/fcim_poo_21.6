# Наследование
Концепция наследования появилась на заре программирования, еще в 1960-е годы, но широкое распространиение получила благодаря языку Simula. Как говорилось в одной из предыдущих частей, для обозначения связи между подпроцессами в язык были введены понятия "класс" и "подкласс". Причем, "подклассы процессов представляли собой описания со своими собственными операциями и локальными данными (аналогично объектам-функциям в Lisp)," при этом уже включая свойства родительского процесса, расширяя его возможности.

    class Page;
    begin
        class Print_Block(Width,Length);integer Width, Length;
        begin
        ref(Print_Block)Next;
        text array Contents(1:Length);
        integer Count;
        for Count:=1 step 1 until Length do Contents(Count):-Blanks(Width)
        end--of--Print_Block;

        Print_Block class Title_Block(Title);text Title;
        begin
        Contents(Length//2):=Title
        end--of--Title_Block;

        Print_Block class Text_Block;
        begin
        for Count:=1 step 1 until Length do
        begin
            InImage;
            Contents(Count):=Intext(Width)
        end
        end--of--Text_Block;
    end..of..Page;
    new Page;
Строки *Print_Block class Title_Block* и *Print_Block class Text_Block* указывают на то, что процессы типа Title_Block и Text_Block расширяют процесс Print_Block, который выступает их "префиксом".

Алан Кей говорит о наследовании так:

> "Программирование с помощью наследования показывает силу дифференцированного описания. Например, есть общее понятие 'облако', представленное объектом. Программист может создать облако прямоугольной формы, таким образом дифференцировав его, получая объект 'прямоугольник', который один в один как облако, за исключением..."

Наследование в Simula-67 было обобщением идеи блоков в Algol 60. Но то, как оно было реализовано, не устраивало Алана Кея (слишком тесная связь между префиксом и подклассом, линейная иерархия, трудности в использовании в интерактивных приложениях с поступенчатой компиляцией, где необходима возможность изменять "горячий" код), поэтому в Smalltalk семантику наследования пришлось немного изменить.

Дэн Ингаллс, который писал реализацию Smalltalk, повторил принцип наследования из Simula, но внес в него необходимые изменения. Ниже представлен пример кода с наследованием в Smalltalk-76.

    Class new title: 'Window'; 
        fields='frame'; 
        asFollows!
        ...
    Default Event Responses
    enter [self show] 
    leave 
    outside [^false] 
    pendown 
    keyboard [keyboard next. frame flash] 
    Image 
    show

    Class new title= 'DocWindow'; 
        subclassof: Window; 
        flelds='document scrollbar edit Menu'; 
        asFollows!
    Event Responses
    enter [self show.editMenu show.scrollbar show] 
    leave [document hideselection.editMenu hide.scrollbar hide] 
    outside
        [editMenu startup => [] 
        scrollbar startup => [self showDoc] 
        ^false] 
    pendown [document pendown] 
    keyboard [document keyboard]
    Image
    show [super show.self showDoc]
    showDoc [doucument showin: frame at: scrollbar position] 
Класс DocWindow является подклассом класса Window, а значит предоставляет те же самые методы, расширяя функционал "окна" своими дополнительными методами, которые присущи только окну "документа".

Технически реализация наследования Алана Кея устраивала, но сама логика наследования оставляла желать лучшего. Например, нет четкого семантического разделения между наследованием класса и инстанциированием класса. В обоих случаях появляется объект со свойствами родительского класса. Отсюда и неясность относительно пользы одного из подходов относительно другого. К тому же, наследование позволяет выразить достаточно много идей одним и тем же синтаксисом, что может потом навредить программе, так как совсем не очевидно, какую именно из идей выражает программист в каждом конкретном случае, если применяет наследование.

Больше всего Алан Кей сомневался насчет полезности статического наследования. Основой Smalltalk было динамическое связывание значений, а значит конкретный тип объекта во время компиляции не должен быть известен. Тип аргумента должен определяться из контекста только во время вызова метода объекта, как и тип самого объекта. Также, Алан Кей считал, что множественное наследование важно поддерживать в языке (если "обычное" наследование позволяет много раз наследовать один и тот же родительский класс, множественное наследование позволяет одному дочернему классу иметь несколько родительских классов одновременно). 

В итоге, наследование не стали включать как механизм в следующую версию языка -- Smalltalk-72, так как "его можно симулировать другими способами, используя уже готовые возможности языка, который повторял гибкость Lisp." Пример такой симуляции можно видеть в том, как методы относятся к объектам. Определение произвольного метода в Smalltalk можно написать как угодно. Так, метод print может ничего не выводить. Чтобы дать какие-то гарантии относительно ожидаемого поведения метода, можно инстанциировать класс "Method", назвать класс-экземпляр "Print", благодаря чему все экземпляры Print тоже будут методами. Изменять тело таких методов уже будет нельзя, но его можно будет расширять, добавляя действия помимо вывода информации. Это позволит защитить "значение" метода, разрешив добавлять реализации. Такой вид наследования был предложен Ларри Теслером для "экспертных систем" -- искуственного интеллекта еще в ранних 1970-х. 
## C++ в 1979-1991 гг.
> "Smalltalk подталкивает программистов на использование наследования как основным, если не единственным, способом организовывать код программы и организовывать классы в иерархии с общим корнем. В С++ классы являются типами данных, и наследование -- это не единственный способ организовать код программы."

Эта цитата принадлежит Бъярне Строуструпу, оригинальному автору языка С++. Он неоднократно говорил, что многие идеи для С++ подчерпнул из Simula, включая классы как пользовательские типы данных, наследование как способ выделять отношения между типами данных. И самое главное -- ООП тоже, по мнению Строуструпа, пришел в С++ из Simula -- первого объектно-ориентированного языка.

"У Бэкуса была хорошая идея: программы должны быть написаны для людей, а не для машин, в первую очередь. Так появился Fortran. Но с легкой руки его последователей эта идея зашла слишком далеко. Появились отдельные языки для бухгалтерии, для логистики, для науки. Сотни языков выстраивали концепции какой-то отдельно взятой области. В результате получился хаос: у них не было возможности обмениваться данными, не было возможности использовать несколько языков одновременно. Так продолжалось, пока не появился Кристен Найгард с языком Simula. Он позволил создавать свои собственные типы данных, свои собственные абстракции -- так появилось ООП."
### Влияние Simula на С++
Строуструп очень высоко оценивал вохможности языка Simula. Он впервые познакомился с языком во время работы над своей диссертацией, для которой он писал симуляции сетевых приложений. Так как Simula был языком для симуляций, она почти идеально подходила для целей Струструпа. Языковые концепции очень хорошо подходили к задачам, которые необходимо было решать. Классы позволяли создавать объекты, которые имитировали реальные сущности: "компьютер", "сетевое подключение", "пакет с данными" и т.п. Это делало код легко читаемым, в отличие от того, к чему Строуструп привык в других языках (он особенно выделял Паскаль как пример плохо спроектированного языка). Его также поразила экспрессивность ошибок в обращении к типам данных. Ошибка компиляции практически всегда указывала на недоработку в дизайне класса

К сожалению Simula был не без своих недостатков, главным из которых была производительность. Причем, как в ходе работы программы, так и во время компиляции. Например, перекомпиляция одного класса занимала больше времени, чем перекомпиляция всей программы целиком. Другой проблемой была проверка типов данных в ходе работы программы, а также сбор "мусора". По наблюдениям Строуструпа, 80% всего времени уходило на сбор мусора, даже если никакого мусора программа не производила.  

Этот опыт подтолкнул Строуструпа на создание своего собственного инструмента для программирования, который бы сохранил все положительные стороны Simula и исправил отрицательные моменты.

1. Такой инструмент должен помогать организовать код программы с помощью классов и иерархий классов, с помощью сопроцессовости и статической проверки типов данных. То есть, классы становились главным инструментом дизайна приложений.
2. Хороший инструмент производить программы с высокой степенью быстродействия. Скорость выполнения должна быть сопоставима с ассемблерными языками. Это касается и компиляции. Компиляция также должна поддерживать комбинирование подпрограмм, написанных на разных языках, в одну программу. 
3. Хороший инструмент производит портативные программы.
> "Мой личный опыт показал, что 'хорошая реализация' чего-то, что мне было нужно, всегда была недоступна 'до следующего года', а тогда -- только для компьютеров, которые я не мог себе позволить."

Из этого следовало, что хороший инструмент должен поддерживать множество различных компьютерных систем для общей доступности. 
### Основные возможности первой реализации С++ (1980-81)
1. Классы.
2. Подклассы (наследование). 
3. Доступ к полям классов (public/private).  
4. Конструкторы и деструкторы
5. Функции-декораторы (call/return, позже были убраны из языка).  
6. Дружественные классы (friend). 
7. Статическая проверка типов, статическое приведение типов аргументов.
8. Встраиваимые функции (inline). 
9. Аргументы по-умолчанию. 
10. Перегрузка оператора присваивания. 

Первая реализация С++ была всего лишь расширением языка С и называлась "С с классами". Строуструп написал парсер, который генерировал код на языке С. Этот код затем компилировался любым С-компилятором. Как заметил Строуструп,
> "Язык программирования служит двум целям: позволяет программисту описать действия, которые компьютер должен выполнить, при этом предоставляя программисту набор концепций для обдумывания способов решения поставленной задачи. Первая цель требует близкий к 'железу' язык, чтобы все важные аспекты реализации решались просто и быстро. За это отвечал язык С. Вторая цель требует язык, близкий к поставленной задаче по своей выразительности. Это было добавлено в язык С для создания С++.
## Наследование реализации и наследование интерфейса
В то время как Smalltalk рассматривает классы в качестве собрания операций, доступных их объектам, Simula и С++ видят классы как конкретный интерфейс, предоставляемый множеству объектов (экземпляров соответствующего подкласса). В результате класс в Smalltalk способен обрабатывать сообщения с операциями, которые он не поддерживает, в то время как С++ гарантирует пользователю, что компилятор позволит вызывать только те методы, определение которых присутствует в классе.

В С++ наследование -- механизм создания "производного" класса (подкласса) -- повторяло идею классов с префиксами из Simula. Изначально подклассы использовали для создания новых структур данных из существующих (таким образом новая структура содержала всю информацию своей базовой структуры, и расширяла ее). 

    class Base {
        int x;
    public:
        void f();
    };

    void check(Base b) { b.f(); }

    class Derived : public Base {
        int y;
    public: 
        void g();
    };

    Derived d;
    check(d); // можно вызвать, т.к. тип Derived приводим к типу Base в этом контексте
Это также помогало ассоциировать существующие операции с новыми (производными) типами данных: можно было использовать производные классы в ситуациях, где требовались их базовые классы (так как наследуется реализация базового класса).

Характер наследования -- степень открытости отношений между двумя классами -- можно дополнительно ограничить. Если нужно наследовать только реализацию (код другого класса), наследование объявляется *private*.
   
    class Base {
        int x;
    public:

        void f() {}
    };

    class Derived : private Base {
        int y;
    public:
        void g() { f(); } // легально использовать функцию внутри подкласса
    };

    Derived d;
    d.f();  // нелегально использовать функцию как интерфейс подкласса
            // error: 'void Base::f()' is inaccessible within this context
### Дружественные классы и функции
Параллельно производным классам в язык добавили механизм "дружественных" классов. Идея заключается в том, что реализацию класса можно раскрыть другому классу, обозначив сторонний класс как *friend*.  

    class Derived; // класс должен быть объявлен

    class Base {
        int x;
    public:
        friend Derived; // объявленный ранее класс можно сделать дружественным
    };

    class Derived {
        int y;
    public: 
        void g(Base b) {
            b.x = 0; // private-атрибут класса Base можно изменить в дружественном классе 
        }
    };
В последствии от дружественных классов перешли к дружественным функциям, чтобы сделать механизм раскрытия состояния более гибким. В первую очередь, дружественные функции используются при специализации глобальных функций для своего типа данных.

    int global(int a, int b) {
        return a + b;
    }

    class Base {
        int x;
    public:
        friend int global(int a, Base b) {
            return a + b.x;
        }
    };

    Base b;
    global(4, b); // вызовется перегруженная версия класса Base
Уже тогда были планы изменить семантику наследования, добавив в язык виртуальные функции, статические методы класса, шаблонные классы и функции, а также множественное наследование.  

> All of these generalizations have their uses, but every "feature" of a language takes time and effort to design, 
implement, document, and learn. The base class concept is an engineering compromise, like the C class 
concept.
## Основные возможности первой версии С++
В итоге, помимо всего вышеперечисленного, что было разработано для "С с классами", первая официальная версия языка C++ включала в себя: 
1. Виртуальные функции.
2. Перегрузку имен функций и операторов.
3. Ссылочные типы (для поддержания перегрузки функций и операторов).
4. Ключевое слово const. 
5. "Аллокаторы" для выделения на "куче".
6. Проверку типов выражений во время компиляции (для строгой статической типизации).
### Ключевое слово const
По аналогии с операционными системами, в которых отдельные области памяти можно помечать только на чтение или на запись, в С++ это тоже сделали возможным. Любой тип можно объявить как "только для чтения", добавив ключевое слово *const*. 

Одним из важных преимуществ в использовании констант было то, что процесс мог оптимизировать использование памяти и не выделять память под них, так как их можно заменять конкретными значениями в любом контексте. Соответственно, константы стали лучшей альтернативой макросам для объявления имен как константных значений в определенных случаях.

    #define MV 5
    // или:
    extern const int MC = 5;
    // вторая строка скомпилируется в символ
    MC:
        .long   5
    main:
        push    rbp
        mov     rbp, rsp
        mov     eax, 5      # символьная подстановка вместо переменной
        pop     rbp
        ret
### Аллокаторы
Возможность определять свои аллокаторы для классов оказалась достаточно востребованной. Практика показывала, что привычное использование *malloc*/*free* приводило к тому, что память на "куче" постепенно фрагментировалась (небольшие участки занятой памяти чередуются с небольшими участками выделенной памяти, что может привести к ситуации, когда на "куче" заканчиваются блоки большого объема, хотя сама "куча" имеет много свободного места), так как динамическое выделение маленьких объектов происходило по многу раз в рамках небольшого количества классов. Аллокатор позволял зарезервировать определенную область памяти на "куче" под все нужды класса. Это приводит к тому, что "куча" перестает фрагментироваться. 
### Взаимная совместимость между С и С++
В дизайне языка С++ остро стоял вопрос совместимости с языком С. Насколько сильно должен отличаться С++ от С, и насколько близко должны быть программы, написанные на С, к аналогичным программам на С++? В итоге, за правило было принято "быть как можно ближе к С, но не слишком близко". Это на практике означает, что код, написанный на стандартной версии языка С (ANSI C), должен компилироваться на С++ (Строуструп говорил, что первым настоящим тестом С++ была успешная компиляция ядра операционной системы, которое написано на С).
### Виртуальные функции
Виртуальные функции были добавлены в язык для того, чтобы определять абстрактные базовые классы ("ABC"). Строуструп говорил, что: 
> Абстрактный тип данных определяет своего рода "черный ящик". После определения он с программой не взаимодействует. Единственный способ его адаптировать под нужды программы -- изменить определение. Это делает абстрактные типы данных очень стабильными.

Пользователи жаловались, что реализация того или иного класса имела тенденцию "просачиваться" наружу, из-за чего при изменении реализации приходилось перекомпилировать весь код, который использовал данный класс. Возникла необходимость отделить интерфейс от реализации. Нужно было создать такую систему, в которой есть классы-интерфейсы (очень редко изменяются, так как не содержат реализации) и классы-реализации (изменяются часто, но не используются нигде напрямую).

Строуструп принял решение ввести правило, по которому можно было не включать реализацию в абстрактный класс, но предоставлять ее по запросу пользователям абстрактного класса из другого класса, который наследуется от абстрактного. Это делается с помощью виртуальных функций.

    class Base {
    public:
        virtual void f();
    };

    class Derived : public Base {
        int x;
    public:
        void f();
    };
В данном примере функция *f* в базовом классе объявлена виртуальной для того, чтобы ее можно было определить в любом производном классе. Класс *Derived* наследует класс *Base*, наследуя и виртуальную функцию *f*. Имея собственное определение этой функции, он может быть использован в рамках вычислительного процесса в тех случаях, когда пользователь обращается к классу *Base*.  

    void check(Base &b) {
        b.f();
    }
    // несмотря на то, что вызывается функция f класса Base, выполняется код функции f класса Derived
    Derived d;
    check(d);
Это возможно благодаря тому, что для всей иерархии генерируется *виртуальная таблица* которая связывает имена всех виртуальных функций с их реализациями во всех производных классах.

    vtable for Derived:
            .quad   0
            .quad   typeinfo for Derived
            .quad   Derived::f()
    vtable for Base:
            .quad   0
            .quad   typeinfo for Base
            .quad   Base::f()
    typeinfo for Derived:
            .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
            .quad   typeinfo name for Derived
            .long   0
            .long   1
            .quad   typeinfo for Base
            .quad   0
    typeinfo name for Derived:
            .string "7Derived"
    typeinfo for Base:
            .quad   vtable for __cxxabiv1::__class_type_info+16
            .quad   typeinfo name for Base
    typeinfo name for Base:
            .string "4Base"
Таким образом, важность абстрактных классов заключается в том, что они позволяют четко разграничить код, который полагается на интерфейс, и код, который реализует этот же интерфейс. Дополнительным преимуществом явдяется то, что меньше информации используется для определения процесса, а значит меньше кода нужно компилировать в случае изменений в программе.

Цитируя Строуструпа,
> ООП -- это программирование через наследование. Абстрактные данные -- это программирование с использованием пользовательских типов. За редким исключением, ООП может и должно быть надмножеством абстракции данных.

Если сравнивать то, как наследование устроено в Simula с тем, как оно было в Smalltalk, наследование в С++ ближе к первому случаю.

Класс определяет конкретный набор функций как интерфейс, который реализуется набором конкретных объектов (производных классов). В Smalltalk же класс определяет набор операций для объектов (подклассов). Другими словами, класс в Smalltalk -- это минимальная "спецификация" (формальное описание), и пользователь может попробовать обратиться к объекту с запросом, который не может быть обработан, так как им на самом деле не поддерживается. В С++ класс авно указывает только те операции, которые он поддерживает, и это проверяется компилятором. 

Здесь важно отметить, что эта идея прямо противоречит тому, как ООП определял Алан Кей, для кого, в первую очередь, поздние вычисления являлись важнейшей характеристикой ООП. Но для Строуструпа момент динамического (то есть, не проверяемого компилятором) поведения был принципиальным. Он принял решение,
> Отказаться от всех форм динамического вычисления за исключением виртуальных функций, так как динамическое вычисление не подходит статически-типизируемому языку, где производительность имеет критическое значение.
### Множественное наследование
Первоначально идея множественного наследования заключалась в том, что несколько классов можно было комбинировать внутри общего подкласса, чтобы подкласс мог себя вести как любой из своих суперклассов.

    class Base {
    public:
        void f();
    };

    class OtherBase {
    public:
        void g();
    };
    
    void check(Base &b, OtherBase o) {
        b.f();
        o.g();
    }

    class Derived : public Base, public OtherBase {
    // множественное наследование позволяет включать реализацию из нескольких классов
        int y;
    };

    Derived d;
    // в классе Derived не объявлены функции f и g, но они доступны через него
    check(d, d);
У этой идеи есть как сторонники, так и противники. Противники указывают на две потенциальные проблемы. Первая проблема заключается в том, что если из самого объекта не возможно получить информацию о том, сколько у него суперклассов, очень трудно себе представить и учитывать все зависимости в такой иерархии. Также не очень понятна практическая польза от такого наследования. К тому же, использование классов, которые имеют больше одного предка, в других частях программы может привести к проблемам, которые тяжело диагностировать.

Примером такой проблемы является "ромбовидное" (diamond) наследование. Выглядит оно примерно так.

    class Base {
        int x;
    };

    class MiddleLeft : public Base {};

    class MiddleRight : public Base {};

    class Derived : public MiddleLeft, public MiddleRight {
        int y;
    public:
        void f();
    };
Теперь вопрос стоит следующим образом: сколько переменных *x* в классе *Derived*? 

Тем не менее, были пользователи, которые ценили возмжность использовать множественное наследование когда это остро необходимо. Как говорил Грэди Буч, 
> Множественное наследование как паращют: часто он не нужен, но когда нужен, хорошо, чтобы он был.
### Шаблоны
В С++ долгое время не было своей стандартной библиотеки со структурами данных и алгоритмами. Основной причиной этого было отсутствие статического полиморфизма в явном виде, который бы устраивал Строуструпа. Нужны были механизмы создания обобщенных контейнеров и функций, а от виртуальных функций отказались, так как они статически не проверяли типы аргументов. 

> Есть два подхода к созданию generic-классов: либо через динамическую типизацию и наследование, как в Smalltalk, или через статическую типизацию и механизм параметризации типов. Первый способ очень гибкий, но обходится дорого и, что важнее, не позволяет определять ошибки вызова методов при компиляции. Поэтому в С++ выбрали второй способ.
### Исключения
Еще один механизм, который использовал наследование в С++ -- это обработка исключительных ситуаций. Для этого в язык доавили иерархию исключений как классов. Их дизайн опирался на следующие предположения.
* исключения используются, в первую очередь, для обработки ошибок
* обработчики исключений встречаются в коде редко
* исключения происходят редко относительно того, как часто вызываются функции
* исключения не должны пагубно влиять на взаимную совместимость С++ с языками типа С или Fortran, где нет исключений

Результатом стал дизайн исключений, где они передавались на многих уровнях. Не каждая функция должна ловить исключения, и лучшие стратегии обработки ошибок, как правило, применяют для этого специальные интерфейсы.

Больше всего споров вызвал вопрос относительно того, должны ли исключения завершать или продолжать процесс при возникновении исключительной ситуации с того места, где это произошло. Основываясь на опыте пользователей других систем, в которых встречались оба подхода, в итоге комитет С++ пришел к единому мнению, что исключения должны завершать процесс по умолчанию.

Пример обработки исключений представлен ниже.

    class Exception {
    public:
        virtual const char* error() const = 0;
    };

    class WrongFormatException : public Exception {
    public:
        const char* error() const {}
    };

    class WrongLengthException : public Exception {
    public:
        const char* error() const {}
    };

    class WrongFormatAndLengthException : public WrongFormatException, public WrongLengthException {};

    void check() {
        throw WrongLengthException();
    }

    try {
        check();
    } catch (const Exception& e) {
        std::println(e.error());
    }
Так как все классы образуют общую иерархию, блок *try-catсh* может обрабатывать любое из исключений, общим предком которых является класс Exception. Если же стратегия обработки для разных классов в рамках одной иерархии отличается, их можно ловить выборочно, от более специального к менее:

    try {
        check();
    } catch (const WrongFormatException& e) {
        // здесь обработается только этот тип и его дочерние типы
    } catch (const WrongLengthException& e) {
        // здесь обработается только этот тип и его дочерние типы
    } catch (const Exception& e) {
        std::println(e.error());
    }
Более подробно исключения рассматриваются в отдельной главе.