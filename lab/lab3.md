# Лабораторная работа 3
## Перегрузка функций, методов, операторов
### Задание
Необходимо написать код, который иллюстрирует принципы перегрузки функций, методов и операторов в языке С++. Перегрузка функции обозначает наличие в программе нескольких функций с одним и тем же именем, но разными списками аргументов. Перегрузка методов означает то же самое, но в рамках какого-то класса. Перегрузка операторов соединяет два предыдущих принципа. 

Композиция данных и функциональность написанного кода может быть произвольной.

В функции main нужно показать работоспособность всех операций, созданных для задания.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
### Контрольные вопросы
1. В чем заключается суть перегрузки функций или методов?
2. С какой целью перегружают операторы для своего класса?
3. Как работают операторы сравнения (например, == и <)?
4. Как перегрузка функций связана с полиморфизмом?
5. Почему перегрузку иногда называют "мнимым" полиморфизмом?
### Задание по выбору (опциональное)
Используя предыдущую лабораторную с помощью класса необходимо реализовать для своего варианта абстрактный тип данных, который скрывает внутренние поля с данными. Для реализации простейших операций над объектами класса необходимо добавить в класс все нужные операторы. Ниже показаны примеры прототипов, из которых складывается интерфейс абстрактного типа данных.

Оператор присваивания копированием operator= принимает один аргумент – константную ссылку (&) на объект заданного класса. Оператор выполняет замену всех элементов коллекции объекта слева  от оператора на копии элементов коллекции объекта справа от оператора. Данный оператор семантически схож с конструктором копирования, поэтому в некоторых ситуациях они могут быть взаимозаменяемы. Оператор присваивания возвращает ссылку на измененный объект. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.
```C++
    public:
        example &operator=(const example&);
```
Оператор присваивания переносом operator= принимает один аргумент – rvalue-ссылку (&&) на объект заданного класса. Оператор выполняет замену всех элементов коллекции объекта слева от оператора на элементы коллекции объекта справа от оператора. Объект справа очищается. Данный оператор семантически схож с конструктором переноса, поэтому в некоторых ситуациях они могут быть взаимозаменяемы. Оператор присваивания возвращает ссылку на измененный объект. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.
```C++
    public:
        example &operator=(example&&) noexcept;
```
Оператор сравнения operator== принимает два аргумента: константную ссылку (&) на объект заданного класса слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргументы равны, и “ложь” в противном случае. Объекты считаются равными, если равны их коллекции. Коллекции равны, если они содержат равное количество элементов, а также – если значение каждого элемента одной коллекции равно элементу другой коллекции на том же месте. Данный оператор повторяет логику метода is_equal. Аналогично реализуется обратный оператор сравнения operator!=. 
```C++
    public:
        friend bool operator==(const example&, const example&);
        friend bool operator!=(const example&, const example&);
```
Оператор сравнения operator< принимает два аргумента: константную ссылку (&) на объект заданного класса слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Оператор возвращает булевое значение: “истинность”, если аргумент слева от оператора строго меньше аргумента справа от оператора, и “ложь” в противном случае. Сравнение производится лексикографически. Аналогично реализуются операторы operator<=, operator>, operator>=.
```C++
    public:
        friend bool operator<(const example&, const example&);
        friend bool operator>(const example&, const example&);
        friend bool operator<=(const example&, const example&);
        friend bool operator>=(const example&, const example&);
```
Оператор ввода из потока данных operator>> принимает два аргумента: ссылку (&) на поток данных слева от оператора и константную ссылку (&) на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из потока данных слева в объект справа от оператора. Оператор возвращает ссылку на измененный поток ввода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат. 
```C++
    public:
        friend std::istream &operator>>(std::istream&, example&);
```
Оператор вывода в поток данных operator<< принимает два аргумента: ссылку (&) на поток данных слева от оператора и ссылку (&) на объект заданного класса справа от оператора. Результатом вызова оператора должно быть копирование информации из объекта справа в поток данных слева от оператора. Оператор возвращает ссылку на измененный поток вывода. Это необходимо для того, чтобы данный оператор можно было вызывать на собственный результат.
```C++
    public:
        friend std::ostream &operator<<(std::ostream&, const example&);
```
Оператор доступа по индексу operator[] принимает единственный аргумент – беззнаковое целое число, обозначающее позицию элемента в массиве. возвращает ссылку на элемент коллекции, находящийся по заданному индексу. В отличие от метода at не проверяет индекс на несоответствие размеру коллекции. В случаях, когда pos >= size(), поведение метода не определено. Асимптотичность метода постоянная – O(1).
```C++
    public:
        int &operator[](size_t);
```
Метод count принимает один аргумент – целое число – и возвращает количество элементов коллекции, значение которых равно значению аргумента.
```C++
    public:
        size_t count(int) const;
```
Метод contains принимает один аргумент – целое число – и возвращает булевое значение: “истинность”, если значение аргумента равно значению хотя бы одного элемента коллекции, и “ложь” в противном случае.
```C++
    public:
        bool contains(int) const;
```
Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:
```C++
class example {
private:
    // необходимые поля здесь
public:
    // методы из предыдущей лабораторной работы здесь

    example &operator=(const example&);
    example &operator=(example&&) noexcept;
    friend bool operator==(const example&, const example&);
    friend bool operator!=(const example&, const example&);
    friend bool operator<(const example&, const example&);
    friend bool operator>(const example&, const example&);
    friend bool operator<=(const example&, const example&);
    friend bool operator>=(const example&, const example&);
    int &operator[](size_t);
    friend std::ostream &operator<<(std::ostream&, const example&);
    friend std::istream &operator>>(std::istream&, example&);
    bool contains(int);
    size_t count(int);
};
```
### Контрольные вопросы
1. Где в вашем классе использовалась перегрузка?
2. Какие 2 оператора являются особенными и генерируются компилятором во всех классах по-умолчанию?
3. Как работают операторы сравнения для заданного варианта?
4. Почему некоторые бинарные операторы нужно объявлять как "дружественные"?
5. В чем принципиальная разница между конструктором копирования и оператором копирования?
6. Почему операторы ввода (<<) и вывода (>>) не могут быть членами класса?
7. Почему полезно определять две версии оператора доступа ([])?