# Лабораторная работа 5
## Обобщенное программирование, шаблоны функций, статический полиморфизм
### Задание
Необходимо написать код, который иллюстрирует использование шаблонов в языке С++. С помощью ключевых слов auto и template нужно написать обобщенные функции, которые принимают диапазоны любой длины, объекты любого типа, произвольное количество аргументов.

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
### Контрольные вопросы
1. С какой целью определяют шаблонные параметры для функции?
2. Как ключевое слово auto работает в комбинации с шаблонами?
3. В чем суть обобщенных функций? Как это влияет на написание алгоритмов?
4. Какие требования накладываются на тип аргумента(ов) при вызове шаблонной функции в зависимости от тела функции?
## Шаблоны типов
### Задание по выбору (опциональное)
Используя код из предыдущей лабораторной работы необходимо создать шаблонный тип данных, где шаблонный параметр(ы) выступает в роли интерфейса.
```C++
template <typename T, typename U> class example {
private:

public:

};
```
Метод find принимает аргумент заданного в шаблоне типа, соответствующий типу данных хранящихся в контейнере элементов, и возвращает итератор на элемент контейнера, значение которого равно значению аргумента.
```C++
    public:
        iterator find(const T&) const;
```
Метод insert имеет два параметра: итератор, указывающий на существующий в коллекции элемент, и ссылку на значение заданного для коллекции типа. Метод возвращает итератор на новый элемент коллекции. Метод сохраняет элементы, которые уже существуют в коллекции на момент вызова, сдвигая их на один вправо относительно значения первого аргумента. Если новый размер превышает выделенный до сих пор под коллекцию объем памяти, метод вызывает выделение нового блока памяти. При этом все ссылки и итераторы, существующие в программе, которые указывают на элементы, идущие за значением первого аргумента, становятся недействительными Асимптотичность метода линейная относительно длины оставшейся за индексом части коллекции – O(n).
```C++
    public:
        iterator insert(iterator, const T&);
```
Метод erase принимает один аргумент – итератор, обозначающий желаемую позицию элемента на удаление. Метод возвращает итератор на элемент, следующий за удаленным. Метод сохраняет элементы, которые уже существуют в коллекции на момент вызова, сдвигая их на один влево относительно pos. При этом все ссылки и итераторы, существующие в программе, которые указывают на элементы, идущие за pos, становятся недействительными Асимптотичность метода линейная относительно длины оставшейся за индексом части коллекции – O(n).
```C++
    public:
        iterator erase(iterator);
        static size_t erase(example<T>&, const T&);
```
Т.о. полный интерфейс класса, в зависимости от варианта, будет выглядеть так:
```C++
template <typename T, typename U>
class example {
private:
    // необходимые поля здесь
public:
    // методы и классы из четвертой лабораторной работы здесь
    // добавить шаблоны по необходимости

    iterator find(const T&) const;
    iterator insert(iterator, const T&);
    iterator erase(iterator);
    static size_t erase(example<T>&, const T&);
};
```
### Контрольные вопросы
1. С какой целью определяют шаблонные параметры для класса?
2. В чем отличие шаблонных классов от абстрактных классов для объявления интерфейсов? В чем сходство?
3. Какая разница между динамическим и статическим полиморфизмом?