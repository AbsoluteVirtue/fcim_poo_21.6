# Лабораторная работа 7
## Обработка ошибок, исключения
### Задание
Необходимо написать код, который иллюстрирует использование исключений для обработки исключительных ситуаций. Используя ключевые слова throw, try и catch, нужно обработать несколько разных ислючений. Также нужно показать эффект исключений разных типов в рамках одного блока try-catch и восстановление программы после обработки исключения.

Далее нужно создать свой тип исключений -- так, чтобы его обработка гармонично сочеталась с обработкой встроенных типов ислючений.

Композиция данных и функциональность написанного кода может быть произвольной.

Необходимо написать подробный отчет, в котором объясняются все использованные для выполнения задания механики и свойства языка С++.
### Контрольные вопросы
1. Какие ситуации, возникающие в программах, считаются исключительными и требуют для своей обработки использование исключений?
2. Чем механизм обработки исключений отличается от использования (assert) в аналогичных ситуациях?
3. Что происходит с объектами, объявленными в блоке try в момент возникновения исключительной ситуации (throw)? 
4. Что нужно иметь ввиду при определении блока catch (например, в зависимости от видов объектов, объявленных в блоке try)?
5. В каком порядке активируются блоки catch, когда несколько таких блоков ассоциируется с одним блоком try?
6. Что нужно обязательно определять для пользовательских исключений, чтобы их можно было обрабатывать с помощью стандартного класса std::exception?
7. Какие способы обработки ошибок помимо исключений принято использовать в аналогичных ситуациях?
## Контрактное проектирование, концепции
### Задание по выбору (опциональное)
Используя код из предыдущей лабораторной, необходимо дополнить методы своего класса (или классов) проверками во время компиляции для соблюдения контрактов и отсутствия неопределенности в поведении программы. Например, контейнеры, которые предоставляют метод push_back подвержены неопределенному поведению в случаях, когда этот метод вызывается на пустой контейнер.
> If empty() is true, the behavior is undefined.

Другими словами, поведение метода невозможно предугадать, так как стандарт языка по этому поводу ничего не может сказать (более того, компилятор имеет право предположить, что эта ситуация никогда не произойдет). Реализация метода в таком случае может быть любой.
```C++
void pop_back_hardened(auto &data) {
    if constexpr (
        requires { 
            { data.empty() };
            { data.pop_back() };
        }
    ) if (data.empty()) data.pop_back();
}
```
-- фрагмент кода выше использует ключевое слово requires, которое позволяет определить некоторое ограничение на заданный тип или объект. В данном примере ограничивается возможность вызова pop_back на котнейнер data, если у него нет методов pop_back и empty.
> https://en.cppreference.com/w/cpp/language/constraints.html

Проверкам с использованием ключевого слова requires можно задавать имена, такие именованные проверки называются концепциями и определяются с помощью ключевого слова concept.
```C++
template <class T> 
concept poppable = requires (T c) {
    { c.empty() } -> std::same_as<bool>;
    { c.pop_back() } -> std::same_as<void>;
};

void pop_back_hardened(poppable auto &data) {
    if (data.empty()) data.pop_back();
}
```
Ключевое слово concept расширяет шаблоны типов, позволяя накладывать ограничения на шаблонные параметры. В новом примере блок requires определен как концепция и может быть включен в функцию на правах шаблонного параметра. Дополнительно, можно проверять возвращаемые типы методов. Концепции используют библиотеку type_traits.
> https://en.cppreference.com/w/cpp/meta.html

Перечень встроенных в стандартную библиотеку концепций можно посмотреть по ссылке: 
> https://en.cppreference.com/w/cpp/concepts.html

Другой способ проверять выполнение предусловия или постусловия при вызове методов -- использовать ключевые слова pre, post:
```C++
void pop_back_hardened(auto &data) pre(!data.empty()) {
    data.pop_back();
}
```
Данный способ пока что не поддерживается современными компиляторами.
> https://en.cppreference.com/w/cpp/language/contracts.html
### Контрольные вопросы
1. Что такое "неопределенное поведение" (UB)? Чем оно может быть опасно?
2. Как ограничения на типах (type traits) позволяют избегать неопределенного поведения?
3. Как используются шаблоны для создания именованных ограничений (concepts)?
4. Как можно явно обозначить контракт, используя эти возможности языка С++?
5. В чем отличие именованных ограничений от абстрактных классов для объявления интерфейсов? В чем сходство?